{"version":3,"file":"category.min.js","sources":["../src/category.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * The category component.\r\n *\r\n * @module     qbank_managecategories/category\r\n * @class      qbank_managecategories/category\r\n */\r\n\r\nimport {BaseComponent, DragDrop} from 'core/reactive';\r\nimport {categorymanager} from 'qbank_managecategories/categorymanager';\r\nimport Templates from 'core/templates';\r\nimport Modal from \"core/modal\";\r\nimport {get_string as getString} from \"core/str\";\r\n\r\nexport default class extends BaseComponent {\r\n\r\n    create(descriptor) {\r\n        this.name = descriptor.element.id;\r\n        this.selectors = {\r\n            CATEGORY_LIST: '.qbank_managecategories-categorylist',\r\n            CATEGORY_ITEM: '.qbank_managecategories-item[data-categoryid]',\r\n            CATEGORY_CONTENTS: '.qbank_managecategories-item > .container',\r\n            EDIT_BUTTON: '[data-action=\"addeditcategory\"]',\r\n            MOVE_BUTTON: '[role=\"menuitem\"][data-actiontype=\"move\"]',\r\n            CONTEXT: '.qbank_managecategories-categorylist[data-contextid]',\r\n            MODAL_CATEGORY_ITEM: '.modal_category_item[data-movingcategoryid]',\r\n            CONTENT_AREA: '.qbank_managecategories-details',\r\n            CATEGORY_ID: id => `#category-${id}`,\r\n            CONTENT_CONTAINER: id => `#category-${id} .qbank_managecategories-childlistcontainer`,\r\n            CHILD_LIST: id => `ul[data-categoryid=\"${id}\"]`,\r\n            PREVIOUS_SIBLING: sortorder => `:scope > [data-sortorder=\"${sortorder}\"]`,\r\n        };\r\n        this.classes = {\r\n            NO_BOTTOM_PADDING: 'pb-0',\r\n            DRAGHANDLE: 'draghandle',\r\n            DROPTARGET: 'qbank_managecategories-droptarget-before',\r\n        };\r\n        this.ids = {\r\n            CATEGORY: id => `category-${id}`,\r\n        };\r\n    }\r\n\r\n    stateReady() {\r\n        this.initDragDrop();\r\n        this.addEventListener(this.getElement(this.selectors.EDIT_BUTTON), 'click', categorymanager.showEditModal);\r\n        const moveButton = this.getElement(this.selectors.MOVE_BUTTON);\r\n        this.addEventListener(moveButton, 'click', this.showMoveModal);\r\n    }\r\n\r\n    destroy() {\r\n        // The draggable element must be unregistered.\r\n        this.deInitDragDrop();\r\n    }\r\n\r\n    /**\r\n     * Remove any existing DragDrop component, and create a new one.\r\n     */\r\n    initDragDrop() {\r\n        this.deInitDragDrop();\r\n        // If the element is currently draggable, register the getDraggableData method.\r\n        if (this.element.classList.contains(this.classes.DRAGHANDLE)) {\r\n            this.getDraggableData = this._getDraggableData;\r\n        }\r\n        this.dragdrop = new DragDrop(this);\r\n    }\r\n\r\n    /**\r\n     * If the DragDrop component is currently registered, unregister it.\r\n     */\r\n    deInitDragDrop() {\r\n        if (this.dragdrop !== undefined) {\r\n            if (this.getDraggableData !== undefined) {\r\n                this.dragdrop.setDraggable(false);\r\n                this.getDraggableData = undefined;\r\n            }\r\n            this.dragdrop.unregister();\r\n            this.dragdrop = undefined;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Static method to create a component instance.\r\n     *\r\n     * @param {string} target the DOM main element or its ID\r\n     * @param {object} selectors optional css selector overrides\r\n     * @return {Component}\r\n     */\r\n    static init(target, selectors) {\r\n        return new this({\r\n            element: document.querySelector(target),\r\n            selectors,\r\n            reactive: categorymanager,\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Return the category ID from the component's element.\r\n     *\r\n     * This method is referenced as getDraggableData when the component can be dragged.\r\n     *\r\n     * @return {{id: string}}\r\n     * @private\r\n     */\r\n    _getDraggableData() {\r\n        return {\r\n            id: this.getElement().dataset.categoryid\r\n        };\r\n    }\r\n\r\n    validateDropData() {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Highlight the top border of the category item.\r\n     *\r\n     * @param {Object} dropData\r\n     */\r\n    showDropZone(dropData) {\r\n        if (this.getElement().closest(this.selectors.CATEGORY_ID(dropData.id))) {\r\n            // Can't drop onto itself or its own child.\r\n            return false;\r\n        }\r\n        this.getElement().classList.add(this.classes.DROPTARGET);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Remove highlighting.\r\n     */\r\n    hideDropZone() {\r\n        this.getElement().classList.remove(this.classes.DROPTARGET);\r\n    }\r\n\r\n    /**\r\n     * Find the new position of the dropped category, and trigger the move.\r\n     *\r\n     * @param {Object} dropData The category being moved.\r\n     * @param {Event} event The drop event.\r\n     */\r\n    drop(dropData, event) {\r\n        const dropTarget = event.target.closest(this.selectors.CATEGORY_ITEM);\r\n\r\n        if (!dropTarget) {\r\n            return;\r\n        }\r\n\r\n        if (dropTarget.closest(this.selectors.CATEGORY_ID(dropData.id))) {\r\n            // Can't drop onto your own child.\r\n            return;\r\n        }\r\n\r\n        const source = document.getElementById(this.ids.CATEGORY(dropData.id));\r\n\r\n        if (!source) {\r\n            return;\r\n        }\r\n\r\n        const targetParentId = dropTarget.dataset.parent;\r\n        const parentList = dropTarget.closest(this.selectors.CATEGORY_LIST);\r\n        let precedingSibling;\r\n\r\n        if (dropTarget === parentList.firstElementChild) {\r\n            // Dropped at the top of the list.\r\n            precedingSibling = null;\r\n        } else {\r\n            precedingSibling = dropTarget.previousElementSibling;\r\n        }\r\n\r\n        // Insert the category after the target category\r\n        categorymanager.moveCategory(dropData.id, targetParentId, precedingSibling?.dataset.categoryid);\r\n    }\r\n\r\n    getWatchers() {\r\n        return [\r\n            // After any update to this category, move it to the new position.\r\n            {watch: `categories[${this.element.dataset.categoryid}]:updated`, handler: this.updatePosition},\r\n            // When the template context is added or updated, re-render the content.\r\n            {watch: `categories[${this.element.dataset.categoryid}].templatecontext:created`, handler: this.rerender},\r\n            {watch: `categories[${this.element.dataset.categoryid}].templatecontext:updated`, handler: this.rerender},\r\n            // When a new category is created, check whether we need to add a child list to this category.\r\n            {watch: `categories:created`, handler: this.checkChildList},\r\n        ];\r\n    }\r\n\r\n    /**\r\n     * Re-render the category content.\r\n     *\r\n     * @param {Object} args\r\n     * @param {Element} args.element\r\n     * @return {Promise<Array>}\r\n     */\r\n    async rerender({element}) {\r\n        const {html, js} = await Templates.renderForPromise(\r\n            'qbank_managecategories/category_details',\r\n            element.templatecontext\r\n        );\r\n        return Templates.replaceNodeContents(this.getElement(this.selectors.CONTENT_AREA), html, js);\r\n    }\r\n\r\n    /**\r\n     * Render and append a new child list.\r\n     *\r\n     * @param {Object} context Template context, must include at least categoryid.\r\n     * @return {Promise<Element>}\r\n     */\r\n    async createChildList(context) {\r\n        const {html, js} = await Templates.renderForPromise(\r\n            'qbank_managecategories/childlist',\r\n            context,\r\n        );\r\n        const parentContainer = document.querySelector(this.selectors.CONTENT_CONTAINER(context.categoryid));\r\n        await Templates.appendNodeContents(parentContainer, html, js);\r\n        const childList = document.querySelector(this.selectors.CHILD_LIST(context.categoryid));\r\n        childList.closest(this.selectors.CATEGORY_CONTENTS).classList.add(this.classes.NO_BOTTOM_PADDING);\r\n        return childList;\r\n    }\r\n\r\n    /**\r\n     * Move a category to its new position.\r\n     *\r\n     * A category may change its parent, sortorder and draghandle independently or at the same time. This method will resolve those\r\n     * changes and move the element to the new position. If the parent doesn't already have a child list, one will be created.\r\n     *\r\n     * If the parent has changed, this will also update the state with the new child count of the old and new parents.\r\n     *\r\n     * @param {Object} args\r\n     * @param {Object} args.element\r\n     * @return {Promise<void>}\r\n     */\r\n    async updatePosition({element}) {\r\n        window.console.log('updating', this.getElement());\r\n        window.console.log('new state', element);\r\n        // Move to a new parent category.\r\n        let newParent;\r\n        const originParent = document.querySelector(this.selectors.CHILD_LIST(this.getElement().dataset.parent));\r\n        if (parseInt(this.getElement().dataset.parent) !== element.parent) {\r\n            newParent = document.querySelector(this.selectors.CHILD_LIST(element.parent));\r\n            if (!newParent) {\r\n                // The target category doesn't have a child list yet. We'd better create one.\r\n                newParent = await this.createChildList({categoryid: element.parent});\r\n            }\r\n            this.getElement().dataset.parent = element.parent;\r\n        } else {\r\n            newParent = this.getElement().parentElement;\r\n        }\r\n        window.console.log('newParent', newParent);\r\n\r\n        // Move to a new position within the parent.\r\n        let previousSibling;\r\n        let nextSibling;\r\n        if (newParent.firstElementChild && parseInt(element.sortorder) <= parseInt(newParent.firstElementChild.dataset.sortorder)) {\r\n            // Move to the top of the list.\r\n            nextSibling = newParent.firstElementChild;\r\n        } else {\r\n            // Move later in the list.\r\n            previousSibling = newParent.querySelector(this.selectors.PREVIOUS_SIBLING(element.sortorder - 1));\r\n            nextSibling = previousSibling?.nextElementSibling;\r\n        }\r\n        window.console.log('previousSibling', previousSibling);\r\n        window.console.log('nextSibling', nextSibling);\r\n\r\n        // Check if this has actually moved, or if it's just having its sortorder updated due to another element moving.\r\n        const moved = (newParent !== this.getElement().parentElement || nextSibling !== this.getElement());\r\n\r\n        window.console.log('moved', moved);\r\n\r\n        if (moved) {\r\n            if (nextSibling) {\r\n                window.console.log('insertBefore');\r\n                // Move to the specified position in the list.\r\n                newParent.insertBefore(this.getElement(), nextSibling);\r\n            } else {\r\n                window.console.log('appendChild');\r\n                // Move to the end of the list (may also be the top of the list is empty).\r\n                newParent.appendChild(this.getElement());\r\n            }\r\n        }\r\n        if (originParent !== newParent) {\r\n            // Update child count of old and new parent.\r\n            this.reactive.stateManager.processUpdates([\r\n                {\r\n                    name: 'categoryLists',\r\n                    action: 'put',\r\n                    fields: {\r\n                        id: originParent.dataset.categoryid,\r\n                        childCount: originParent.querySelectorAll(this.selectors.CATEGORY_ITEM).length\r\n                    }\r\n                },\r\n                {\r\n                    name: 'categoryLists',\r\n                    action: 'put',\r\n                    fields: {\r\n                        id: newParent.dataset.categoryid,\r\n                        childCount: newParent.querySelectorAll(this.selectors.CATEGORY_ITEM).length\r\n                    }\r\n                }\r\n            ]);\r\n        }\r\n\r\n        this.element.dataset.sortorder = element.sortorder;\r\n\r\n        // Enable/disable dragging.\r\n        const isDraggable = this.element.classList.contains(this.classes.DRAGHANDLE);\r\n        if (isDraggable && !element.draghandle) {\r\n            this.element.classList.remove(this.classes.DRAGHANDLE);\r\n            this.initDragDrop();\r\n        } else if (!isDraggable && element.draghandle) {\r\n            this.element.classList.add(this.classes.DRAGHANDLE);\r\n            this.initDragDrop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Recursively create a list of all valid destinations for a current category within a parent category.\r\n     *\r\n     * @param {Element} item\r\n     * @param {Number} movingCategoryId\r\n     * @return {Array<Object>}\r\n     */\r\n    createMoveCategoryList(item, movingCategoryId) {\r\n        const categories = [];\r\n        if (item.children) {\r\n            let precedingSibling = null;\r\n            item.children.forEach(category => {\r\n                const categoryId = parseInt(category.dataset.categoryid);\r\n                // Don't create a target for the category that's moving.\r\n                if (categoryId === movingCategoryId) {\r\n                    return;\r\n                }\r\n                // Create a target to move before this child.\r\n                let child = {\r\n                    categoryid: categoryId,\r\n                    movingcategoryid: movingCategoryId,\r\n                    precedingsiblingid: precedingSibling?.dataset.categoryid ?? 0,\r\n                    parent: category.dataset.parent,\r\n                    categoryname: category.dataset.categoryname,\r\n                    categories: null,\r\n                    current: categoryId === movingCategoryId,\r\n                };\r\n                const childList = category.querySelector(this.selectors.CATEGORY_LIST);\r\n                if (childList) {\r\n                    // If the child has its own children, recursively make a list of those.\r\n                    child.categories = this.createMoveCategoryList(childList, movingCategoryId);\r\n                } else {\r\n                    // Otherwise, create a target to move as a new child of this one.\r\n                    child.categories = [\r\n                        {\r\n                            movingcategoryid: movingCategoryId,\r\n                            precedingsiblingid: 0,\r\n                            parent: categoryId,\r\n                            categoryname: category.dataset.categoryname,\r\n                            categories: null,\r\n                            newchild: true,\r\n                        }\r\n                    ];\r\n                }\r\n                categories.push(child);\r\n                precedingSibling = category;\r\n            });\r\n            const precedingId = parseInt(precedingSibling.dataset.categoryid);\r\n            if (precedingId !== movingCategoryId) {\r\n                // If this is the last child of its parent, also create a target to move the category after this one.\r\n                categories.push({\r\n                    movingcategoryid: movingCategoryId,\r\n                    precedingsiblingid: precedingId,\r\n                    parent: precedingSibling.dataset.parent,\r\n                    categoryname: precedingSibling.dataset.categoryname,\r\n                    categories: null,\r\n                    lastchild: true,\r\n                });\r\n            }\r\n        }\r\n        return categories;\r\n    }\r\n\r\n    /**\r\n     * Displays a modal containing links to move the category to a new location.\r\n     *\r\n     * @param {Event} e Button click event.\r\n     */\r\n    async showMoveModal(e) {\r\n        // Return if it is not menu item.\r\n        const item = e.target;\r\n        if (!item) {\r\n            return;\r\n        }\r\n        // Return if it is disabled.\r\n        if (item.getAttribute('aria-disabled') === 'true') {\r\n            return;\r\n        }\r\n\r\n        // Prevent addition click on the item.\r\n        item.setAttribute('aria-disabled', true);\r\n\r\n        // Build the list of move links.\r\n        let moveList = {contexts: []};\r\n        const contexts = document.querySelectorAll(this.selectors.CONTEXT);\r\n        contexts.forEach(context => {\r\n            const moveContext = {\r\n                contextname: context.dataset.contextname,\r\n                categories: [],\r\n                hascategories: false,\r\n            };\r\n            moveContext.categories = this.createMoveCategoryList(context, parseInt(item.dataset.categoryid));\r\n            moveContext.hascategories = moveContext.categories.length > 0;\r\n            moveList.contexts.push(moveContext);\r\n        });\r\n\r\n        const modal = await Modal.create({\r\n            title: getString('movecategory', 'qbank_managecategories', item.dataset.categoryname),\r\n            body: Templates.render('qbank_managecategories/move_context_list', moveList),\r\n            footer: '',\r\n            show: true,\r\n            large: true,\r\n        });\r\n        // Show modal and add click event for list items.\r\n        modal.getBody()[0].addEventListener('click', e => {\r\n            const target = e.target.closest(this.selectors.MODAL_CATEGORY_ITEM);\r\n            if (!target) {\r\n                return;\r\n            }\r\n            categorymanager.moveCategory(target.dataset.movingcategoryid, target.dataset.parent, target.dataset.precedingsiblingid);\r\n            modal.destroy();\r\n        });\r\n        item.setAttribute('aria-disabled', false);\r\n    }\r\n\r\n    /**\r\n     * Check and add a child list if needed.\r\n     *\r\n     * Check whether the category that has just been added has this category as its parent. If it does,\r\n     * check that this category has a child list, and if not, add one.\r\n     *\r\n     * @param {Object} args\r\n     * @param {Element} args.element The new category.\r\n     * @return {Promise<Element>}\r\n     */\r\n    async checkChildList({element}) {\r\n        if (element.parent !== this.getElement().dataset.categoryid) {\r\n            return null; // Not for me.\r\n        }\r\n        let childList = this.getElement(this.selectors.CATEGORY_LIST);\r\n        if (childList) {\r\n            return null; // List already exists, it will handle adding the new category.\r\n        }\r\n        // Render and add a new child list containing the new category.\r\n        return this.createChildList({\r\n            categoryid: element.parent,\r\n            children: [\r\n                element.templatecontext,\r\n            ]\r\n        });\r\n    }\r\n}\r\n"],"names":["_interopRequireDefault","e","__esModule","default","_templates","_modal","_default","BaseComponent","create","descriptor","this","name","element","id","selectors","CATEGORY_LIST","CATEGORY_ITEM","CATEGORY_CONTENTS","EDIT_BUTTON","MOVE_BUTTON","CONTEXT","MODAL_CATEGORY_ITEM","CONTENT_AREA","CATEGORY_ID","CONTENT_CONTAINER","CHILD_LIST","PREVIOUS_SIBLING","sortorder","classes","NO_BOTTOM_PADDING","DRAGHANDLE","DROPTARGET","ids","CATEGORY","stateReady","initDragDrop","addEventListener","getElement","categorymanager","showEditModal","moveButton","showMoveModal","destroy","deInitDragDrop","classList","contains","getDraggableData","_getDraggableData","dragdrop","DragDrop","undefined","setDraggable","unregister","init","target","document","querySelector","reactive","dataset","categoryid","validateDropData","showDropZone","dropData","closest","add","hideDropZone","remove","drop","event","dropTarget","getElementById","targetParentId","parent","parentList","precedingSibling","firstElementChild","previousElementSibling","moveCategory","getWatchers","watch","handler","updatePosition","rerender","checkChildList","_ref","html","js","Templates","renderForPromise","templatecontext","replaceNodeContents","createChildList","context","parentContainer","appendNodeContents","childList","_ref2","newParent","window","console","log","originParent","previousSibling","nextSibling","parseInt","parentElement","nextElementSibling","moved","insertBefore","appendChild","stateManager","processUpdates","action","fields","childCount","querySelectorAll","length","isDraggable","draghandle","createMoveCategoryList","item","movingCategoryId","categories","children","forEach","category","categoryId","child","movingcategoryid","precedingsiblingid","categoryname","current","newchild","push","precedingId","lastchild","getAttribute","setAttribute","moveList","contexts","moveContext","contextname","hascategories","modal","Modal","title","getString","get_string","body","render","footer","show","large","getBody","_ref3","_exports"],"mappings":"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"}