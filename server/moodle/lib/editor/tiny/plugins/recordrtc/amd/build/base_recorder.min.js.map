{"version":3,"file":"base_recorder.min.js","sources":["../src/base_recorder.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n//\r\n\r\n/**\r\n * Tiny Record RTC type.\r\n *\r\n * @module      tiny_recordrtc/base_recorder\r\n * @copyright   2022 Stevani Andolo <stevani@hotmail.com.au>\r\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport {getString, getStrings} from 'core/str';\r\nimport {component} from './common';\r\nimport Pending from 'core/pending';\r\nimport {getData, isPausingAllowed} from './options';\r\nimport uploadFile from 'editor_tiny/uploader';\r\nimport {add as addToast} from 'core/toast';\r\nimport * as ModalEvents from 'core/modal_events';\r\nimport * as Templates from 'core/templates';\r\nimport {saveCancelPromise} from 'core/notification';\r\nimport {prefetchStrings, prefetchTemplates} from 'core/prefetch';\r\nimport AlertModal from 'core/local/modal/alert';\r\n\r\n/**\r\n * The RecordRTC base class for audio, video, and any other future types\r\n */\r\nexport default class {\r\n\r\n    stopRequested = false;\r\n    buttonTimer = null;\r\n    pauseTime = null;\r\n    startTime = null;\r\n\r\n    /**\r\n     * Constructor for the RecordRTC class\r\n     *\r\n     * @param {TinyMCE} editor The Editor to which the content will be inserted\r\n     * @param {Modal} modal The Moodle Modal that contains the interface used for recording\r\n     */\r\n    constructor(editor, modal) {\r\n        this.ready = false;\r\n\r\n        if (!this.checkAndWarnAboutBrowserCompatibility()) {\r\n            return;\r\n        }\r\n\r\n        this.editor = editor;\r\n        this.config = getData(editor).params;\r\n        this.modal = modal;\r\n        this.modalRoot = modal.getRoot()[0];\r\n        this.startStopButton = this.modalRoot.querySelector('button[data-action=\"startstop\"]');\r\n        this.uploadButton = this.modalRoot.querySelector('button[data-action=\"upload\"]');\r\n        this.pauseResumeButton = this.modalRoot.querySelector('button[data-action=\"pauseresume\"]');\r\n\r\n        // Disable the record button untilt he stream is acquired.\r\n        this.setRecordButtonState(false);\r\n\r\n        this.player = this.configurePlayer();\r\n        this.registerEventListeners();\r\n        this.ready = true;\r\n\r\n        this.captureUserMedia();\r\n        this.prefetchContent();\r\n    }\r\n\r\n    /**\r\n     * Check whether the browser is compatible.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    isReady() {\r\n        return this.ready;\r\n    }\r\n\r\n    // Disable eslint's valid-jsdoc rule as the following methods are abstract and mnust be overridden by the child class.\r\n\r\n    /* eslint-disable valid-jsdoc, no-unused-vars */\r\n\r\n    /**\r\n     * Get the Player element for this type.\r\n     *\r\n     * @returns {HTMLElement} The player element, typically an audio or video tag.\r\n     */\r\n    configurePlayer() {\r\n        throw new Error(`configurePlayer() must be implemented in ${this.constructor.name}`);\r\n    }\r\n\r\n    /**\r\n     * Get the list of supported mimetypes for this recorder.\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/isTypeSupported}\r\n     *\r\n     * @returns {string[]} The list of supported mimetypes.\r\n     */\r\n    getSupportedTypes() {\r\n        throw new Error(`getSupportedTypes() must be implemented in ${this.constructor.name}`);\r\n    }\r\n\r\n    /**\r\n     * Get any recording options passed into the MediaRecorder.\r\n     * Please note that the mimeType will be fetched from {@link getSupportedTypes()}.\r\n     *\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaRecorder/MediaRecorder#options}\r\n     * @returns {Object}\r\n     */\r\n    getRecordingOptions() {\r\n        throw new Error(`getRecordingOptions() must be implemented in ${this.constructor.name}`);\r\n    }\r\n\r\n    /**\r\n     * Get a filename for the generated file.\r\n     *\r\n     * Typically this function will take a prefix and add a type-specific suffix such as the extension to it.\r\n     *\r\n     * @param {string} prefix The prefix for the filename generated by the recorder.\r\n     * @returns {string}\r\n     */\r\n    getFileName(prefix) {\r\n        throw new Error(`getFileName() must be implemented in ${this.constructor.name}`);\r\n    }\r\n\r\n    /**\r\n     * Get a list of constraints as required by the getUserMedia() function.\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#constraints}\r\n     *\r\n     * @returns {Object}\r\n     */\r\n    getMediaConstraints() {\r\n        throw new Error(`getMediaConstraints() must be implemented in ${this.constructor.name}`);\r\n    }\r\n\r\n    /**\r\n     * Whether to start playing the recording as it is captured.\r\n     * @returns {boolean} Whether to start playing the recording as it is captured.\r\n     */\r\n    playOnCapture() {\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Get the time limit for this recording type.\r\n     *\r\n     * @returns {number} The time limit in seconds.\r\n     */\r\n    getTimeLimit() {\r\n        throw new Error(`getTimeLimit() must be implemented in ${this.constructor.name}`);\r\n    }\r\n\r\n    /**\r\n     * Get the name of the template used when embedding the URL in the editor content.\r\n     *\r\n     * @returns {string}\r\n     */\r\n    getEmbedTemplateName() {\r\n        throw new Error(`getEmbedTemplateName() must be implemented in ${this.constructor.name}`);\r\n    }\r\n\r\n    /**\r\n     * Fetch the Class of the Modal to be displayed.\r\n     *\r\n     * @returns {Modal}\r\n     */\r\n    static getModalClass() {\r\n        throw new Error(`getModalClass() must be implemented in ${this.constructor.name}`);\r\n    }\r\n\r\n    /* eslint-enable valid-jsdoc, no-unused-vars */\r\n\r\n    /**\r\n     * Get the options for the MediaRecorder.\r\n     *\r\n     * @returns {object} The options for the MediaRecorder instance.\r\n     */\r\n    getParsedRecordingOptions() {\r\n        const requestedTypes = this.getSupportedTypes();\r\n        const possibleTypes = requestedTypes.reduce((result, type) => {\r\n            result.push(type);\r\n            // Safari seems to use codecs: instead of codecs=.\r\n            // It is safe to add both, so we do, but we want them to remain in order.\r\n            result.push(type.replace('=', ':'));\r\n            return result;\r\n        }, []);\r\n\r\n        const compatTypes = possibleTypes.filter((type) => window.MediaRecorder.isTypeSupported(type));\r\n\r\n        const options = this.getRecordingOptions();\r\n        if (compatTypes.length !== 0) {\r\n            options.mimeType = compatTypes[0];\r\n        }\r\n        window.console.info(\r\n            `Selected codec ${options.mimeType} from ${compatTypes.length} options.`,\r\n            compatTypes,\r\n        );\r\n\r\n        return options;\r\n    }\r\n\r\n    /**\r\n     * Start capturing the User Media and handle success or failure of the capture.\r\n     */\r\n    async captureUserMedia() {\r\n        try {\r\n            const stream = await navigator.mediaDevices.getUserMedia(this.getMediaConstraints());\r\n            this.handleCaptureSuccess(stream);\r\n        } catch (error) {\r\n            this.handleCaptureFailure(error);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Prefetch some of the content that will be used in the UI.\r\n     *\r\n     * Note: not all of the strings used are pre-fetched.\r\n     * Some of the strings will be fetched because their template is used.\r\n     */\r\n    prefetchContent() {\r\n        prefetchStrings(component, [\r\n            'uploading',\r\n            'recordagain_title',\r\n            'recordagain_desc',\r\n            'discard_title',\r\n            'discard_desc',\r\n            'confirm_yes',\r\n            'recordinguploaded',\r\n            'maxfilesizehit',\r\n            'maxfilesizehit_title',\r\n            'uploadfailed',\r\n            'pause',\r\n            'resume',\r\n        ]);\r\n\r\n        prefetchTemplates([\r\n            this.getEmbedTemplateName(),\r\n            'tiny_recordrtc/timeremaining',\r\n        ]);\r\n    }\r\n\r\n    /**\r\n     * Display an error message to the user.\r\n     *\r\n     * @param {Promise<string>} title The error title\r\n     * @param {Promise<string>} content The error message\r\n     * @returns {Promise<Modal>}\r\n     */\r\n    async displayAlert(title, content) {\r\n        const pendingPromise = new Pending('core/confirm:alert');\r\n        const modal = await AlertModal.create({\r\n            title: title,\r\n            body: content,\r\n            removeOnClose: true,\r\n        });\r\n\r\n        modal.show();\r\n        pendingPromise.resolve();\r\n\r\n        return modal;\r\n    }\r\n\r\n    /**\r\n     * Handle successful capture of the User Media.\r\n     *\r\n     * @param {MediaStream} stream The stream as captured by the User Media.\r\n     */\r\n    handleCaptureSuccess(stream) {\r\n        // Set audio player source to microphone stream.\r\n        this.player.srcObject = stream;\r\n\r\n        if (this.playOnCapture()) {\r\n            // Mute audio, distracting while recording.\r\n            this.player.muted = true;\r\n\r\n            this.player.play();\r\n        }\r\n\r\n        this.stream = stream;\r\n        this.setupPlayerSource();\r\n        this.setRecordButtonState(true);\r\n    }\r\n\r\n    /**\r\n     * Setup the player to use the stream as a source.\r\n     */\r\n    setupPlayerSource() {\r\n        if (!this.player.srcObject) {\r\n            this.player.srcObject = this.stream;\r\n\r\n            // Mute audio, distracting while recording.\r\n            this.player.muted = true;\r\n\r\n            this.player.play();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable the record button.\r\n     *\r\n     * @param {boolean|null} enabled Set the button state\r\n     */\r\n    setRecordButtonState(enabled) {\r\n        this.startStopButton.disabled = !enabled;\r\n    }\r\n\r\n    /**\r\n     * Configure button visibility for the record button.\r\n     *\r\n     * @param {boolean} visible Set the visibility of the button.\r\n     */\r\n    setRecordButtonVisibility(visible) {\r\n        const container = this.getButtonContainer('start-stop');\r\n        container.classList.toggle('hide', !visible);\r\n    }\r\n\r\n    /**\r\n     * Configure button visibility for the pause button.\r\n     *\r\n     * @param {boolean} visible Set the visibility of the button.\r\n     */\r\n    setPauseButtonVisibility(visible) {\r\n        if (this.pauseResumeButton) {\r\n            this.pauseResumeButton.classList.toggle('hidden', !visible);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enable the upload button.\r\n     *\r\n     * @param {boolean|null} enabled Set the button state\r\n     */\r\n    setUploadButtonState(enabled) {\r\n        this.uploadButton.disabled = !enabled;\r\n    }\r\n\r\n    /**\r\n     * Configure button visibility for the upload button.\r\n     *\r\n     * @param {boolean} visible Set the visibility of the button.\r\n     */\r\n    setUploadButtonVisibility(visible) {\r\n        const container = this.getButtonContainer('upload');\r\n        container.classList.toggle('hide', !visible);\r\n    }\r\n\r\n    /**\r\n     * Sets the state of the audio player, including visibility, muting, and controls.\r\n     *\r\n     * @param {boolean} state A boolean indicating the audio player state.\r\n     */\r\n    setPlayerState(state) {\r\n        // Mute or unmute the audio player and show or hide controls.\r\n        this.player.muted = !state;\r\n        this.player.controls = state;\r\n        // Toggle the 'hide' class on the player button container based on state.\r\n        this.getButtonContainer('player')?.classList.toggle('hide', !state);\r\n    }\r\n\r\n    /**\r\n     * Handle failure to capture the User Media.\r\n     *\r\n     * @param {Error} error\r\n     */\r\n    handleCaptureFailure(error) {\r\n        // Changes 'CertainError' -> 'gumcertain' to match language string names.\r\n        var subject = `gum${error.name.replace('Error', '').toLowerCase()}`;\r\n        this.displayAlert(\r\n            getString(`${subject}_title`, component),\r\n            getString(subject, component)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Close the modal and stop recording.\r\n     */\r\n    close() {\r\n        // Closing the modal will destroy it and remove it from the DOM.\r\n        // It will also stop the recording via the hidden Modal Event.\r\n        this.modal.hide();\r\n    }\r\n\r\n    /**\r\n     * Register event listeners for the modal.\r\n     */\r\n    registerEventListeners() {\r\n        this.modalRoot.addEventListener('click', this.handleModalClick.bind(this));\r\n        this.modal.getRoot().on(ModalEvents.outsideClick, this.outsideClickHandler.bind(this));\r\n        this.modal.getRoot().on(ModalEvents.hidden, () => {\r\n            this.cleanupStream();\r\n            this.requestRecordingStop();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Prevent the Modal from closing when recording is on process.\r\n     *\r\n     * @param {MouseEvent} event The click event\r\n     */\r\n    async outsideClickHandler(event) {\r\n        if (this.isRecording() || this.isPaused()) {\r\n            // The user is recording.\r\n            // Do not distract with a confirmation, just prevent closing.\r\n            event.preventDefault();\r\n        } else if (this.hasData()) {\r\n            // If there is a blobsize then there is data that may be lost.\r\n            // Ask the user to confirm they want to close the modal.\r\n            // We prevent default here, and then close the modal if they confirm.\r\n            event.preventDefault();\r\n\r\n            try {\r\n                await saveCancelPromise(\r\n                    await getString(\"discard_title\", component),\r\n                    await getString(\"discard_desc\", component),\r\n                    await getString(\"confirm_yes\", component),\r\n                );\r\n                this.modal.hide();\r\n            } catch (error) {\r\n                // Do nothing, the modal will not close.\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle a click within the Modal.\r\n     *\r\n     * @param {MouseEvent} event The click event\r\n     */\r\n    handleModalClick(event) {\r\n        const button = event.target.closest('button');\r\n        if (button && button.dataset.action) {\r\n            const action = button.dataset.action;\r\n            if (action === 'startstop') {\r\n                this.handleRecordingStartStopRequested();\r\n            }\r\n\r\n            if (action === 'upload') {\r\n                this.uploadRecording();\r\n            }\r\n\r\n            if (action === 'pauseresume') {\r\n                this.handleRecordingPauseResumeRequested();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle the click event for the recording start/stop button.\r\n     */\r\n    handleRecordingStartStopRequested() {\r\n        if (this.isRecording() || this.isPaused()) {\r\n            this.requestRecordingStop();\r\n        } else {\r\n            this.startRecording();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle the click event for the recording pause/resume button.\r\n     */\r\n    handleRecordingPauseResumeRequested() {\r\n        if (this.isRecording()) {\r\n            // Pause recording.\r\n            this.mediaRecorder.pause();\r\n        } else if (this.isPaused()) {\r\n            // Resume recording.\r\n            this.mediaRecorder.resume();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle the media stream after it has finished.\r\n     */\r\n    async onMediaStopped() {\r\n        // Set source of audio player.\r\n        this.blob = new Blob(this.data.chunks, {\r\n            type: this.mediaRecorder.mimeType\r\n        });\r\n        this.player.srcObject = null;\r\n        this.player.src = URL.createObjectURL(this.blob);\r\n\r\n        // Change the label to \"Record again\".\r\n        this.setRecordButtonTextFromString('recordagain');\r\n\r\n        // Show upload button.\r\n        this.setUploadButtonVisibility(true);\r\n        this.setPlayerState(true);\r\n        this.setUploadButtonState(true);\r\n\r\n        // Hide the pause button.\r\n        this.setPauseButtonVisibility(false);\r\n        if (this.mediaRecorder.state === 'inactive') {\r\n            this.setPauseButtonTextFromString('pause');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Upload the recording and insert it into the editor content.\r\n     */\r\n    async uploadRecording() {\r\n        // Trigger error if no recording has been made.\r\n        if (this.data.chunks.length === 0) {\r\n            this.displayAlert('norecordingfound');\r\n            return;\r\n        }\r\n\r\n        const fileName = this.getFileName((Math.random() * 1000).toString().replace('.', ''));\r\n\r\n        // Upload recording to server.\r\n        try {\r\n            // Once uploading starts, do not allow any further changes to the recording.\r\n            this.setRecordButtonVisibility(false);\r\n\r\n            // Disable the upload button.\r\n            this.setUploadButtonState(false);\r\n\r\n            // Upload the recording.\r\n            const fileURL = await uploadFile(this.editor, 'media', this.blob, fileName, (progress) => {\r\n                this.setUploadButtonTextProgress(progress);\r\n            });\r\n            this.insertMedia(fileURL);\r\n            this.close();\r\n            addToast(await getString('recordinguploaded', component));\r\n        } catch (error) {\r\n            // Show a toast and unhide the button.\r\n            this.setUploadButtonState(true);\r\n\r\n            addToast(await getString('uploadfailed', component, {error}), {\r\n                type: 'error',\r\n            });\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Helper to get the container that a button is in.\r\n     *\r\n     * @param {string} purpose The button purpose\r\n     * @returns {HTMLElement}\r\n     */\r\n    getButtonContainer(purpose) {\r\n        return this.modalRoot.querySelector(`[data-purpose=\"${purpose}-container\"]`);\r\n    }\r\n\r\n    /**\r\n     * Check whether the browser is compatible with capturing media.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    static isBrowserCompatible() {\r\n        return this.checkSecure() && this.hasUserMedia();\r\n    }\r\n\r\n    static async display(editor) {\r\n        const ModalClass = this.getModalClass();\r\n        const modal = await ModalClass.create({\r\n            templateContext: {\r\n                isallowedpausing: isPausingAllowed(editor),\r\n            },\r\n            large: true,\r\n            removeOnClose: true,\r\n        });\r\n\r\n        // Set up the VideoRecorder.\r\n        const recorder = new this(editor, modal);\r\n        if (recorder.isReady()) {\r\n            modal.show();\r\n        }\r\n        return modal;\r\n    }\r\n\r\n    /**\r\n     * Check whether the browser is compatible with capturing media, and display a warning if not.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    checkAndWarnAboutBrowserCompatibility() {\r\n        if (!this.constructor.checkSecure()) {\r\n            getStrings(['insecurealert_title', 'insecurealert'].map((key) => ({key, component})))\r\n                .then(([title, message]) => addToast(message, {title, type: 'error'}))\r\n                .catch();\r\n            return false;\r\n        }\r\n\r\n        if (!this.constructor.hasUserMedia) {\r\n            getStrings(['nowebrtc_title', 'nowebrtc'].map((key) => ({key, component})))\r\n                .then(([title, message]) => addToast(message, {title, type: 'error'}))\r\n                .catch();\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Check whether the browser supports WebRTC.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    static hasUserMedia() {\r\n        return (navigator.mediaDevices && window.MediaRecorder);\r\n    }\r\n\r\n    /**\r\n     * Check whether the hostname is either hosted over SSL, or from a valid localhost hostname.\r\n     *\r\n     * The UserMedia API can only be used in secure contexts as noted.\r\n     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia#privacy_and_security}\r\n     *\r\n     * @returns {boolean} Whether the plugin can be loaded.\r\n     */\r\n    static checkSecure() {\r\n        // Note: We can now use window.isSecureContext.\r\n        // https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts#feature_detection\r\n        // https://developer.mozilla.org/en-US/docs/Web/API/isSecureContext\r\n        return window.isSecureContext;\r\n    }\r\n\r\n    /**\r\n     * Update the content of the stop recording button timer.\r\n     */\r\n    async setStopRecordingButton() {\r\n        const {html, js} = await Templates.renderForPromise('tiny_recordrtc/timeremaining', this.getTimeRemaining());\r\n        Templates.replaceNodeContents(this.startStopButton, html, js);\r\n        this.startButtonTimer();\r\n    }\r\n\r\n    /**\r\n     * Update the time on the stop recording button.\r\n     */\r\n    updateRecordButtonTime() {\r\n        const {remaining, minutes, seconds} = this.getTimeRemaining();\r\n        if (remaining < 0) {\r\n            this.requestRecordingStop();\r\n        } else {\r\n            this.startStopButton.querySelector('[data-type=\"minutes\"]').textContent = minutes;\r\n            this.startStopButton.querySelector('[data-type=\"seconds\"]').textContent = seconds;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the text of the record button using a language string.\r\n     *\r\n     * @param {string} string The string identifier\r\n     */\r\n    async setRecordButtonTextFromString(string) {\r\n        this.startStopButton.textContent = await getString(string, component);\r\n    }\r\n\r\n    /**\r\n     * Set the text of the pause button using a language string.\r\n     *\r\n     * @param {string} string The string identifier\r\n     */\r\n    async setPauseButtonTextFromString(string) {\r\n        if (this.pauseResumeButton) {\r\n            this.pauseResumeButton.textContent = await getString(string, component);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the upload button text progress.\r\n     *\r\n     * @param {number} progress The progress\r\n     */\r\n    async setUploadButtonTextProgress(progress) {\r\n        this.uploadButton.textContent = await getString('uploading', component, {\r\n            progress: Math.round(progress * 100) / 100,\r\n        });\r\n    }\r\n\r\n    async resetUploadButtonText() {\r\n        this.uploadButton.textContent = await getString('upload', component);\r\n    }\r\n\r\n    /**\r\n     * Clear the timer for the stop recording button.\r\n     */\r\n    clearButtonTimer() {\r\n        if (this.buttonTimer) {\r\n            clearInterval(this.buttonTimer);\r\n        }\r\n        this.buttonTimer = null;\r\n        this.pauseTime = null;\r\n        this.startTime = null;\r\n    }\r\n\r\n    /**\r\n     * Pause the timer for the stop recording button.\r\n     */\r\n    pauseButtonTimer() {\r\n        // Stop the countdown timer.\r\n        this.pauseTime = new Date().getTime(); // Store pause time.\r\n        if (this.buttonTimer) {\r\n            clearInterval(this.buttonTimer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Start the timer for the start recording button.\r\n     * If the recording was paused, the timer will resume from the pause time.\r\n     */\r\n    startButtonTimer() {\r\n        if (this.pauseTime !== null) {\r\n            // Resume from pause.\r\n            const pauseDuration = new Date().getTime() - this.pauseTime;\r\n            // Adjust start time by pause duration.\r\n            this.startTime += pauseDuration;\r\n            this.pauseTime = null;\r\n        }\r\n        this.buttonTimer = setInterval(this.updateRecordButtonTime.bind(this), 500);\r\n    }\r\n\r\n    /**\r\n     * Get the time remaining for the recording.\r\n     *\r\n     * @returns {Object} The minutes and seconds remaining.\r\n     */\r\n    getTimeRemaining() {\r\n        // All times are in milliseconds.\r\n        let now = new Date().getTime();\r\n        if (this.pauseTime !== null) {\r\n            // If paused, use pauseTime instead of current time.\r\n            now = this.pauseTime;\r\n        }\r\n        const remaining = Math.floor(this.getTimeLimit() - ((now - this.startTime) / 1000));\r\n\r\n        const formatter = new Intl.NumberFormat(navigator.language, {minimumIntegerDigits: 2});\r\n        const seconds = formatter.format(remaining % 60);\r\n        const minutes = formatter.format(Math.floor((remaining - seconds) / 60));\r\n        return {\r\n            remaining,\r\n            minutes,\r\n            seconds,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Get the maximum file size that can be uploaded.\r\n     *\r\n     * @returns {number} The max byte size\r\n     */\r\n    getMaxUploadSize() {\r\n        return this.config.maxrecsize;\r\n    }\r\n\r\n    /**\r\n     * Stop the recording.\r\n     * Please note that this should only stop the recording.\r\n     * Anything related to processing the recording should be handled by the\r\n     * mediaRecorder's stopped event handler which is processed after it has stopped.\r\n     */\r\n    requestRecordingStop() {\r\n        if (this.mediaRecorder && this.mediaRecorder.state !== 'inactive') {\r\n            this.stopRequested = true;\r\n            if (this.isPaused()) {\r\n                this.stopRecorder();\r\n            }\r\n        } else {\r\n            // There is no recording to stop, but the stream must still be cleaned up.\r\n            this.cleanupStream();\r\n        }\r\n    }\r\n\r\n    stopRecorder() {\r\n        if (this.isPaused()) {\r\n            this.pauseTime = null;\r\n        }\r\n        this.mediaRecorder.stop();\r\n\r\n        // Unmute the player so that the audio is heard during playback.\r\n        this.player.muted = false;\r\n    }\r\n\r\n    /**\r\n     * Clean up the stream.\r\n     *\r\n     * This involves stopping any track which is still active.\r\n     */\r\n    cleanupStream() {\r\n        if (this.stream) {\r\n            this.stream.getTracks()\r\n                .filter((track) => track.readyState !== 'ended')\r\n                .forEach((track) => track.stop());\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Handle the mediaRecorder `stop` event.\r\n     */\r\n    handleStopped() {\r\n        // Handle the stream data.\r\n        this.onMediaStopped();\r\n\r\n        // Clear the button timer.\r\n        this.clearButtonTimer();\r\n    }\r\n\r\n    /**\r\n     * Handle the mediaRecorder `start` event.\r\n     *\r\n     * This event is called when the recording starts.\r\n     */\r\n    handleStarted() {\r\n        this.startTime = new Date().getTime();\r\n        if (isPausingAllowed(this.editor) && !this.isPaused()) {\r\n            this.setPauseButtonVisibility(true);\r\n        }\r\n        this.setStopRecordingButton();\r\n    }\r\n\r\n    /**\r\n     * Handle the mediaRecorder `pause` event.\r\n     *\r\n     * This event is called when the recording pauses.\r\n     */\r\n    handlePaused() {\r\n        this.pauseButtonTimer();\r\n        this.setPauseButtonTextFromString('resume');\r\n    }\r\n\r\n    /**\r\n     * Handle the mediaRecorder `resume` event.\r\n     *\r\n     * This event is called when the recording resumes.\r\n     */\r\n    handleResume() {\r\n        this.startButtonTimer();\r\n        this.setPauseButtonTextFromString('pause');\r\n    }\r\n\r\n    /**\r\n     * Handle the mediaRecorder `dataavailable` event.\r\n     *\r\n     * @param {Event} event\r\n     */\r\n    handleDataAvailable(event) {\r\n        if (this.isRecording() || this.isPaused()) {\r\n            const newSize = this.data.blobSize + event.data.size;\r\n            // Recording stops when either the maximum upload size is reached, or the time limit expires.\r\n            // The time limit is checked in the `updateButtonTime` function.\r\n            if (newSize >= this.getMaxUploadSize()) {\r\n                this.stopRecorder();\r\n                this.displayFileLimitHitMessage();\r\n            } else {\r\n                // Push recording slice to array.\r\n                this.data.chunks.push(event.data);\r\n\r\n                // Size of all recorded data so far.\r\n                this.data.blobSize = newSize;\r\n\r\n                if (this.stopRequested) {\r\n                    this.stopRecorder();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    async displayFileLimitHitMessage() {\r\n        addToast(await getString('maxfilesizehit', component), {\r\n            title: await getString('maxfilesizehit_title', component),\r\n            type: 'error',\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Check whether the recording is in progress.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    isRecording() {\r\n        return this.mediaRecorder?.state === 'recording';\r\n    }\r\n\r\n    /**\r\n     * Check whether the recording is paused.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    isPaused() {\r\n        return this.mediaRecorder?.state === 'paused';\r\n    }\r\n\r\n    /**\r\n     * Whether any data has been recorded.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    hasData() {\r\n        return !!this.data?.blobSize;\r\n    }\r\n\r\n    /**\r\n     * Start the recording\r\n     */\r\n    async startRecording() {\r\n        if (this.mediaRecorder) {\r\n            // Stop the existing recorder if it exists.\r\n            if (this.isRecording() || this.isPaused()) {\r\n                this.mediaRecorder.stop();\r\n            }\r\n\r\n            if (this.hasData()) {\r\n                const resetRecording = await this.recordAgainConfirmation();\r\n                if (!resetRecording) {\r\n                    // User cancelled at the confirmation to reset the data, so exit early.\r\n                    return;\r\n                }\r\n                this.setUploadButtonVisibility(false);\r\n                this.setPlayerState(false);\r\n                if (!this.stream.active) {\r\n                    await this.captureUserMedia();\r\n                }\r\n            }\r\n\r\n            this.mediaRecorder = null;\r\n        }\r\n\r\n        // The options for the recording codecs and bitrates.\r\n        this.mediaRecorder = new MediaRecorder(this.stream, this.getParsedRecordingOptions());\r\n\r\n        this.mediaRecorder.addEventListener('dataavailable', this.handleDataAvailable.bind(this));\r\n        this.mediaRecorder.addEventListener('stop', this.handleStopped.bind(this));\r\n        this.mediaRecorder.addEventListener('start', this.handleStarted.bind(this));\r\n        this.mediaRecorder.addEventListener('pause', this.handlePaused.bind(this));\r\n        this.mediaRecorder.addEventListener('resume', this.handleResume.bind(this));\r\n\r\n        this.data = {\r\n            chunks: [],\r\n            blobSize: 0\r\n        };\r\n        this.setupPlayerSource();\r\n        this.stopRequested = false;\r\n\r\n        // Capture in 50ms chunks.\r\n        this.mediaRecorder.start(50);\r\n    }\r\n\r\n    /**\r\n     * Confirm whether the user wants to reset the existing recoring.\r\n     *\r\n     * @returns {Promise<boolean>} Whether the user confirmed the reset.\r\n     */\r\n    async recordAgainConfirmation() {\r\n        try {\r\n            await saveCancelPromise(\r\n                await getString(\"recordagain_title\", component),\r\n                await getString(\"recordagain_desc\", component),\r\n                await getString(\"confirm_yes\", component)\r\n            );\r\n            return true;\r\n        } catch {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Insert the HTML to embed the recording into the editor content.\r\n     *\r\n     * @param {string} source The URL to view the media.\r\n     */\r\n    async insertMedia(source) {\r\n        const {html} = await Templates.renderForPromise(\r\n            this.getEmbedTemplateName(),\r\n            this.getEmbedTemplateContext({\r\n                source,\r\n            })\r\n        );\r\n        this.editor.insertContent(html);\r\n    }\r\n\r\n    /**\r\n     * Add or modify the template parameters for the specified type.\r\n     *\r\n     * @param {Object} templateContext The Tempalte context to use\r\n     * @returns {Object} The finalised template context\r\n     */\r\n    getEmbedTemplateContext(templateContext) {\r\n        return templateContext;\r\n    }\r\n}\r\n"],"names":["_getRequireWildcardCache","e","WeakMap","r","t","_interopRequireWildcard","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_interopRequireDefault","_pending","_uploader","ModalEvents","Templates","_alert","_exports","stopRequested","buttonTimer","pauseTime","startTime","constructor","editor","modal","this","ready","checkAndWarnAboutBrowserCompatibility","config","getData","params","modalRoot","getRoot","startStopButton","querySelector","uploadButton","pauseResumeButton","setRecordButtonState","player","configurePlayer","registerEventListeners","captureUserMedia","prefetchContent","isReady","Error","name","getSupportedTypes","getRecordingOptions","getFileName","prefix","getMediaConstraints","playOnCapture","getTimeLimit","getEmbedTemplateName","getModalClass","getParsedRecordingOptions","compatTypes","reduce","result","type","push","replace","filter","window","MediaRecorder","isTypeSupported","options","length","mimeType","console","info","stream","navigator","mediaDevices","getUserMedia","handleCaptureSuccess","error","handleCaptureFailure","prefetchStrings","component","prefetchTemplates","displayAlert","title","content","pendingPromise","Pending","AlertModal","create","body","removeOnClose","show","resolve","srcObject","muted","play","setupPlayerSource","enabled","disabled","setRecordButtonVisibility","visible","getButtonContainer","classList","toggle","setPauseButtonVisibility","setUploadButtonState","setUploadButtonVisibility","setPlayerState","state","controls","subject","toLowerCase","getString","close","hide","addEventListener","handleModalClick","bind","on","outsideClick","outsideClickHandler","hidden","cleanupStream","requestRecordingStop","event","isRecording","isPaused","preventDefault","hasData","saveCancelPromise","button","target","closest","dataset","action","handleRecordingStartStopRequested","uploadRecording","handleRecordingPauseResumeRequested","startRecording","mediaRecorder","pause","resume","onMediaStopped","blob","Blob","data","chunks","src","URL","createObjectURL","setRecordButtonTextFromString","setPauseButtonTextFromString","fileName","Math","random","toString","fileURL","uploadFile","progress","setUploadButtonTextProgress","insertMedia","addToast","purpose","isBrowserCompatible","checkSecure","hasUserMedia","display","ModalClass","templateContext","isallowedpausing","isPausingAllowed","large","getStrings","map","key","then","_ref2","message","catch","_ref","isSecureContext","setStopRecordingButton","html","js","renderForPromise","getTimeRemaining","replaceNodeContents","startButtonTimer","updateRecordButtonTime","remaining","minutes","seconds","textContent","string","round","resetUploadButtonText","clearButtonTimer","clearInterval","pauseButtonTimer","Date","getTime","pauseDuration","setInterval","now","floor","formatter","Intl","NumberFormat","language","minimumIntegerDigits","format","getMaxUploadSize","maxrecsize","stopRecorder","stop","getTracks","track","readyState","forEach","handleStopped","handleStarted","handlePaused","handleResume","handleDataAvailable","newSize","blobSize","size","displayFileLimitHitMessage","recordAgainConfirmation","active","start","source","getEmbedTemplateContext","insertContent"],"mappings":"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"}