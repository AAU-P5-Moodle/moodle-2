{"version":3,"file":"sortable_list.min.js","sources":["../src/sortable_list.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * A javascript module to handle list items drag and drop\r\n *\r\n * Example of usage:\r\n *\r\n * Create a list (for example `<ul>` or `<tbody>`) where each draggable element has a drag handle.\r\n * The best practice is to use the template core/drag_handle:\r\n * $OUTPUT->render_from_template('core/drag_handle', ['movetitle' => get_string('movecontent', 'moodle', ELEMENTNAME)]);\r\n *\r\n * Attach this JS module to this list:\r\n *\r\n * Space between define and ( critical in comment but not allowed in code in order to function\r\n * correctly with Moodle's requirejs.php\r\n *\r\n * For the full list of possible parameters see var defaultParameters below.\r\n *\r\n * The following jQuery events are fired:\r\n * - SortableList.EVENTS.DRAGSTART : when user started dragging a list element\r\n * - SortableList.EVENTS.DRAG : when user dragged a list element to a new position\r\n * - SortableList.EVENTS.DROP : when user dropped a list element\r\n * - SortableList.EVENTS.DROPEND : when user finished dragging - either fired right after dropping or\r\n *                          if \"Esc\" was pressed during dragging\r\n *\r\n * @example\r\n * define (['jquery', 'core/sortable_list'], function($, SortableList) {\r\n *     var list = new SortableList('ul.my-awesome-list'); // source list (usually <ul> or <tbody>) - selector or element\r\n *\r\n *     // Listen to the events when element is dragged.\r\n *     $('ul.my-awesome-list > *').on(SortableList.EVENTS.DROP, function(evt, info) {\r\n *         console.log(info);\r\n *     });\r\n *\r\n *     // Advanced usage. Overwrite methods getElementName, getDestinationName, moveDialogueTitle, for example:\r\n *     list.getElementName = function(element) {\r\n *         return $.Deferred().resolve(element.attr('data-name'));\r\n *     }\r\n * });\r\n *\r\n * @module     core/sortable_list\r\n * @class      core/sortable_list\r\n * @copyright  2018 Marina Glancy\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\ndefine(['jquery', 'core/log', 'core/autoscroll', 'core/str', 'core/modal_cancel', 'core/modal_events', 'core/notification'],\r\nfunction($, log, autoScroll, str, ModalCancel, ModalEvents, Notification) {\r\n\r\n    /**\r\n     * Default parameters\r\n     *\r\n     * @private\r\n     * @type {Object}\r\n     */\r\n    var defaultParameters = {\r\n        targetListSelector: null,\r\n        moveHandlerSelector: '[data-drag-type=move]',\r\n        isHorizontal: false,\r\n        autoScroll: true\r\n    };\r\n\r\n    /**\r\n     * Class names for different elements that may be changed during sorting\r\n     *\r\n     * @private\r\n     * @type {Object}\r\n     */\r\n    var CSS = {\r\n        keyboardDragClass: 'dragdrop-keyboard-drag',\r\n        isDraggedClass: 'sortable-list-is-dragged',\r\n        isDroppedClass: 'sortable-list-is-dropped',\r\n        currentPositionClass: 'sortable-list-current-position',\r\n        sourceListClass: 'sortable-list-source',\r\n        targetListClass: 'sortable-list-target',\r\n        overElementClass: 'sortable-list-over-element'\r\n    };\r\n\r\n    /**\r\n     * Test the browser support for options objects on event listeners.\r\n     * @return {Boolean}\r\n     */\r\n    var eventListenerOptionsSupported = function() {\r\n        var passivesupported = false,\r\n            options,\r\n            testeventname = \"testpassiveeventoptions\";\r\n\r\n        // Options support testing example from:\r\n        // https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener\r\n\r\n        try {\r\n            options = Object.defineProperty({}, \"passive\", {\r\n                // eslint-disable-next-line getter-return\r\n                get: function() {\r\n                    passivesupported = true;\r\n                }\r\n            });\r\n\r\n            // We use an event name that is not likely to conflict with any real event.\r\n            document.addEventListener(testeventname, options, options);\r\n            // We remove the event listener as we have tested the options already.\r\n            document.removeEventListener(testeventname, options, options);\r\n        } catch (err) {\r\n            // It's already false.\r\n            passivesupported = false;\r\n        }\r\n        return passivesupported;\r\n    };\r\n\r\n    /**\r\n     * Allow to create non-passive touchstart listeners and prevent page scrolling when dragging\r\n     * From: https://stackoverflow.com/a/48098097\r\n     *\r\n     * @param {string} eventname\r\n     * @returns {object}\r\n     */\r\n    var registerNotPassiveListeners = function(eventname) {\r\n        return {\r\n            setup: function(x, ns, handle) {\r\n                if (ns.includes('notPassive')) {\r\n                    this.addEventListener(eventname, handle, {passive: false});\r\n                    return true;\r\n                } else {\r\n                    return false;\r\n                }\r\n            }\r\n        };\r\n    };\r\n\r\n    if (eventListenerOptionsSupported) {\r\n        $.event.special.touchstart = registerNotPassiveListeners('touchstart');\r\n        $.event.special.touchmove = registerNotPassiveListeners('touchmove');\r\n        $.event.special.touchend = registerNotPassiveListeners('touchend');\r\n    }\r\n\r\n    /**\r\n     * Initialise sortable list.\r\n     *\r\n     * @param {(String|jQuery|Element)} root JQuery/DOM element representing sortable list (i.e. <ul>, <tbody>) or CSS selector\r\n     * @param {Object} config Parameters for the list. See defaultParameters above for examples.\r\n     * @param {(String|jQuery|Element)} config.targetListSelector target lists, by default same as root\r\n     * @param {String} config.moveHandlerSelector  CSS selector for a drag handle. By default '[data-drag-type=move]'\r\n     * @param {String} config.listSelector   CSS selector for target lists. By default the same as root\r\n     * @param {(Boolean|Function)} config.isHorizontal Set to true if the list is horizontal (can also be a callback\r\n     *                                                 with list as an argument)\r\n     * @param {Boolean} config.autoScroll Engages autoscroll module for automatic vertical scrolling of the whole page,\r\n     *                                    by default true\r\n     */\r\n    var SortableList = function(root, config) {\r\n\r\n        this.info = null;\r\n        this.proxy = null;\r\n        this.proxyDelta = null;\r\n        this.dragCounter = 0;\r\n        this.lastEvent = null;\r\n\r\n        this.config = $.extend({}, defaultParameters, config || {});\r\n        this.config.listSelector = root;\r\n        if (!this.config.targetListSelector) {\r\n            this.config.targetListSelector = root;\r\n        }\r\n        if (typeof this.config.listSelector === 'object') {\r\n            // The root is an element on the page. Register a listener for this element.\r\n            $(this.config.listSelector).on('mousedown touchstart.notPassive', $.proxy(this.dragStartHandler, this));\r\n        } else {\r\n            // The root is a CSS selector. Register a listener that picks up the element dynamically.\r\n            $('body').on('mousedown touchstart.notPassive', this.config.listSelector, $.proxy(this.dragStartHandler, this));\r\n        }\r\n        if (this.config.moveHandlerSelector !== null) {\r\n            $('body').on('click keypress', this.config.moveHandlerSelector, $.proxy(this.clickHandler, this));\r\n        }\r\n\r\n    };\r\n\r\n    /**\r\n     * Events fired by this entity\r\n     *\r\n     * @public\r\n     * @type {Object}\r\n     */\r\n    SortableList.EVENTS = {\r\n        DRAGSTART: 'sortablelist-dragstart',\r\n        DRAG: 'sortablelist-drag',\r\n        DROP: 'sortablelist-drop',\r\n        DRAGEND: 'sortablelist-dragend'\r\n    };\r\n\r\n    /**\r\n     * Resets the temporary classes assigned during dragging\r\n     * @private\r\n     */\r\n     SortableList.prototype.resetDraggedClasses = function() {\r\n        var classes = [\r\n            CSS.isDraggedClass,\r\n            CSS.currentPositionClass,\r\n            CSS.overElementClass,\r\n            CSS.targetListClass,\r\n        ];\r\n        for (var i in classes) {\r\n            $('.' + classes[i]).removeClass(classes[i]);\r\n        }\r\n        if (this.proxy) {\r\n            this.proxy.remove();\r\n            this.proxy = $();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Calculates evt.pageX, evt.pageY, evt.clientX and evt.clientY\r\n     *\r\n     * For touch events pageX and pageY are taken from the first touch;\r\n     * For the emulated mousemove event they are taken from the last real event.\r\n     *\r\n     * @private\r\n     * @param {Event} evt\r\n     */\r\n    SortableList.prototype.calculatePositionOnPage = function(evt) {\r\n\r\n        if (evt.originalEvent && evt.originalEvent.touches && evt.originalEvent.touches[0] !== undefined) {\r\n            // This is a touchmove or touchstart event, get position from the first touch position.\r\n            var touch = evt.originalEvent.touches[0];\r\n            evt.pageX = touch.pageX;\r\n            evt.pageY = touch.pageY;\r\n        }\r\n\r\n        if (evt.pageX === undefined) {\r\n            // Information is not present in case of touchend or when event was emulated by autoScroll.\r\n            // Take the absolute mouse position from the last event.\r\n            evt.pageX = this.lastEvent.pageX;\r\n            evt.pageY = this.lastEvent.pageY;\r\n        } else {\r\n            this.lastEvent = evt;\r\n        }\r\n\r\n        if (evt.clientX === undefined) {\r\n            // If not provided in event calculate relative mouse position.\r\n            evt.clientX = Math.round(evt.pageX - $(window).scrollLeft());\r\n            evt.clientY = Math.round(evt.pageY - $(window).scrollTop());\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Handler from dragstart event\r\n     *\r\n     * @private\r\n     * @param {Event} evt\r\n     */\r\n    SortableList.prototype.dragStartHandler = function(evt) {\r\n        if (this.info !== null) {\r\n            if (this.info.type === 'click' || this.info.type === 'touchend') {\r\n                // Ignore double click.\r\n                return;\r\n            }\r\n            // Mouse down or touch while already dragging, cancel previous dragging.\r\n            this.moveElement(this.info.sourceList, this.info.sourceNextElement);\r\n            this.finishDragging();\r\n        }\r\n\r\n        if (evt.type === 'mousedown' && evt.which !== 1) {\r\n            // We only need left mouse click. If this is a mousedown event with right/middle click ignore it.\r\n            return;\r\n        }\r\n\r\n        this.calculatePositionOnPage(evt);\r\n        var movedElement = $(evt.target).closest($(evt.currentTarget).children());\r\n        if (!movedElement.length) {\r\n            // Can't find the element user wants to drag. They clicked on the list but outside of any element of the list.\r\n            return;\r\n        }\r\n\r\n        // Check that we grabbed the element by the handle.\r\n        if (this.config.moveHandlerSelector !== null) {\r\n            if (!$(evt.target).closest(this.config.moveHandlerSelector, movedElement).length) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        evt.stopPropagation();\r\n        evt.preventDefault();\r\n\r\n        // Information about moved element with original location.\r\n        // This object is passed to event observers.\r\n        this.dragCounter++;\r\n        this.info = {\r\n            element: movedElement,\r\n            sourceNextElement: movedElement.next(),\r\n            sourceList: movedElement.parent(),\r\n            targetNextElement: movedElement.next(),\r\n            targetList: movedElement.parent(),\r\n            type: evt.type,\r\n            dropped: false,\r\n            startX: evt.pageX,\r\n            startY: evt.pageY,\r\n            startTime: new Date().getTime()\r\n        };\r\n\r\n        $(this.config.targetListSelector).addClass(CSS.targetListClass);\r\n\r\n        var offset = movedElement.offset();\r\n        movedElement.addClass(CSS.currentPositionClass);\r\n        this.proxyDelta = {x: offset.left - evt.pageX, y: offset.top - evt.pageY};\r\n        this.proxy = $();\r\n        var thisDragCounter = this.dragCounter;\r\n        setTimeout($.proxy(function() {\r\n            // This mousedown event may in fact be a beginning of a 'click' event. Use timeout before showing the\r\n            // dragged object so we can catch click event. When timeout finishes make sure that click event\r\n            // has not happened during this half a second.\r\n            // Verify dragcounter to make sure the user did not manage to do two very fast drag actions one after another.\r\n            if (this.info === null || this.info.type === 'click' || this.info.type === 'keypress'\r\n                    || this.dragCounter !== thisDragCounter) {\r\n                return;\r\n            }\r\n\r\n            // Create a proxy - the copy of the dragged element that moves together with a mouse.\r\n            this.createProxy();\r\n        }, this), 500);\r\n\r\n        // Start drag.\r\n        $(window).on('mousemove touchmove.notPassive mouseup touchend.notPassive', $.proxy(this.dragHandler, this));\r\n        $(window).on('keypress', $.proxy(this.dragcancelHandler, this));\r\n\r\n        // Start autoscrolling. Every time the page is scrolled emulate the mousemove event.\r\n        if (this.config.autoScroll) {\r\n            autoScroll.start(function() {\r\n                $(window).trigger('mousemove');\r\n            });\r\n        }\r\n\r\n       this.executeCallback(SortableList.EVENTS.DRAGSTART);\r\n    };\r\n\r\n    /**\r\n     * Creates a \"proxy\" object - a copy of the element that is being moved that always follows the mouse\r\n     * @private\r\n     */\r\n    SortableList.prototype.createProxy = function() {\r\n        this.proxy = this.info.element.clone();\r\n        this.info.sourceList.append(this.proxy);\r\n        this.proxy.removeAttr('id').removeClass(CSS.currentPositionClass)\r\n            .addClass(CSS.isDraggedClass).css({position: 'fixed'});\r\n        this.proxy.offset({top: this.proxyDelta.y + this.lastEvent.pageY, left: this.proxyDelta.x + this.lastEvent.pageX});\r\n    };\r\n\r\n    /**\r\n     * Handler for click event - when user clicks on the drag handler or presses Enter on keyboard\r\n     *\r\n     * @private\r\n     * @param {Event} evt\r\n     */\r\n    SortableList.prototype.clickHandler = function(evt) {\r\n        if (evt.type === 'keypress' && evt.originalEvent.keyCode !== 13 && evt.originalEvent.keyCode !== 32) {\r\n            return;\r\n        }\r\n        if (this.info !== null) {\r\n            // Ignore double click.\r\n            return;\r\n        }\r\n\r\n        // Find the element that this draghandle belongs to.\r\n        var clickedElement = $(evt.target).closest(this.config.moveHandlerSelector),\r\n            sourceList = clickedElement.closest(this.config.listSelector),\r\n            movedElement = clickedElement.closest(sourceList.children());\r\n        if (!movedElement.length) {\r\n            return;\r\n        }\r\n\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n\r\n        // Store information about moved element with original location.\r\n        this.dragCounter++;\r\n        this.info = {\r\n            element: movedElement,\r\n            sourceNextElement: movedElement.next(),\r\n            sourceList: sourceList,\r\n            targetNextElement: movedElement.next(),\r\n            targetList: sourceList,\r\n            dropped: false,\r\n            type: evt.type,\r\n            startTime: new Date().getTime()\r\n        };\r\n\r\n        this.executeCallback(SortableList.EVENTS.DRAGSTART);\r\n        this.displayMoveDialogue(clickedElement);\r\n    };\r\n\r\n    /**\r\n     * Finds the position of the mouse inside the element - on the top, on the bottom, on the right or on the left\\\r\n     *\r\n     * Used to determine if the moved element should be moved after or before the current element\r\n     *\r\n     * @private\r\n     * @param {Number} pageX\r\n     * @param {Number} pageY\r\n     * @param {jQuery} element\r\n     * @returns {(Object|null)}\r\n     */\r\n    SortableList.prototype.getPositionInNode = function(pageX, pageY, element) {\r\n        if (!element.length) {\r\n            return null;\r\n        }\r\n        var node = element[0],\r\n            offset = 0,\r\n            rect = node.getBoundingClientRect(),\r\n            y = pageY - (rect.top + window.scrollY),\r\n            x = pageX - (rect.left + window.scrollX);\r\n        if (x >= -offset && x <= rect.width + offset && y >= -offset && y <= rect.height + offset) {\r\n            return {\r\n                x: x,\r\n                y: y,\r\n                xRatio: rect.width ? (x / rect.width) : 0,\r\n                yRatio: rect.height ? (y / rect.height) : 0\r\n            };\r\n        }\r\n        return null;\r\n    };\r\n\r\n    /**\r\n     * Check if list is horizontal\r\n     *\r\n     * @param {jQuery} element\r\n     * @return {Boolean}\r\n     */\r\n    SortableList.prototype.isListHorizontal = function(element) {\r\n        var isHorizontal = this.config.isHorizontal;\r\n        if (isHorizontal === true || isHorizontal === false) {\r\n            return isHorizontal;\r\n        }\r\n        return isHorizontal(element);\r\n    };\r\n\r\n    /**\r\n     * Handler for events mousemove touchmove mouseup touchend\r\n     *\r\n     * @private\r\n     * @param {Event} evt\r\n     */\r\n    SortableList.prototype.dragHandler = function(evt) {\r\n\r\n        evt.preventDefault();\r\n        evt.stopPropagation();\r\n\r\n        this.calculatePositionOnPage(evt);\r\n\r\n        // We can not use evt.target here because it will most likely be our proxy.\r\n        // Move the proxy out of the way so we can find the element at the current mouse position.\r\n        this.proxy.offset({top: -1000, left: -1000});\r\n        // Find the element at the current mouse position.\r\n        var element = $(document.elementFromPoint(evt.clientX, evt.clientY));\r\n\r\n        // Find the list element and the list over the mouse position.\r\n        var mainElement = this.info.element[0],\r\n            isNotSelf = function() {\r\n                return this !== mainElement;\r\n            },\r\n            current = element.closest('.' + CSS.targetListClass + ' > :not(.' + CSS.isDraggedClass + ')').filter(isNotSelf),\r\n            currentList = element.closest('.' + CSS.targetListClass),\r\n            proxy = this.proxy,\r\n            isNotProxy = function() {\r\n                return !proxy || !proxy.length || this !== proxy[0];\r\n            };\r\n\r\n        // Add the specified class to the list element we are hovering.\r\n        $('.' + CSS.overElementClass).removeClass(CSS.overElementClass);\r\n        current.addClass(CSS.overElementClass);\r\n\r\n        // Move proxy to the current position.\r\n        this.proxy.offset({top: this.proxyDelta.y + evt.pageY, left: this.proxyDelta.x + evt.pageX});\r\n\r\n        if (currentList.length && !currentList.children().filter(isNotProxy).length) {\r\n            // Mouse is over an empty list.\r\n            this.moveElement(currentList, $());\r\n        } else if (current.length === 1 && !this.info.element.find(current[0]).length) {\r\n            // Mouse is over an element in a list - find whether we should move the current position\r\n            // above or below this element.\r\n            var coordinates = this.getPositionInNode(evt.pageX, evt.pageY, current);\r\n            if (coordinates) {\r\n                var parent = current.parent(),\r\n                    ratio = this.isListHorizontal(parent) ? coordinates.xRatio : coordinates.yRatio,\r\n                    subList = current.find('.' + CSS.targetListClass),\r\n                    subListEmpty = !subList.children().filter(isNotProxy).filter(isNotSelf).length;\r\n                if (subList.length && subListEmpty && ratio > 0.2 && ratio < 0.8) {\r\n                    // This is an element that is a parent of an empty list and we are around the middle of this element.\r\n                    // Treat it as if we are over this empty list.\r\n                   this.moveElement(subList, $());\r\n                } else if (ratio > 0.5) {\r\n                    // Insert after this element.\r\n                   this.moveElement(parent, current.next().filter(isNotProxy));\r\n                } else {\r\n                    // Insert before this element.\r\n                   this.moveElement(parent, current);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (evt.type === 'mouseup' || evt.type === 'touchend') {\r\n            // Drop the moved element.\r\n            this.info.endX = evt.pageX;\r\n            this.info.endY = evt.pageY;\r\n            this.info.endTime = new Date().getTime();\r\n            this.info.dropped = true;\r\n            this.info.positionChanged = this.hasPositionChanged(this.info);\r\n            var oldinfo = this.info;\r\n            this.executeCallback(SortableList.EVENTS.DROP);\r\n            this.finishDragging();\r\n\r\n            if (evt.type === 'touchend'\r\n                    && this.config.moveHandlerSelector !== null\r\n                    && (oldinfo.endTime - oldinfo.startTime < 500)\r\n                    && !oldinfo.positionChanged) {\r\n                // The click event is not triggered on touch screens because we call preventDefault in touchstart handler.\r\n                // If the touchend quickly followed touchstart without moving, consider it a \"click\".\r\n                this.clickHandler(evt);\r\n            } else if (oldinfo.positionChanged) {\r\n                mainElement.classList.add(CSS.isDroppedClass);\r\n            }\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Checks if the position of the dragged element in the list has changed\r\n     *\r\n     * @private\r\n     * @param {Object} info\r\n     * @return {Boolean}\r\n     */\r\n    SortableList.prototype.hasPositionChanged = function(info) {\r\n        return info.sourceList[0] !== info.targetList[0] ||\r\n            info.sourceNextElement.length !== info.targetNextElement.length ||\r\n            (info.sourceNextElement.length && info.sourceNextElement[0] !== info.targetNextElement[0]);\r\n    };\r\n\r\n    /**\r\n     * Moves the current position of the dragged element\r\n     *\r\n     * @private\r\n     * @param {jQuery} parentElement\r\n     * @param {jQuery} beforeElement\r\n     */\r\n    SortableList.prototype.moveElement = function(parentElement, beforeElement) {\r\n        var dragEl = this.info.element;\r\n        if (beforeElement.length && beforeElement[0] === dragEl[0]) {\r\n            // Insert before the current position of the dragged element - nothing to do.\r\n            return;\r\n        }\r\n        if (parentElement[0] === this.info.targetList[0] &&\r\n                beforeElement.length === this.info.targetNextElement.length &&\r\n                beforeElement[0] === this.info.targetNextElement[0]) {\r\n            // Insert in the same location as the current position - nothing to do.\r\n            return;\r\n        }\r\n\r\n        if (beforeElement.length) {\r\n            // Move the dragged element before the specified element.\r\n            parentElement[0].insertBefore(dragEl[0], beforeElement[0]);\r\n        } else if (this.proxy && this.proxy.parent().length && this.proxy.parent()[0] === parentElement[0]) {\r\n            // We need to move to the end of the list but the last element in this list is a proxy.\r\n            // Always leave the proxy in the end of the list.\r\n            parentElement[0].insertBefore(dragEl[0], this.proxy[0]);\r\n        } else {\r\n            // Insert in the end of a list (when proxy is in another list).\r\n            parentElement[0].appendChild(dragEl[0]);\r\n        }\r\n\r\n        // Save the current position of the dragged element in the list.\r\n        this.info.targetList = parentElement;\r\n        this.info.targetNextElement = beforeElement;\r\n        this.executeCallback(SortableList.EVENTS.DRAG);\r\n    };\r\n\r\n    /**\r\n     * Finish dragging (when dropped or cancelled).\r\n     * @private\r\n     */\r\n    SortableList.prototype.finishDragging = function() {\r\n        this.resetDraggedClasses();\r\n        if (this.config.autoScroll) {\r\n            autoScroll.stop();\r\n        }\r\n        $(window).off('mousemove touchmove.notPassive mouseup touchend.notPassive', $.proxy(this.dragHandler, this));\r\n        $(window).off('keypress', $.proxy(this.dragcancelHandler, this));\r\n        this.executeCallback(SortableList.EVENTS.DRAGEND);\r\n        this.info = null;\r\n    };\r\n\r\n    /**\r\n     * Executes callback specified in sortable list parameters\r\n     *\r\n     * @private\r\n     * @param {String} eventName\r\n     */\r\n    SortableList.prototype.executeCallback = function(eventName) {\r\n        this.info.element.trigger(eventName, this.info);\r\n    };\r\n\r\n    /**\r\n     * Handler from keypress event (cancel dragging when Esc is pressed)\r\n     *\r\n     * @private\r\n     * @param {Event} evt\r\n     */\r\n    SortableList.prototype.dragcancelHandler = function(evt) {\r\n        if (evt.type !== 'keypress' || evt.originalEvent.keyCode !== 27) {\r\n            // Only cancel dragging when Esc was pressed.\r\n            return;\r\n        }\r\n        // Dragging was cancelled. Return item to the original position.\r\n        this.moveElement(this.info.sourceList, this.info.sourceNextElement);\r\n        this.finishDragging();\r\n    };\r\n\r\n    /**\r\n     * Returns the name of the current element to be used in the move dialogue\r\n     *\r\n     * @public\r\n     * @param {jQuery} element\r\n     * @return {Promise}\r\n     */\r\n    SortableList.prototype.getElementName = function(element) {\r\n        return $.Deferred().resolve(element.text());\r\n    };\r\n\r\n    /**\r\n     * Returns the label for the potential move destination, i.e. \"After ElementX\" or \"To the top of the list\"\r\n     *\r\n     * Note that we use \"after\" in the label for better UX\r\n     *\r\n     * @public\r\n     * @param {jQuery} parentElement\r\n     * @param {jQuery} afterElement\r\n     * @return {Promise}\r\n     */\r\n    SortableList.prototype.getDestinationName = function(parentElement, afterElement) {\r\n        if (!afterElement.length) {\r\n            return str.get_string('movecontenttothetop', 'moodle');\r\n        } else {\r\n            return this.getElementName(afterElement)\r\n                .then(function(name) {\r\n                    return str.get_string('movecontentafter', 'moodle', name);\r\n                });\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Returns the title for the move dialogue (\"Move elementY\")\r\n     *\r\n     * @public\r\n     * @param {jQuery} element\r\n     * @param {jQuery} handler\r\n     * @return {Promise}\r\n     */\r\n    SortableList.prototype.getMoveDialogueTitle = function(element, handler) {\r\n        if (handler.attr('title')) {\r\n            return $.Deferred().resolve(handler.attr('title'));\r\n        }\r\n        return this.getElementName(element).then(function(name) {\r\n            return str.get_string('movecontent', 'moodle', name);\r\n        });\r\n    };\r\n\r\n    /**\r\n     * Returns the list of possible move destinations\r\n     *\r\n     * @private\r\n     * @return {Promise}\r\n     */\r\n    SortableList.prototype.getDestinationsList = function() {\r\n        var addedLists = [],\r\n            targets = $(this.config.targetListSelector),\r\n            destinations = $('<ul/>').addClass(CSS.keyboardDragClass),\r\n            result = $.when().then(function() {\r\n                return destinations;\r\n            }),\r\n            createLink = $.proxy(function(parentElement, beforeElement, afterElement) {\r\n                if (beforeElement.is(this.info.element) || afterElement.is(this.info.element)) {\r\n                    // Can not move before or after itself.\r\n                    return;\r\n                }\r\n                if ($.contains(this.info.element[0], parentElement[0])) {\r\n                    // Can not move to its own child.\r\n                    return;\r\n                }\r\n                result = result\r\n                .then($.proxy(function() {\r\n                    return this.getDestinationName(parentElement, afterElement);\r\n                }, this))\r\n                .then(function(txt) {\r\n                    var li = $('<li/>').appendTo(destinations);\r\n                    var a = $('<a href=\"#\"/>').attr('data-core_sortable_list-quickmove', 1).appendTo(li);\r\n                    a.data('parent-element', parentElement).data('before-element', beforeElement).text(txt);\r\n                    return destinations;\r\n                });\r\n            }, this),\r\n            addList = function() {\r\n                // Destination lists may be nested. We want to add all move destinations in the same\r\n                // order they appear on the screen for the user.\r\n                if ($.inArray(this, addedLists) !== -1) {\r\n                    return;\r\n                }\r\n                addedLists.push(this);\r\n                var list = $(this),\r\n                    children = list.children();\r\n                children.each(function() {\r\n                    var element = $(this);\r\n                    createLink(list, element, element.prev());\r\n                    // Add all nested lists.\r\n                    element.find(targets).each(addList);\r\n                });\r\n                createLink(list, $(), children.last());\r\n            };\r\n        targets.each(addList);\r\n        return result;\r\n    };\r\n\r\n    /**\r\n     * Displays the dialogue to move element.\r\n     * @param {jQuery} clickedElement element to return focus to after the modal is closed\r\n     * @private\r\n     */\r\n    SortableList.prototype.displayMoveDialogue = function(clickedElement) {\r\n        ModalCancel.create({\r\n            title: this.getMoveDialogueTitle(this.info.element, clickedElement),\r\n            body: this.getDestinationsList()\r\n        }).then($.proxy(function(modal) {\r\n            var quickMoveHandler = $.proxy(function(e) {\r\n                e.preventDefault();\r\n                e.stopPropagation();\r\n                this.moveElement($(e.currentTarget).data('parent-element'), $(e.currentTarget).data('before-element'));\r\n                this.info.endTime = new Date().getTime();\r\n                this.info.positionChanged = this.hasPositionChanged(this.info);\r\n                this.info.dropped = true;\r\n                clickedElement.focus();\r\n                this.executeCallback(SortableList.EVENTS.DROP);\r\n                modal.hide();\r\n            }, this);\r\n            modal.getRoot().on('click', '[data-core_sortable_list-quickmove]', quickMoveHandler);\r\n            modal.getRoot().on(ModalEvents.hidden, $.proxy(function() {\r\n                // Always destroy when hidden, it is generated dynamically each time.\r\n                modal.getRoot().off('click', '[data-core_sortable_list-quickmove]', quickMoveHandler);\r\n                modal.destroy();\r\n                this.finishDragging();\r\n            }, this));\r\n            modal.setLarge();\r\n            modal.show();\r\n            return modal;\r\n        }, this)).catch(Notification.exception);\r\n    };\r\n\r\n    return SortableList;\r\n\r\n});\r\n"],"names":["define","$","log","autoScroll","str","ModalCancel","ModalEvents","Notification","defaultParameters","targetListSelector","moveHandlerSelector","isHorizontal","CSS","registerNotPassiveListeners","eventname","setup","x","ns","handle","includes","this","addEventListener","passive","options","passivesupported","Object","defineProperty","get","document","removeEventListener","err","event","special","touchstart","touchmove","touchend","SortableList","root","config","info","proxy","proxyDelta","dragCounter","lastEvent","extend","listSelector","on","dragStartHandler","clickHandler","EVENTS","DRAGSTART","DRAG","DROP","DRAGEND","prototype","resetDraggedClasses","classes","i","removeClass","remove","calculatePositionOnPage","evt","originalEvent","touches","undefined","touch","pageX","pageY","clientX","Math","round","window","scrollLeft","clientY","scrollTop","type","moveElement","sourceList","sourceNextElement","finishDragging","which","movedElement","target","closest","currentTarget","children","length","stopPropagation","preventDefault","element","next","parent","targetNextElement","targetList","dropped","startX","startY","startTime","Date","getTime","addClass","offset","left","y","top","thisDragCounter","setTimeout","createProxy","dragHandler","dragcancelHandler","start","trigger","executeCallback","clone","append","removeAttr","css","position","keyCode","clickedElement","displayMoveDialogue","getPositionInNode","rect","getBoundingClientRect","scrollY","scrollX","width","height","xRatio","yRatio","isListHorizontal","elementFromPoint","mainElement","isNotSelf","current","filter","currentList","isNotProxy","find","coordinates","ratio","subList","subListEmpty","endX","endY","endTime","positionChanged","hasPositionChanged","oldinfo","classList","add","parentElement","beforeElement","dragEl","insertBefore","appendChild","stop","off","eventName","getElementName","Deferred","resolve","text","getDestinationName","afterElement","then","name","get_string","getMoveDialogueTitle","handler","attr","getDestinationsList","addedLists","targets","destinations","result","when","createLink","is","contains","txt","li","appendTo","data","addList","inArray","push","list","each","prev","last","create","title","body","modal","quickMoveHandler","e","focus","hide","getRoot","hidden","destroy","setLarge","show","catch","exception"],"mappings":"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"}