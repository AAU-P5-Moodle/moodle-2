{"version":3,"file":"focuslock.min.js","sources":["../../../src/local/aria/focuslock.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Tab locking system.\r\n *\r\n * This is based on code and examples provided in the ARIA specification.\r\n * https://www.w3.org/TR/wai-aria-practices/examples/dialog-modal/dialog.html\r\n *\r\n * @module     core/local/aria/focuslock\r\n * @copyright  2019 Andrew Nicols <andrew@nicols.co.uk>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nimport Selectors from './selectors';\r\n\r\nconst lockRegionStack = [];\r\nconst initialFocusElementStack = [];\r\nconst finalFocusElementStack = [];\r\n\r\nlet lastFocus = null;\r\nlet ignoreFocusChanges = false;\r\nlet isLocked = false;\r\n\r\n/**\r\n * The lock handler.\r\n *\r\n * This is the item that does a majority of the work.\r\n * The overall logic from this comes from the examles in the WCAG guidelines.\r\n *\r\n * The general idea is that if the focus is not held within by an Element within the lock region, then we replace focus\r\n * on the first element in the lock region. If the first element is the element previously selected prior to the\r\n * user-initiated focus change, then instead jump to the last element in the lock region.\r\n *\r\n * This gives us a solution which supports focus locking of any kind, which loops in both directions, and which\r\n * prevents the lock from escaping the modal entirely.\r\n *\r\n * @method\r\n * @param {Event} event The event from the focus change\r\n */\r\nconst lockHandler = event => {\r\n    if (ignoreFocusChanges) {\r\n        // The focus change was made by an internal call to set focus.\r\n        return;\r\n    }\r\n\r\n    // Find the current lock region.\r\n    let lockRegion = getCurrentLockRegion();\r\n    while (lockRegion) {\r\n        if (document.contains(lockRegion)) {\r\n            break;\r\n        }\r\n\r\n        // The lock region does not exist.\r\n        // Perhaps it was removed without being untrapped.\r\n        untrapFocus();\r\n        lockRegion = getCurrentLockRegion();\r\n    }\r\n    if (!lockRegion) {\r\n        return;\r\n    }\r\n\r\n    if (lockRegion.contains(event.target)) {\r\n        lastFocus = event.target;\r\n    } else {\r\n        focusFirstDescendant();\r\n        if (lastFocus == document.activeElement) {\r\n            focusLastDescendant();\r\n        }\r\n        lastFocus = document.activeElement;\r\n    }\r\n};\r\n\r\n/**\r\n * Focus the first descendant of the current lock region.\r\n *\r\n * @method\r\n * @returns {Bool} Whether a node was focused\r\n */\r\nconst focusFirstDescendant = () => {\r\n    const lockRegion = getCurrentLockRegion();\r\n\r\n    // Grab all elements in the lock region and attempt to focus each element until one is focused.\r\n    // We can capture most of this in the query selector, but some cases may still reject focus.\r\n    // For example, a disabled text area cannot be focused, and it becomes difficult to provide a decent query selector\r\n    // to capture this.\r\n    // The use of Array.some just ensures that we stop as soon as we have a successful focus.\r\n    const focusableElements = Array.from(lockRegion.querySelectorAll(Selectors.elements.focusable));\r\n\r\n    // The lock region itself may be focusable. This is particularly true on Moodle's older dialogues.\r\n    // We must include it in the calculation of descendants to ensure that looping works correctly.\r\n    focusableElements.unshift(lockRegion);\r\n    return focusableElements.some(focusableElement => attemptFocus(focusableElement));\r\n};\r\n\r\n/**\r\n * Focus the last descendant of the current lock region.\r\n *\r\n * @method\r\n * @returns {Bool} Whether a node was focused\r\n */\r\nconst focusLastDescendant = () => {\r\n    const lockRegion = getCurrentLockRegion();\r\n\r\n    // Grab all elements in the lock region, reverse them, and attempt to focus each element until one is focused.\r\n    // We can capture most of this in the query selector, but some cases may still reject focus.\r\n    // For example, a disabled text area cannot be focused, and it becomes difficult to provide a decent query selector\r\n    // to capture this.\r\n    // The use of Array.some just ensures that we stop as soon as we have a successful focus.\r\n    const focusableElements = Array.from(lockRegion.querySelectorAll(Selectors.elements.focusable)).reverse();\r\n\r\n    // The lock region itself may be focusable. This is particularly true on Moodle's older dialogues.\r\n    // We must include it in the calculation of descendants to ensure that looping works correctly.\r\n    focusableElements.push(lockRegion);\r\n    return focusableElements.some(focusableElement => attemptFocus(focusableElement));\r\n};\r\n\r\n/**\r\n * Check whether the supplied focusTarget is actually focusable.\r\n * There are cases where a normally focusable element can reject focus.\r\n *\r\n * Note: This example is a wholesale copy of the WCAG example.\r\n *\r\n * @method\r\n * @param {HTMLElement} focusTarget\r\n * @returns {Bool}\r\n */\r\nconst isFocusable = focusTarget => {\r\n    if (focusTarget.tabIndex > 0 || (focusTarget.tabIndex === 0 && focusTarget.getAttribute('tabIndex') !== null)) {\r\n        return true;\r\n    }\r\n\r\n    if (focusTarget.disabled) {\r\n        return false;\r\n    }\r\n\r\n    switch (focusTarget.nodeName) {\r\n        case 'A':\r\n            return !!focusTarget.href && focusTarget.rel != 'ignore';\r\n        case 'INPUT':\r\n            return focusTarget.type != 'hidden' && focusTarget.type != 'file';\r\n        case 'BUTTON':\r\n        case 'SELECT':\r\n        case 'TEXTAREA':\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n};\r\n\r\n/**\r\n * Attempt to focus the supplied focusTarget.\r\n *\r\n * Note: This example is a heavily inspired by the WCAG example.\r\n *\r\n * @method\r\n * @param {HTMLElement} focusTarget\r\n * @returns {Bool} Whether focus was successful o rnot.\r\n */\r\nconst attemptFocus = focusTarget => {\r\n    if (!isFocusable(focusTarget)) {\r\n        return false;\r\n    }\r\n\r\n    // The ignoreFocusChanges variable prevents the focus event handler from interfering and entering a fight with itself.\r\n    ignoreFocusChanges = true;\r\n\r\n    try {\r\n        focusTarget.focus();\r\n    } catch (e) {\r\n        // Ignore failures. We will just try to focus the next element in the list.\r\n    }\r\n\r\n    ignoreFocusChanges = false;\r\n\r\n    // If focus was successful the activeElement will be the one we focused.\r\n    return (document.activeElement === focusTarget);\r\n};\r\n\r\n/**\r\n * Get the current lock region from the top of the stack.\r\n *\r\n * @method\r\n * @returns {HTMLElement}\r\n */\r\nconst getCurrentLockRegion = () => {\r\n    return lockRegionStack[lockRegionStack.length - 1];\r\n};\r\n\r\n/**\r\n * Add a new lock region to the stack.\r\n *\r\n * @method\r\n * @param {HTMLElement} newLockRegion\r\n */\r\nconst addLockRegionToStack = newLockRegion => {\r\n    if (newLockRegion === getCurrentLockRegion()) {\r\n        return;\r\n    }\r\n\r\n    lockRegionStack.push(newLockRegion);\r\n    const currentLockRegion = getCurrentLockRegion();\r\n\r\n    // Append an empty div which can be focused just outside of the item locked.\r\n    // This locks tab focus to within the tab region, and does not allow it to extend back into the window by\r\n    // guaranteeing the existence of a tabable item after the lock region which can be focused but which will be caught\r\n    // by the handler.\r\n    const element = document.createElement('div');\r\n    element.tabIndex = 0;\r\n    element.style.position = 'fixed';\r\n    element.style.top = 0;\r\n    element.style.left = 0;\r\n\r\n    const initialNode = element.cloneNode();\r\n    currentLockRegion.parentNode.insertBefore(initialNode, currentLockRegion);\r\n    initialFocusElementStack.push(initialNode);\r\n\r\n    const finalNode = element.cloneNode();\r\n    currentLockRegion.parentNode.insertBefore(finalNode, currentLockRegion.nextSibling);\r\n    finalFocusElementStack.push(finalNode);\r\n};\r\n\r\n/**\r\n * Remove the top lock region from the stack.\r\n *\r\n * @method\r\n */\r\nconst removeLastLockRegionFromStack = () => {\r\n    // Take the top element off the stack, and replce the current lockRegion value.\r\n    lockRegionStack.pop();\r\n\r\n    const finalNode = finalFocusElementStack.pop();\r\n    if (finalNode) {\r\n        // The final focus element may have been removed if it was part of a parent item.\r\n        finalNode.remove();\r\n    }\r\n\r\n    const initialNode = initialFocusElementStack.pop();\r\n    if (initialNode) {\r\n        // The initial focus element may have been removed if it was part of a parent item.\r\n        initialNode.remove();\r\n    }\r\n};\r\n\r\n/**\r\n * Whether any region is left in the stack.\r\n *\r\n * @return {Bool}\r\n */\r\nconst hasTrappedRegionsInStack = () => {\r\n    return !!lockRegionStack.length;\r\n};\r\n\r\n/**\r\n * Start trapping the focus and lock it to the specified newLockRegion.\r\n *\r\n * @method\r\n * @param {HTMLElement} newLockRegion The container to lock focus to\r\n */\r\nexport const trapFocus = newLockRegion => {\r\n    // Update the lock region stack.\r\n    // This allows us to support nesting.\r\n    addLockRegionToStack(newLockRegion);\r\n\r\n    if (!isLocked) {\r\n        // Add the focus handler.\r\n        document.addEventListener('focus', lockHandler, true);\r\n    }\r\n\r\n    // Attempt to focus on the first item in the lock region.\r\n    if (!focusFirstDescendant()) {\r\n        const currentLockRegion = getCurrentLockRegion();\r\n\r\n        // No focusable descendants found in the region yet.\r\n        // This can happen when the region is locked before content is generated.\r\n        // Focus on the region itself for now.\r\n        const originalRegionTabIndex = currentLockRegion.tabIndex;\r\n        currentLockRegion.tabIndex = 0;\r\n        attemptFocus(currentLockRegion);\r\n        currentLockRegion.tabIndex = originalRegionTabIndex;\r\n    }\r\n\r\n    // Keep track of the last item focused.\r\n    lastFocus = document.activeElement;\r\n\r\n    isLocked = true;\r\n};\r\n\r\n/**\r\n * Stop trapping the focus.\r\n *\r\n * @method\r\n */\r\nexport const untrapFocus = () => {\r\n    // Remove the top region from the stack.\r\n    removeLastLockRegionFromStack();\r\n\r\n    if (hasTrappedRegionsInStack()) {\r\n        // The focus manager still has items in the stack.\r\n        return;\r\n    }\r\n\r\n    document.removeEventListener('focus', lockHandler, true);\r\n\r\n    lastFocus = null;\r\n    ignoreFocusChanges = false;\r\n    isLocked = false;\r\n};\r\n"],"names":["e","_selectors","__esModule","default","lockRegionStack","initialFocusElementStack","finalFocusElementStack","lastFocus","ignoreFocusChanges","isLocked","lockHandler","event","lockRegion","getCurrentLockRegion","document","contains","untrapFocus","target","focusFirstDescendant","activeElement","focusLastDescendant","focusableElements","Array","from","querySelectorAll","Selectors","elements","focusable","unshift","some","focusableElement","attemptFocus","reverse","push","focusTarget","tabIndex","getAttribute","disabled","nodeName","href","rel","type","isFocusable","focus","length","_exports","trapFocus","newLockRegion","currentLockRegion","element","createElement","style","position","top","left","initialNode","cloneNode","parentNode","insertBefore","finalNode","nextSibling","addLockRegionToStack","addEventListener","originalRegionTabIndex","removeLastLockRegionFromStack","pop","remove","removeEventListener"],"mappings":"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"}