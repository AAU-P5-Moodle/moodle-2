{"version":3,"file":"aria-hidden.min.js","sources":["../../../src/local/aria/aria-hidden.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * ARIA helpers related to the aria-hidden attribute.\r\n *\r\n * @module     core/local/aria/aria-hidden.\r\n * @copyright  2020 Andrew Nicols <andrew@nicols.co.uk>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nimport {getList} from 'core/normalise';\r\nimport Selectors from './selectors';\r\n\r\n// The map of MutationObserver objects for an object.\r\nconst childObserverMap = new Map();\r\nconst siblingObserverMap = new Map();\r\n\r\n/**\r\n * Determine whether the browser supports the MutationObserver system.\r\n *\r\n * @method\r\n * @returns {Bool}\r\n */\r\nconst supportsMutationObservers = () => (MutationObserver && typeof MutationObserver === 'function');\r\n\r\n/**\r\n * Disable element focusability, disabling the tabindex for child elements which are normally focusable.\r\n *\r\n * @method\r\n * @param {HTMLElement} target\r\n */\r\nconst disableElementFocusability = target => {\r\n    if (!(target instanceof HTMLElement)) {\r\n        // This element is not an HTMLElement.\r\n        // This can happen for Text Nodes.\r\n        return;\r\n    }\r\n\r\n    if (target.matches(Selectors.elements.focusable)) {\r\n        disableAndStoreTabIndex(target);\r\n    }\r\n\r\n    target.querySelectorAll(Selectors.elements.focusable).forEach(disableAndStoreTabIndex);\r\n};\r\n\r\n/**\r\n * Remove the current tab-index and store it for later restoration.\r\n *\r\n * @method\r\n * @param {HTMLElement} element\r\n */\r\nconst disableAndStoreTabIndex = element => {\r\n    if (typeof element.dataset.ariaHiddenTabIndex !== 'undefined') {\r\n        // This child already has a hidden attribute.\r\n        // Do not modify it as the original value will be lost.\r\n        return;\r\n    }\r\n\r\n    // Store the old tabindex in a data attribute.\r\n    if (element.getAttribute('tabindex')) {\r\n        element.dataset.ariaHiddenTabIndex = element.getAttribute('tabindex');\r\n    } else {\r\n        element.dataset.ariaHiddenTabIndex = '';\r\n    }\r\n    element.setAttribute('tabindex', -1);\r\n};\r\n\r\n/**\r\n * Re-enable element focusability, restoring any tabindex.\r\n *\r\n * @method\r\n * @param {HTMLElement} target\r\n */\r\nconst enableElementFocusability = target => {\r\n    if (!(target instanceof HTMLElement)) {\r\n        // This element is not an HTMLElement.\r\n        // This can happen for Text Nodes.\r\n        return;\r\n    }\r\n\r\n    if (target.matches(Selectors.elements.focusableToUnhide)) {\r\n        restoreTabIndex(target);\r\n    }\r\n\r\n    target.querySelectorAll(Selectors.elements.focusableToUnhide).forEach(restoreTabIndex);\r\n};\r\n\r\n/**\r\n * Restore the tab-index of the supplied element.\r\n *\r\n * When disabling focusability the current tab-index is stored in the ariaHiddenTabIndex data attribute.\r\n * This is used to restore the tab-index, but only whilst the parent nodes remain unhidden.\r\n *\r\n * @method\r\n * @param {HTMLElement} element\r\n */\r\nconst restoreTabIndex = element => {\r\n    if (element.closest(Selectors.aria.hidden)) {\r\n        // This item still has a hidden parent, or is hidden itself. Do not unhide it.\r\n        return;\r\n    }\r\n\r\n    const oldTabIndex = element.dataset.ariaHiddenTabIndex;\r\n    if (oldTabIndex === '') {\r\n        element.removeAttribute('tabindex');\r\n    } else {\r\n        element.setAttribute('tabindex', oldTabIndex);\r\n    }\r\n\r\n    delete element.dataset.ariaHiddenTabIndex;\r\n};\r\n\r\n/**\r\n * Update the supplied DOM Module to be hidden.\r\n *\r\n * @method\r\n * @param {HTMLElement} target\r\n * @returns {Array}\r\n */\r\nexport const hide = target => getList(target).forEach(_hide);\r\n\r\nconst _hide = target => {\r\n    if (!(target instanceof HTMLElement)) {\r\n        // This element is not an HTMLElement.\r\n        // This can happen for Text Nodes.\r\n        return;\r\n    }\r\n\r\n    if (target.closest(Selectors.aria.hidden)) {\r\n        // This Element, or a parent Element, is already hidden.\r\n        // Stop processing.\r\n        return;\r\n    }\r\n\r\n    // Set the aria-hidden attribute to true.\r\n    target.setAttribute('aria-hidden', true);\r\n\r\n    // Based on advice from https://dequeuniversity.com/rules/axe/3.3/aria-hidden-focus, upon setting the aria-hidden\r\n    // attribute, all focusable elements underneath that element should be modified such that they are not focusable.\r\n    disableElementFocusability(target);\r\n\r\n    if (supportsMutationObservers()) {\r\n        // Add a MutationObserver to check for new children to the tree.\r\n        const mutationObserver = new MutationObserver(mutationList => {\r\n            mutationList.forEach(mutation => {\r\n                if (mutation.type === 'childList') {\r\n                    mutation.addedNodes.forEach(disableElementFocusability);\r\n                } else if (mutation.type === 'attributes') {\r\n                    // The tabindex has been updated on a hidden attribute.\r\n                    // Ensure that it is stored, ad set to -1 to prevent breakage.\r\n                    const element = mutation.target;\r\n                    const proposedTabIndex = element.getAttribute('tabindex');\r\n\r\n                    if (proposedTabIndex !== \"-1\") {\r\n                        element.dataset.ariaHiddenTabIndex = proposedTabIndex;\r\n                        element.setAttribute('tabindex', -1);\r\n                    }\r\n                }\r\n            });\r\n        });\r\n\r\n        mutationObserver.observe(target, {\r\n            // Watch for changes to the entire subtree.\r\n            subtree: true,\r\n\r\n            // Watch for new nodes.\r\n            childList: true,\r\n\r\n            // Watch for attribute changes to the tabindex.\r\n            attributes: true,\r\n            attributeFilter: ['tabindex'],\r\n        });\r\n        childObserverMap.set(target, mutationObserver);\r\n    }\r\n};\r\n\r\n/**\r\n * Reverse the effect of the hide action.\r\n *\r\n * @method\r\n * @param {HTMLElement} target\r\n * @returns {Array}\r\n */\r\nexport const unhide = target => getList(target).forEach(_unhide);\r\n\r\nconst _unhide = target => {\r\n    if (!(target instanceof HTMLElement)) {\r\n        return;\r\n    }\r\n\r\n    // Note: The aria-hidden attribute should be removed, and not set to false.\r\n    // The presence of the attribute is sufficient for some browsers to treat it as being true, regardless of its value.\r\n    target.removeAttribute('aria-hidden');\r\n\r\n    // Restore the tabindex across all child nodes of the target.\r\n    enableElementFocusability(target);\r\n\r\n    // Remove the focusability MutationObserver watching this tree.\r\n    if (childObserverMap.has(target)) {\r\n        childObserverMap.get(target).disconnect();\r\n        childObserverMap.delete(target);\r\n    }\r\n};\r\n\r\n/**\r\n * Correctly mark all siblings of the supplied target Element as hidden.\r\n *\r\n * @method\r\n * @param {HTMLElement} target\r\n * @returns {Array}\r\n */\r\nexport const hideSiblings = target => getList(target).forEach(_hideSiblings);\r\n\r\nconst _hideSiblings = target => {\r\n    if (!(target instanceof HTMLElement)) {\r\n        return;\r\n    }\r\n\r\n    if (!target.parentElement) {\r\n        return;\r\n    }\r\n\r\n    target.parentElement.childNodes.forEach(node => {\r\n        if (node === target) {\r\n            // Skip self;\r\n            return;\r\n        }\r\n\r\n        hide(node);\r\n    });\r\n\r\n    if (supportsMutationObservers()) {\r\n        // Add a MutationObserver to check for new children to the tree.\r\n        const newNodeObserver = new MutationObserver(mutationList => {\r\n            mutationList.forEach(mutation => {\r\n                mutation.addedNodes.forEach(node => {\r\n                    if (target.contains(node)) {\r\n                        // Skip self, and children of self.\r\n                        return;\r\n                    }\r\n\r\n                    hide(node);\r\n                });\r\n            });\r\n        });\r\n\r\n        newNodeObserver.observe(target.parentElement, {childList: true, subtree: true});\r\n        siblingObserverMap.set(target.parentElement, newNodeObserver);\r\n    }\r\n};\r\n\r\n/**\r\n * Correctly reverse the hide action of all children of the supplied target Element.\r\n *\r\n * @method\r\n * @param {HTMLElement} target\r\n * @returns {Array}\r\n */\r\nexport const unhideSiblings = target => getList(target).forEach(_unhideSiblings);\r\n\r\nconst _unhideSiblings = target => {\r\n    if (!(target instanceof HTMLElement)) {\r\n        return;\r\n    }\r\n\r\n    if (!target.parentElement) {\r\n        return;\r\n    }\r\n\r\n    target.parentElement.childNodes.forEach(node => {\r\n        if (node === target) {\r\n            // Skip self;\r\n            return;\r\n        }\r\n\r\n        unhide(node);\r\n    });\r\n\r\n    // Remove the sibling MutationObserver watching this tree.\r\n    if (siblingObserverMap.has(target.parentElement)) {\r\n        siblingObserverMap.get(target.parentElement).disconnect();\r\n        siblingObserverMap.delete(target.parentElement);\r\n    }\r\n};\r\n"],"names":["e","_selectors","__esModule","default","childObserverMap","Map","siblingObserverMap","supportsMutationObservers","MutationObserver","disableElementFocusability","target","HTMLElement","matches","Selectors","elements","focusable","disableAndStoreTabIndex","querySelectorAll","forEach","element","dataset","ariaHiddenTabIndex","getAttribute","setAttribute","restoreTabIndex","closest","aria","hidden","oldTabIndex","removeAttribute","hide","getList","_hide","_exports","mutationObserver","mutationList","mutation","type","addedNodes","proposedTabIndex","observe","subtree","childList","attributes","attributeFilter","set","unhide","_unhide","focusableToUnhide","enableElementFocusability","has","get","disconnect","delete","hideSiblings","_hideSiblings","parentElement","childNodes","node","newNodeObserver","contains","unhideSiblings","_unhideSiblings"],"mappings":"0HAuBoC,IAAAA;;;;;;;gJAApCC,YAAoCD,EAApCC,aAAoCD,EAAAE,WAAAF,EAAAG,CAAAA,QAAAH,GAGpC,MAAMI,iBAAmB,IAAIC,IACvBC,mBAAqB,IAAID,IAQzBE,0BAA4BA,IAAOC,kBAAgD,mBAArBA,iBAQ9DC,2BAA6BC,SACzBA,kBAAkBC,cAMpBD,OAAOE,QAAQC,WAAAA,QAAUC,SAASC,YAClCC,wBAAwBN,QAG5BA,OAAOO,iBAAiBJ,WAAAA,QAAUC,SAASC,WAAWG,QAAQF,yBAAwB,EASpFA,wBAA0BG,eACsB,IAAvCA,QAAQC,QAAQC,qBAOvBF,QAAQG,aAAa,YACrBH,QAAQC,QAAQC,mBAAqBF,QAAQG,aAAa,YAE1DH,QAAQC,QAAQC,mBAAqB,GAEzCF,QAAQI,aAAa,YAAa,GAAE,EAgClCC,gBAAkBL,UACpB,GAAIA,QAAQM,QAAQZ,WAAAA,QAAUa,KAAKC,QAE/B,OAGJ,MAAMC,YAAcT,QAAQC,QAAQC,mBAChB,KAAhBO,YACAT,QAAQU,gBAAgB,YAExBV,QAAQI,aAAa,WAAYK,oBAG9BT,QAAQC,QAAQC,kBAAkB,EAUhCS,KAAOpB,SAAU,EAAAqB,WAAAA,SAAQrB,QAAQQ,QAAQc,OAAOC,SAAAH,KAAAA,KAE7D,MAAME,MAAQtB,SACV,GAAMA,kBAAkBC,cAMpBD,OAAOe,QAAQZ,WAAAA,QAAUa,KAAKC,UAOlCjB,OAAOa,aAAa,eAAe,GAInCd,2BAA2BC,QAEvBH,6BAA6B,CAE7B,MAAM2B,iBAAmB,IAAI1B,kBAAiB2B,eAC1CA,aAAajB,SAAQkB,WACjB,GAAsB,cAAlBA,SAASC,KACTD,SAASE,WAAWpB,QAAQT,iCACzB,GAAsB,eAAlB2B,SAASC,KAAuB,CAGvC,MAAMlB,QAAUiB,SAAS1B,OACnB6B,iBAAmBpB,QAAQG,aAAa,YAErB,OAArBiB,mBACApB,QAAQC,QAAQC,mBAAqBkB,iBACrCpB,QAAQI,aAAa,YAAa,GAE1C,IACF,IAGNW,iBAAiBM,QAAQ9B,OAAQ,CAE7B+B,SAAS,EAGTC,WAAW,EAGXC,YAAY,EACZC,gBAAiB,CAAC,cAEtBxC,iBAAiByC,IAAInC,OAAQwB,iBACjC,GAUSY,OAASpC,SAAU,EAAAqB,WAAAA,SAAQrB,QAAQQ,QAAQ6B,SAASd,SAAAa,OAAAA,OAEjE,MAAMC,QAAUrC,SACNA,kBAAkBC,cAMxBD,OAAOmB,gBAAgB,eAvHOnB,UACxBA,kBAAkBC,cAMpBD,OAAOE,QAAQC,WAAAA,QAAUC,SAASkC,oBAClCxB,gBAAgBd,QAGpBA,OAAOO,iBAAiBJ,WAAAA,QAAUC,SAASkC,mBAAmB9B,QAAQM,iBAAgB,EA+GtFyB,CAA0BvC,QAGtBN,iBAAiB8C,IAAIxC,UACrBN,iBAAiB+C,IAAIzC,QAAQ0C,aAC7BhD,iBAAiBiD,OAAO3C,SAC5B,EAUyEuB,SAAAqB,aAAjD5C,SAAU,EAAAqB,WAAAA,SAAQrB,QAAQQ,QAAQqC,eAE9D,MAAMA,cAAgB7C,SAClB,GAAMA,kBAAkBC,aAInBD,OAAO8C,gBAIZ9C,OAAO8C,cAAcC,WAAWvC,SAAQwC,OAChCA,OAAShD,QAKboB,KAAK4B,KAAK,IAGVnD,6BAA6B,CAE7B,MAAMoD,gBAAkB,IAAInD,kBAAiB2B,eACzCA,aAAajB,SAAQkB,WACjBA,SAASE,WAAWpB,SAAQwC,OACpBhD,OAAOkD,SAASF,OAKpB5B,KAAK4B,KAAK,GACZ,GACJ,IAGNC,gBAAgBnB,QAAQ9B,OAAO8C,cAAe,CAACd,WAAW,EAAMD,SAAS,IACzEnC,mBAAmBuC,IAAInC,OAAO8C,cAAeG,gBACjD,GAU6E1B,SAAA4B,eAAnDnD,SAAU,EAAAqB,WAAAA,SAAQrB,QAAQQ,QAAQ4C,iBAEhE,MAAMA,gBAAkBpD,SACdA,kBAAkBC,aAInBD,OAAO8C,gBAIZ9C,OAAO8C,cAAcC,WAAWvC,SAAQwC,OAChCA,OAAShD,QAKboC,OAAOY,KAAK,IAIZpD,mBAAmB4C,IAAIxC,OAAO8C,iBAC9BlD,mBAAmB6C,IAAIzC,OAAO8C,eAAeJ,aAC7C9C,mBAAmB+C,OAAO3C,OAAO8C,gBACrC,CACF"}