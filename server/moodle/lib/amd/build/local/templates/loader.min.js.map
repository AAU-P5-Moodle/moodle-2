{"version":3,"file":"loader.min.js","sources":["../../../src/local/templates/loader.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nimport $ from 'jquery';\r\nimport ajax from 'core/ajax';\r\nimport * as str from 'core/str';\r\nimport * as config from 'core/config';\r\nimport mustache from 'core/mustache';\r\nimport storage from 'core/localstorage';\r\nimport {getNormalisedComponent} from 'core/utils';\r\n\r\n/**\r\n * Template this.\r\n *\r\n * @module     core/local/templates/loader\r\n * @copyright  2023 Andrew Lyons <andrew@nicols.co.uk>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n * @since      4.3\r\n */\r\nexport default class Loader {\r\n    /** @var {String} themeName for the current render */\r\n    currentThemeName = '';\r\n\r\n    /** @var {Object[]} loadTemplateBuffer - List of templates to be loaded */\r\n    static loadTemplateBuffer = [];\r\n\r\n    /** @var {Bool} isLoadingTemplates - Whether templates are currently being loaded */\r\n    static isLoadingTemplates = false;\r\n\r\n    /** @var {Map} templateCache - Cache of already loaded template strings */\r\n    static templateCache = new Map();\r\n\r\n    /** @var {Promise[]} templatePromises - Cache of already loaded template promises */\r\n    static templatePromises = {};\r\n\r\n    /** @var {Promise[]} cachePartialPromises - Cache of already loaded template partial promises */\r\n    static cachePartialPromises = [];\r\n\r\n    /**\r\n     * A helper to get the search key\r\n     *\r\n     * @param {string} theme\r\n     * @param {string} templateName\r\n     * @returns {string}\r\n     */\r\n    static getSearchKey(theme, templateName) {\r\n        return `${theme}/${templateName}`;\r\n    }\r\n\r\n    /**\r\n     * Load a template.\r\n     *\r\n     * @method getTemplate\r\n     * @param {string} templateName - should consist of the component and the name of the template like this:\r\n     *                              core/menu (lib/templates/menu.mustache) or\r\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\r\n     * @param {string} [themeName=config.theme] - The theme to load the template from\r\n     * @return {Promise} JQuery promise object resolved when the template has been fetched.\r\n     */\r\n    static getTemplate(templateName, themeName = config.theme) {\r\n        const searchKey = this.getSearchKey(themeName, templateName);\r\n\r\n        // If we haven't already seen this template then buffer it.\r\n        const cachedPromise = this.getTemplatePromiseFromCache(searchKey);\r\n        if (cachedPromise) {\r\n            return cachedPromise;\r\n        }\r\n\r\n        // Check the buffer to see if this template has already been added.\r\n        const existingBufferRecords = this.loadTemplateBuffer.filter((record) => record.searchKey === searchKey);\r\n        if (existingBufferRecords.length) {\r\n            // This template is already in the buffer so just return the existing\r\n            // promise. No need to add it to the buffer again.\r\n            return existingBufferRecords[0].deferred.promise();\r\n        }\r\n\r\n        // This is the first time this has been requested so let's add it to the buffer\r\n        // to be loaded.\r\n        const parts = templateName.split('/');\r\n        const component = getNormalisedComponent(parts.shift());\r\n        const name = parts.join('/');\r\n        const deferred = $.Deferred();\r\n\r\n        // Add this template to the buffer to be loaded.\r\n        this.loadTemplateBuffer.push({\r\n            component,\r\n            name,\r\n            theme: themeName,\r\n            searchKey,\r\n            deferred,\r\n        });\r\n\r\n        // We know there is at least one thing in the buffer so kick off a processing run.\r\n        this.processLoadTemplateBuffer();\r\n        return deferred.promise();\r\n    }\r\n\r\n    /**\r\n     * Store a template in the cache.\r\n     *\r\n     * @param {string} searchKey\r\n     * @param {string} templateSource\r\n     */\r\n    static setTemplateInCache(searchKey, templateSource) {\r\n        // Cache all of the dependent templates because we'll need them to render\r\n        // the requested template.\r\n        this.templateCache.set(searchKey, templateSource);\r\n    }\r\n\r\n    /**\r\n     * Fetch a template from the cache.\r\n     *\r\n     * @param {string} searchKey\r\n     * @returns {string}\r\n     */\r\n    static getTemplateFromCache(searchKey) {\r\n        return this.templateCache.get(searchKey);\r\n    }\r\n\r\n    /**\r\n     * Check whether a template is in the cache.\r\n     *\r\n     * @param {string} searchKey\r\n     * @returns {bool}\r\n     */\r\n    static hasTemplateInCache(searchKey) {\r\n        return this.templateCache.has(searchKey);\r\n    }\r\n\r\n    /**\r\n     * Prefetch a set of templates without rendering them.\r\n     *\r\n     * @param {Array} templateNames The list of templates to fetch\r\n     * @param {string} themeName\r\n     */\r\n    static prefetchTemplates(templateNames, themeName) {\r\n        templateNames.forEach((templateName) => this.prefetchTemplate(templateName, themeName));\r\n    }\r\n\r\n    /**\r\n     * Prefetech a sginle template without rendering it.\r\n     *\r\n     * @param {string} templateName\r\n     * @param {string} themeName\r\n     */\r\n    static prefetchTemplate(templateName, themeName) {\r\n        const searchKey = this.getSearchKey(themeName, templateName);\r\n\r\n        // If we haven't already seen this template then buffer it.\r\n        if (this.hasTemplateInCache(searchKey)) {\r\n            return;\r\n        }\r\n\r\n        // Check the buffer to see if this template has already been added.\r\n        const existingBufferRecords = this.loadTemplateBuffer.filter((record) => record.searchKey === searchKey);\r\n\r\n        if (existingBufferRecords.length) {\r\n            // This template is already in the buffer so just return the existing promise.\r\n            // No need to add it to the buffer again.\r\n            return;\r\n        }\r\n\r\n        // This is the first time this has been requested so let's add it to the buffer to be loaded.\r\n        const parts = templateName.split('/');\r\n        const component = getNormalisedComponent(parts.shift());\r\n        const name = parts.join('/');\r\n\r\n        // Add this template to the buffer to be loaded.\r\n        this.loadTemplateBuffer.push({\r\n            component,\r\n            name,\r\n            theme: themeName,\r\n            searchKey,\r\n            deferred: $.Deferred(),\r\n        });\r\n\r\n        this.processLoadTemplateBuffer();\r\n    }\r\n\r\n    /**\r\n     * Load a partial from the cache or ajax.\r\n     *\r\n     * @method partialHelper\r\n     * @param {string} name The partial name to load.\r\n     * @param {string} [themeName = config.theme] The theme to load the partial from.\r\n     * @return {string}\r\n     */\r\n    static partialHelper(name, themeName = config.theme) {\r\n        const searchKey = this.getSearchKey(themeName, name);\r\n\r\n        if (!this.hasTemplateInCache(searchKey)) {\r\n            new Error(`Failed to pre-fetch the template: ${name}`);\r\n        }\r\n        return this.getTemplateFromCache(searchKey);\r\n    }\r\n\r\n    /**\r\n     * Scan a template source for partial tags and return a list of the found partials.\r\n     *\r\n     * @method scanForPartials\r\n     * @param {string} templateSource - source template to scan.\r\n     * @return {Array} List of partials.\r\n     */\r\n    static scanForPartials(templateSource) {\r\n        const tokens = mustache.parse(templateSource);\r\n        const partials = [];\r\n\r\n        const findPartial = (tokens, partials) => {\r\n            let i;\r\n            for (i = 0; i < tokens.length; i++) {\r\n                const token = tokens[i];\r\n                if (token[0] == '>' || token[0] == '<') {\r\n                    partials.push(token[1]);\r\n                }\r\n                if (token.length > 4) {\r\n                    findPartial(token[4], partials);\r\n                }\r\n            }\r\n        };\r\n\r\n        findPartial(tokens, partials);\r\n\r\n        return partials;\r\n    }\r\n\r\n    /**\r\n     * Load a template and scan it for partials. Recursively fetch the partials.\r\n     *\r\n     * @method cachePartials\r\n     * @param {string} templateName - should consist of the component and the name of the template like this:\r\n     *                              core/menu (lib/templates/menu.mustache) or\r\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\r\n     * @param {string} [themeName=config.theme]\r\n     * @param {Array} parentage - A list of requested partials in this render chain.\r\n     * @return {Promise} JQuery promise object resolved when all partials are in the cache.\r\n     */\r\n    static cachePartials(templateName, themeName = config.theme, parentage = []) {\r\n        const searchKey = this.getSearchKey(themeName, templateName);\r\n\r\n        if (searchKey in this.cachePartialPromises) {\r\n            return this.cachePartialPromises[searchKey];\r\n        }\r\n\r\n        // This promise will not be resolved until all child partials are also resolved and ready.\r\n        // We create it here to allow us to check for recursive inclusion of templates.\r\n        // Keep track of the requested partials in this chain.\r\n        if (!parentage.length) {\r\n            parentage.push(searchKey);\r\n        }\r\n\r\n        this.cachePartialPromises[searchKey] = $.Deferred();\r\n        this._cachePartials(templateName, themeName, parentage).catch((error) => {\r\n            this.cachePartialPromises[searchKey].reject(error);\r\n        });\r\n\r\n        return this.cachePartialPromises[searchKey];\r\n    }\r\n\r\n    /**\r\n     * Cache the template partials for the specified template.\r\n     *\r\n     * @param {string} templateName\r\n     * @param {string} themeName\r\n     * @param {array} parentage\r\n     * @returns {promise<string>}\r\n     */\r\n    static async _cachePartials(templateName, themeName, parentage) {\r\n        const searchKey = this.getSearchKey(themeName, templateName);\r\n        const templateSource = await this.getTemplate(templateName, themeName);\r\n        const partials = this.scanForPartials(templateSource);\r\n        const uniquePartials = partials.filter((partialName) => {\r\n            // Check for recursion.\r\n            if (parentage.indexOf(`${themeName}/${partialName}`) >= 0) {\r\n                // Ignore templates which include a parent template already requested in the current chain.\r\n                return false;\r\n            }\r\n\r\n            // Ignore templates that include themselves.\r\n            return partialName !== templateName;\r\n        });\r\n\r\n        // Fetch any partial which has not already been fetched.\r\n        const fetchThemAll = uniquePartials.map((partialName) => {\r\n            parentage.push(`${themeName}/${partialName}`);\r\n            return this.cachePartials(partialName, themeName, parentage);\r\n        });\r\n\r\n        await Promise.all(fetchThemAll);\r\n        return this.cachePartialPromises[searchKey].resolve(templateSource);\r\n    }\r\n\r\n    /**\r\n     * Take all of the templates waiting in the buffer and load them from the server\r\n     * or from the cache.\r\n     *\r\n     * All of the templates that need to be loaded from the server will be batched up\r\n     * and sent in a single network request.\r\n     */\r\n    static processLoadTemplateBuffer() {\r\n        if (!this.loadTemplateBuffer.length) {\r\n            return;\r\n        }\r\n\r\n        if (this.isLoadingTemplates) {\r\n            return;\r\n        }\r\n\r\n        this.isLoadingTemplates = true;\r\n        // Grab any templates waiting in the buffer.\r\n        const templatesToLoad = this.loadTemplateBuffer.slice();\r\n        // This will be resolved with the list of promises for the server request.\r\n        const serverRequestsDeferred = $.Deferred();\r\n        const requests = [];\r\n        // Get a list of promises for each of the templates we need to load.\r\n        const templatePromises = templatesToLoad.map((templateData) => {\r\n            const component = getNormalisedComponent(templateData.component);\r\n            const name = templateData.name;\r\n            const searchKey = templateData.searchKey;\r\n            const theme = templateData.theme;\r\n            const templateDeferred = templateData.deferred;\r\n            let promise = null;\r\n\r\n            // Double check to see if this template happened to have landed in the\r\n            // cache as a dependency of an earlier template.\r\n            if (this.hasTemplateInCache(searchKey)) {\r\n                // We've seen this template so immediately resolve the existing promise.\r\n                promise = this.getTemplatePromiseFromCache(searchKey);\r\n            } else {\r\n                // We haven't seen this template yet so we need to request it from\r\n                // the server.\r\n                requests.push({\r\n                    methodname: 'core_output_load_template_with_dependencies',\r\n                    args: {\r\n                        component,\r\n                        template: name,\r\n                        themename: theme,\r\n                        lang: config.language,\r\n                    }\r\n                });\r\n                // Remember the index in the requests list for this template so that\r\n                // we can get the appropriate promise back.\r\n                const index = requests.length - 1;\r\n\r\n                // The server deferred will be resolved with a list of all of the promises\r\n                // that were sent in the order that they were added to the requests array.\r\n                promise = serverRequestsDeferred.promise()\r\n                    .then((promises) => {\r\n                        // The promise for this template will be the one that matches the index\r\n                        // for it's entry in the requests array.\r\n                        //\r\n                        // Make sure the promise is added to the promises cache for this template\r\n                        // search key so that we don't request it again.\r\n                        templatePromises[searchKey] = promises[index].then((response) => {\r\n                            // Process all of the template dependencies for this template and add\r\n                            // them to the caches so that we don't request them again later.\r\n                            response.templates.forEach((data) => {\r\n                                data.component = getNormalisedComponent(data.component);\r\n                                const tempSearchKey = this.getSearchKey(\r\n                                    theme,\r\n                                    [data.component, data.name].join('/'),\r\n                                );\r\n\r\n                                // Cache all of the dependent templates because we'll need them to render\r\n                                // the requested template.\r\n                                this.setTemplateInCache(tempSearchKey, data.value);\r\n\r\n                                if (config.templaterev > 0) {\r\n                                    // The template cache is enabled - set the value there.\r\n                                    storage.set(`core_template/${config.templaterev}:${tempSearchKey}`, data.value);\r\n                                }\r\n                            });\r\n\r\n                            if (response.strings.length) {\r\n                                // If we have strings that the template needs then warm the string cache\r\n                                // with them now so that we don't need to re-fetch them.\r\n                                str.cache_strings(response.strings.map(({component, name, value}) => ({\r\n                                    component: getNormalisedComponent(component),\r\n                                    key: name,\r\n                                    value,\r\n                                })));\r\n                            }\r\n\r\n                            // Return the original template source that the user requested.\r\n                            if (this.hasTemplateInCache(searchKey)) {\r\n                                return this.getTemplateFromCache(searchKey);\r\n                            }\r\n\r\n                            return null;\r\n                        });\r\n\r\n                        return templatePromises[searchKey];\r\n                    });\r\n            }\r\n\r\n            return promise\r\n                // When we've successfully loaded the template then resolve the deferred\r\n                // in the buffer so that all of the calling code can proceed.\r\n                .then((source) => templateDeferred.resolve(source))\r\n                .catch((error) => {\r\n                    // If there was an error loading the template then reject the deferred\r\n                    // in the buffer so that all of the calling code can proceed.\r\n                    templateDeferred.reject(error);\r\n                    // Rethrow for anyone else listening.\r\n                    throw error;\r\n                });\r\n        });\r\n\r\n        if (requests.length) {\r\n            // We have requests to send so resolve the deferred with the promises.\r\n            serverRequestsDeferred.resolve(ajax.call(requests, true, false, false, 0, config.templaterev));\r\n        } else {\r\n            // Nothing to load so we can resolve our deferred.\r\n            serverRequestsDeferred.resolve();\r\n        }\r\n\r\n        // Once we've finished loading all of the templates then recurse to process\r\n        // any templates that may have been added to the buffer in the time that we\r\n        // were fetching.\r\n        $.when.apply(null, templatePromises)\r\n            .then(() => {\r\n                // Remove the templates we've loaded from the buffer.\r\n                this.loadTemplateBuffer.splice(0, templatesToLoad.length);\r\n                this.isLoadingTemplates = false;\r\n                this.processLoadTemplateBuffer();\r\n                return;\r\n            })\r\n            .catch(() => {\r\n                // Remove the templates we've loaded from the buffer.\r\n                this.loadTemplateBuffer.splice(0, templatesToLoad.length);\r\n                this.isLoadingTemplates = false;\r\n                this.processLoadTemplateBuffer();\r\n            });\r\n    }\r\n\r\n    /**\r\n     * Search the various caches for a template promise for the given search key.\r\n     * The search key should be in the format <theme>/<component>/<template> e.g. boost/core/modal.\r\n     *\r\n     * If the template is found in any of the caches it will populate the other caches with\r\n     * the same data as well.\r\n     *\r\n     * @param {String} searchKey The template search key in the format <theme>/<component>/<template> e.g. boost/core/modal\r\n     * @returns {Object|null} jQuery promise resolved with the template source\r\n     */\r\n    static getTemplatePromiseFromCache(searchKey) {\r\n        // First try the cache of promises.\r\n        if (searchKey in this.templatePromises) {\r\n            return this.templatePromises[searchKey];\r\n        }\r\n\r\n        // Check the module cache.\r\n        if (this.hasTemplateInCache(searchKey)) {\r\n            const templateSource = this.getTemplateFromCache(searchKey);\r\n            // Add this to the promises cache for future.\r\n            this.templatePromises[searchKey] = $.Deferred().resolve(templateSource).promise();\r\n            return this.templatePromises[searchKey];\r\n        }\r\n\r\n        if (config.templaterev <= 0) {\r\n            // Template caching is disabled. Do not store in persistent storage.\r\n            return null;\r\n        }\r\n\r\n        // Now try local storage.\r\n        const cached = storage.get(`core_template/${config.templaterev}:${searchKey}`);\r\n        if (cached) {\r\n            // Add this to the module cache for future.\r\n            this.setTemplateInCache(searchKey, cached);\r\n\r\n            // Add to the promises cache for future.\r\n            this.templatePromises[searchKey] = $.Deferred().resolve(cached).promise();\r\n            return this.templatePromises[searchKey];\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n"],"names":["_getRequireWildcardCache","e","WeakMap","r","t","_interopRequireWildcard","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_interopRequireDefault","_jquery","_ajax","str","config","_mustache","_localstorage","Loader","currentThemeName","static","Map","getSearchKey","theme","templateName","getTemplate","themeName","arguments","length","undefined","searchKey","this","cachedPromise","getTemplatePromiseFromCache","existingBufferRecords","loadTemplateBuffer","filter","record","deferred","promise","parts","split","component","getNormalisedComponent","shift","name","join","$","Deferred","push","processLoadTemplateBuffer","setTemplateInCache","templateSource","templateCache","getTemplateFromCache","hasTemplateInCache","prefetchTemplates","templateNames","forEach","prefetchTemplate","partialHelper","Error","scanForPartials","tokens","mustache","parse","partials","findPartial","token","cachePartials","parentage","cachePartialPromises","_cachePartials","catch","error","reject","fetchThemAll","partialName","indexOf","map","Promise","all","resolve","isLoadingTemplates","templatesToLoad","slice","serverRequestsDeferred","requests","templatePromises","templateData","templateDeferred","methodname","args","template","themename","lang","language","index","then","promises","response","templates","data","tempSearchKey","value","templaterev","storage","strings","cache_strings","_ref","key","source","ajax","when","apply","splice","cached","_exports"],"mappings":"4NAoBwC,SAAAA,yBAAAC,GAAA,GAAA,mBAAAC,QAAA,OAAA,KAAA,IAAAC,EAAAD,IAAAA,QAAAE,EAAAF,IAAAA,eAAAF,yBAAA,SAAAC,GAAAA,OAAAA,EAAAG,EAAAD,IAAAF,EAAA,CAAA,SAAAI,wBAAAJ,EAAAE,GAAAA,IAAAA,GAAAF,GAAAA,EAAAK,WAAAL,OAAAA,EAAAA,GAAAA,OAAAA,GAAAA,iBAAAA,GAAAA,mBAAAA,EAAAM,MAAAA,CAAAA,QAAAN,GAAAG,IAAAA,EAAAJ,yBAAAG,GAAA,GAAAC,GAAAA,EAAAI,IAAAP,GAAA,OAAAG,EAAAK,IAAAR,GAAA,IAAAS,EAAA,CAAAC,UAAA,MAAAC,EAAAC,OAAAC,gBAAAD,OAAAE,yBAAA,IAAA,IAAAC,KAAAf,EAAAe,GAAAA,YAAAA,GAAAC,CAAAA,EAAAA,eAAAC,KAAAjB,EAAAe,GAAAG,CAAAA,IAAAA,EAAAP,EAAAC,OAAAE,yBAAAd,EAAAe,GAAAG,KAAAA,IAAAA,EAAAV,KAAAU,EAAAC,KAAAP,OAAAC,eAAAJ,EAAAM,EAAAG,GAAAT,EAAAM,GAAAf,EAAAe,GAAAN,OAAAA,EAAAH,QAAAN,EAAAG,GAAAA,EAAAgB,IAAAnB,EAAAS,GAAAA,CAAA,CAAA,SAAAW,uBAAApB,GAAAA,OAAAA,GAAAA,EAAAK,WAAAL,EAAAM,CAAAA,QAAAN,EAAA;;;;;;;;qFALxCqB,QAAAD,uBAAAC,SACAC,MAAAF,uBAAAE,OACAC,IAAAnB,wBAAAmB,KACAC,OAAApB,wBAAAoB,QACAC,UAAAL,uBAAAK,WACAC,cAAAN,uBAAAM,eAWe,MAAMC,OAEjBC,iBAAmB,GAGnBC,0BAA4B,GAG5BA,2BAA4B,EAG5BA,qBAAuB,IAAIC,IAG3BD,wBAA0B,CAAA,EAG1BA,4BAA8B,GAS9B,mBAAOE,CAAaC,MAAOC,cACvB,MAAO,GAAGD,SAASC,cACvB,CAYA,kBAAOC,CAAYD,cAAwC,IAA1BE,UAASC,UAAAC,OAAAD,QAAAE,IAAAF,UAAAE,GAAAF,UAAGZ,GAAAA,OAAOQ,MAChD,MAAMO,UAAYC,KAAKT,aAAaI,UAAWF,cAGzCQ,cAAgBD,KAAKE,4BAA4BH,WACvD,GAAIE,cACA,OAAOA,cAIX,MAAME,sBAAwBH,KAAKI,mBAAmBC,QAAQC,QAAWA,OAAOP,YAAcA,YAC9F,GAAII,sBAAsBN,OAGtB,OAAOM,sBAAsB,GAAGI,SAASC,UAK7C,MAAMC,MAAQhB,aAAaiB,MAAM,KAC3BC,WAAY,EAAAC,OAAsBA,wBAACH,MAAMI,SACzCC,KAAOL,MAAMM,KAAK,KAClBR,SAAWS,QAAAA,QAAEC,WAanB,OAVAjB,KAAKI,mBAAmBc,KAAK,CACzBP,oBACAG,UACAtB,MAAOG,UACPI,oBACAQ,oBAIJP,KAAKmB,4BACEZ,SAASC,SACpB,CAQA,yBAAOY,CAAmBrB,UAAWsB,gBAGjCrB,KAAKsB,cAAc3C,IAAIoB,UAAWsB,eACtC,CAQA,2BAAOE,CAAqBxB,WACxB,OAAOC,KAAKsB,cAActD,IAAI+B,UAClC,CAQA,yBAAOyB,CAAmBzB,WACtB,OAAOC,KAAKsB,cAAcvD,IAAIgC,UAClC,CAQA,wBAAO0B,CAAkBC,cAAe/B,WACpC+B,cAAcC,SAASlC,cAAiBO,KAAK4B,iBAAiBnC,aAAcE,YAChF,CAQA,uBAAOiC,CAAiBnC,aAAcE,WAClC,MAAMI,UAAYC,KAAKT,aAAaI,UAAWF,cAG/C,GAAIO,KAAKwB,mBAAmBzB,WACxB,OAMJ,GAF8BC,KAAKI,mBAAmBC,QAAQC,QAAWA,OAAOP,YAAcA,YAEpEF,OAGtB,OAIJ,MAAMY,MAAQhB,aAAaiB,MAAM,KAC3BC,WAAY,EAAAC,OAAsBA,wBAACH,MAAMI,SACzCC,KAAOL,MAAMM,KAAK,KAGxBf,KAAKI,mBAAmBc,KAAK,CACzBP,oBACAG,UACAtB,MAAOG,UACPI,oBACAQ,SAAUS,QAAAA,QAAEC,aAGhBjB,KAAKmB,2BACT,CAUA,oBAAOU,CAAcf,MAAgC,IAA1BnB,UAASC,UAAAC,OAAAD,QAAAE,IAAAF,UAAAE,GAAAF,UAAGZ,GAAAA,OAAOQ,MAC1C,MAAMO,UAAYC,KAAKT,aAAaI,UAAWmB,MAK/C,OAHKd,KAAKwB,mBAAmBzB,YACzB,IAAI+B,MAAM,qCAAqChB,QAE5Cd,KAAKuB,qBAAqBxB,UACrC,CASA,sBAAOgC,CAAgBV,gBACnB,MAAMW,OAASC,UAAAA,QAASC,MAAMb,gBACxBc,SAAW,GAEXC,YAAcA,CAACJ,OAAQG,YACzB,IAAIzD,EACJ,IAAKA,EAAI,EAAGA,EAAIsD,OAAOnC,OAAQnB,IAAK,CAChC,MAAM2D,MAAQL,OAAOtD,GACL,KAAZ2D,MAAM,IAAyB,KAAZA,MAAM,IACzBF,SAASjB,KAAKmB,MAAM,IAEpBA,MAAMxC,OAAS,GACfuC,YAAYC,MAAM,GAAIF,SAE9B,GAKJ,OAFAC,YAAYJ,OAAQG,UAEbA,QACX,CAaA,oBAAOG,CAAc7C,cAAwD,IAA1CE,UAASC,UAAAC,OAAAD,QAAAE,IAAAF,UAAAE,GAAAF,UAAGZ,GAAAA,OAAOQ,MAAO+C,UAAS3C,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,GACrE,MAAMG,UAAYC,KAAKT,aAAaI,UAAWF,cAE/C,OAAIM,aAAaC,KAAKwC,uBAOjBD,UAAU1C,QACX0C,UAAUrB,KAAKnB,WAGnBC,KAAKwC,qBAAqBzC,WAAaiB,QAAClD,QAACmD,WACzCjB,KAAKyC,eAAehD,aAAcE,UAAW4C,WAAWG,OAAOC,QAC3D3C,KAAKwC,qBAAqBzC,WAAW6C,OAAOD,MAAM,KAZ3C3C,KAAKwC,qBAAqBzC,UAgBzC,CAUA,2BAAa0C,CAAehD,aAAcE,UAAW4C,WACjD,MAAMxC,UAAYC,KAAKT,aAAaI,UAAWF,cACzC4B,qBAAuBrB,KAAKN,YAAYD,aAAcE,WActDkD,aAbW7C,KAAK+B,gBAAgBV,gBACNhB,QAAQyC,eAEhCP,UAAUQ,QAAQ,GAAGpD,aAAamD,gBAAkB,IAMjDA,cAAgBrD,eAISuD,KAAKF,cACrCP,UAAUrB,KAAK,GAAGvB,aAAamD,eACxB9C,KAAKsC,cAAcQ,YAAanD,UAAW4C,cAItD,aADMU,QAAQC,IAAIL,cACX7C,KAAKwC,qBAAqBzC,WAAWoD,QAAQ9B,eACxD,CASA,gCAAOF,GACH,IAAKnB,KAAKI,mBAAmBP,OACzB,OAGJ,GAAIG,KAAKoD,mBACL,OAGJpD,KAAKoD,oBAAqB,EAE1B,MAAMC,gBAAkBrD,KAAKI,mBAAmBkD,QAE1CC,uBAAyBvC,QAAAA,QAAEC,WAC3BuC,SAAW,GAEXC,iBAAmBJ,gBAAgBL,KAAKU,eAC1C,MAAM/C,WAAY,EAAAC,OAAAA,wBAAuB8C,aAAa/C,WAChDG,KAAO4C,aAAa5C,KACpBf,UAAY2D,aAAa3D,UACzBP,MAAQkE,aAAalE,MACrBmE,iBAAmBD,aAAanD,SACtC,IAAIC,QAAU,KAId,GAAIR,KAAKwB,mBAAmBzB,WAExBS,QAAUR,KAAKE,4BAA4BH,eACxC,CAGHyD,SAAStC,KAAK,CACV0C,WAAY,8CACZC,KAAM,CACFlD,oBACAmD,SAAUhD,KACViD,UAAWvE,MACXwE,KAAMhF,OAAOiF,YAKrB,MAAMC,MAAQV,SAAS3D,OAAS,EAIhCW,QAAU+C,uBAAuB/C,UAC5B2D,MAAMC,WAMHX,iBAAiB1D,WAAaqE,SAASF,OAAOC,MAAME,WAGhDA,SAASC,UAAU3C,SAAS4C,OACxBA,KAAK5D,WAAY,EAAAC,+BAAuB2D,KAAK5D,WAC7C,MAAM6D,cAAgBxE,KAAKT,aACvBC,MACA,CAAC+E,KAAK5D,UAAW4D,KAAKzD,MAAMC,KAAK,MAKrCf,KAAKoB,mBAAmBoD,cAAeD,KAAKE,OAExCzF,OAAO0F,YAAc,GAErBC,cAAAA,QAAQhG,IAAI,iBAAiBK,OAAO0F,eAAeF,gBAAiBD,KAAKE,MAC7E,IAGAJ,SAASO,QAAQ/E,QAGjBd,IAAI8F,cAAcR,SAASO,QAAQ5B,KAAI8B,OAAA,IAACnE,UAACA,UAASG,KAAEA,KAAI2D,MAAEA,OAAMK,KAAA,MAAM,CAClEnE,WAAW,EAAAC,OAAsBA,wBAACD,WAClCoE,IAAKjE,KACL2D,YACH,KAIDzE,KAAKwB,mBAAmBzB,WACjBC,KAAKuB,qBAAqBxB,WAG9B,QAGJ0D,iBAAiB1D,aAEpC,CAEA,OAAOS,QAGF2D,MAAMa,QAAWrB,iBAAiBR,QAAQ6B,UAC1CtC,OAAOC,QAKJ,MAFAgB,iBAAiBf,OAAOD,OAElBA,KAAK,GACb,IAGNa,SAAS3D,OAET0D,uBAAuBJ,QAAQ8B,MAAAA,QAAKxG,KAAK+E,UAAU,GAAM,GAAO,EAAO,EAAGxE,OAAO0F,cAGjFnB,uBAAuBJ,UAM3BnC,QAAAA,QAAEkE,KAAKC,MAAM,KAAM1B,kBACdU,MAAK,KAEFnE,KAAKI,mBAAmBgF,OAAO,EAAG/B,gBAAgBxD,QAClDG,KAAKoD,oBAAqB,EAC1BpD,KAAKmB,2BACL,IAEHuB,OAAM,KAEH1C,KAAKI,mBAAmBgF,OAAO,EAAG/B,gBAAgBxD,QAClDG,KAAKoD,oBAAqB,EAC1BpD,KAAKmB,2BAA2B,GAE5C,CAYA,kCAAOjB,CAA4BH,WAE/B,GAAIA,aAAaC,KAAKyD,iBAClB,OAAOzD,KAAKyD,iBAAiB1D,WAIjC,GAAIC,KAAKwB,mBAAmBzB,WAAY,CACpC,MAAMsB,eAAiBrB,KAAKuB,qBAAqBxB,WAGjD,OADAC,KAAKyD,iBAAiB1D,WAAaiB,gBAAEC,WAAWkC,QAAQ9B,gBAAgBb,UACjER,KAAKyD,iBAAiB1D,UACjC,CAEA,GAAIf,OAAO0F,aAAe,EAEtB,OAAO,KAIX,MAAMW,OAASV,cAAO7G,QAACE,IAAI,iBAAiBgB,OAAO0F,eAAe3E,aAClE,OAAIsF,QAEArF,KAAKoB,mBAAmBrB,UAAWsF,QAGnCrF,KAAKyD,iBAAiB1D,WAAaiB,gBAAEC,WAAWkC,QAAQkC,QAAQ7E,UACzDR,KAAKyD,iBAAiB1D,YAG1B,IACX,EACH,OAAAuF,SAAAxH,QAAAqB,OAAAmG,SAAAxH,OAAA"}