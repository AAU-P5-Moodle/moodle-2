{"version":3,"file":"statemanager.min.js","sources":["../../../src/local/reactive/statemanager.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Reactive simple state manager.\r\n *\r\n * The state manager contains the state data, trigger update events and\r\n * can lock and unlock the state data.\r\n *\r\n * This file contains the three main elements of the state manager:\r\n * - State manager: the public class to alter the state, dispatch events and process update messages.\r\n * - Proxy handler: a private class to keep track of the state object changes.\r\n * - StateMap class: a private class extending Map class that triggers event when a state list is modifed.\r\n *\r\n * @module     core/local/reactive/statemanager\r\n * @class      StateManager\r\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport Logger from 'core/local/reactive/logger';\r\n\r\n/**\r\n * State manager class.\r\n *\r\n * This class handle the reactive state and ensure only valid mutations can modify the state.\r\n * It also provide methods to apply batch state update messages (see processUpdates function doc\r\n * for more details on update messages).\r\n *\r\n * Implementing a deep state manager is complex and will require many frontend resources. To keep\r\n * the state fast and simple, the state can ONLY store two kind of data:\r\n *  - Object with attributes\r\n *  - Sets of objects with id attributes.\r\n *\r\n * This is an example of a valid state:\r\n *\r\n * {\r\n *  course: {\r\n *      name: 'course name',\r\n *      shortname: 'courseshort',\r\n *      sectionlist: [21, 34]\r\n *  },\r\n *  sections: [\r\n *      {id: 21, name: 'Topic 1', visible: true},\r\n *      {id: 34, name: 'Topic 2', visible: false,\r\n *  ],\r\n * }\r\n *\r\n * The following cases are NOT allowed at a state ROOT level (throws an exception if they are assigned):\r\n *  - Simple values (strings, boolean...).\r\n *  - Arrays of simple values.\r\n *  - Array of objects without ID attribute (all arrays will be converted to maps and requires an ID).\r\n *\r\n * Thanks to those limitations it can simplify the state update messages and the event names. If You\r\n * need to store simple data, just group them in an object.\r\n *\r\n * To grant any state change triggers the proper events, the class uses two private structures:\r\n * - proxy handler: any object stored in the state is proxied using this class.\r\n * - StateMap class: any object set in the state will be converted to StateMap using the\r\n *   objects id attribute.\r\n */\r\nexport default class StateManager {\r\n\r\n    /**\r\n     * Create a basic reactive state store.\r\n     *\r\n     * The state manager is meant to work with native JS events. To ensure each reactive module can use\r\n     * it in its own way, the parent element must provide a valid event dispatcher function and an optional\r\n     * DOM element to anchor the event.\r\n     *\r\n     * @param {function} dispatchEvent the function to dispatch the custom event when the state changes.\r\n     * @param {element} target the state changed custom event target (document if none provided)\r\n     */\r\n    constructor(dispatchEvent, target) {\r\n\r\n        // The dispatch event function.\r\n        /** @package */\r\n        this.dispatchEvent = dispatchEvent;\r\n\r\n        // The DOM container to trigger events.\r\n        /** @package */\r\n        this.target = target ?? document;\r\n\r\n        // State can be altered freely until initial state is set.\r\n        /** @package */\r\n        this.readonly = false;\r\n\r\n        // List of state changes pending to be published as events.\r\n        /** @package */\r\n        this.eventsToPublish = [];\r\n\r\n        // The update state types functions.\r\n        /** @package */\r\n        this.updateTypes = {\r\n            \"create\": this.defaultCreate.bind(this),\r\n            \"update\": this.defaultUpdate.bind(this),\r\n            \"delete\": this.defaultDelete.bind(this),\r\n            \"put\": this.defaultPut.bind(this),\r\n            \"override\": this.defaultOverride.bind(this),\r\n            \"remove\": this.defaultRemove.bind(this),\r\n            \"prepareFields\": this.defaultPrepareFields.bind(this),\r\n        };\r\n\r\n        // The state_loaded event is special because it only happens one but all components\r\n        // may react to that state, even if they are registered after the setIinitialState.\r\n        // For these reason we use a promise for that event.\r\n        this.initialPromise = new Promise((resolve) => {\r\n            const initialStateDone = (event) => {\r\n                resolve(event.detail.state);\r\n            };\r\n            this.target.addEventListener('state:loaded', initialStateDone);\r\n        });\r\n\r\n        this.logger = new Logger();\r\n    }\r\n\r\n    /**\r\n     * Loads the initial state.\r\n     *\r\n     * Note this method will trigger a state changed event with \"state:loaded\" actionname.\r\n     *\r\n     * The state mode will be set to read only when the initial state is loaded.\r\n     *\r\n     * @param {object} initialState\r\n     */\r\n    setInitialState(initialState) {\r\n\r\n        if (this.state !== undefined) {\r\n            throw Error('Initial state can only be initialized ones');\r\n        }\r\n\r\n        // Create the state object.\r\n        const state = new Proxy({}, new Handler('state', this, true));\r\n        for (const [prop, propValue] of Object.entries(initialState)) {\r\n            state[prop] = propValue;\r\n        }\r\n        this.state = state;\r\n\r\n        // When the state is loaded we can lock it to prevent illegal changes.\r\n        this.readonly = true;\r\n\r\n        this.dispatchEvent({\r\n            action: 'state:loaded',\r\n            state: this.state,\r\n        }, this.target);\r\n    }\r\n\r\n    /**\r\n     * Generate a promise that will be resolved when the initial state is loaded.\r\n     *\r\n     * In most cases the final state will be loaded using an ajax call. This is the reason\r\n     * why states manager are created unlocked and won't be reactive until the initial state is set.\r\n     *\r\n     * @return {Promise} the resulting promise\r\n     */\r\n    getInitialPromise() {\r\n        return this.initialPromise;\r\n    }\r\n\r\n    /**\r\n     * Locks or unlocks the state to prevent illegal updates.\r\n     *\r\n     * Mutations use this method to modify the state. Once the state is updated, they must\r\n     * block again the state.\r\n     *\r\n     * All changes done while the state is writable will be registered using registerStateAction.\r\n     * When the state is set again to read only the method will trigger _publishEvents to communicate\r\n     * changes to all watchers.\r\n     *\r\n     * @param {bool} readonly if the state is in read only mode enabled\r\n     */\r\n    setReadOnly(readonly) {\r\n\r\n        this.readonly = readonly;\r\n\r\n        let mode = 'off';\r\n\r\n        // When the state is in readonly again is time to publish all pending events.\r\n        if (this.readonly) {\r\n            mode = 'on';\r\n            this._publishEvents();\r\n        }\r\n\r\n        // Dispatch a read only event.\r\n        this.dispatchEvent({\r\n            action: `readmode:${mode}`,\r\n            state: this.state,\r\n            element: null,\r\n        }, this.target);\r\n    }\r\n\r\n    /**\r\n     * Add methods to process update state messages.\r\n     *\r\n     * The state manager provide a default update, create and delete methods. However,\r\n     * some applications may require to override the default methods or even add new ones\r\n     * like \"refresh\" or \"error\".\r\n     *\r\n     * @param {Object} newFunctions the new update types functions.\r\n     */\r\n    addUpdateTypes(newFunctions) {\r\n        for (const [updateType, updateFunction] of Object.entries(newFunctions)) {\r\n            if (typeof updateFunction === 'function') {\r\n                this.updateTypes[updateType] = updateFunction.bind(newFunctions);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process a state updates array and do all the necessary changes.\r\n     *\r\n     * Note this method unlocks the state while it is executing and relocks it\r\n     * when finishes.\r\n     *\r\n     * @param {array} updates\r\n     * @param {Object} updateTypes optional functions to override the default update types.\r\n     */\r\n    processUpdates(updates, updateTypes) {\r\n        if (!Array.isArray(updates)) {\r\n            throw Error('State updates must be an array');\r\n        }\r\n        this.setReadOnly(false);\r\n        updates.forEach((update) => {\r\n            if (update.name === undefined) {\r\n                throw Error('Missing state update name');\r\n            }\r\n            this.processUpdate(\r\n                update.name,\r\n                update.action,\r\n                update.fields,\r\n                updateTypes\r\n            );\r\n        });\r\n        this.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Process a single state update.\r\n     *\r\n     * Note this method will not lock or unlock the state by itself.\r\n     *\r\n     * @param {string} updateName the state element to update\r\n     * @param {string} action to action to perform\r\n     * @param {object} fields the new data\r\n     * @param {Object} updateTypes optional functions to override the default update types.\r\n     */\r\n    processUpdate(updateName, action, fields, updateTypes) {\r\n\r\n        if (!fields) {\r\n            throw Error('Missing state update fields');\r\n        }\r\n\r\n        if (updateTypes === undefined) {\r\n            updateTypes = {};\r\n        }\r\n\r\n        action = action ?? 'update';\r\n\r\n        const method = updateTypes[action] ?? this.updateTypes[action];\r\n\r\n        if (method === undefined) {\r\n            throw Error(`Unkown update action ${action}`);\r\n        }\r\n\r\n        // Some state data may require some cooking before sending to the\r\n        // state. Reactive instances can overrdide the default fieldDefaults\r\n        // method to add extra logic to all updates.\r\n        const prepareFields = updateTypes.prepareFields ?? this.updateTypes.prepareFields;\r\n\r\n        method(this, updateName, prepareFields(this, updateName, fields));\r\n    }\r\n\r\n    /**\r\n     * Prepare fields for processing.\r\n     *\r\n     * This method is used to add default values or calculations from the frontend side.\r\n     *\r\n     * @param {Object} stateManager the state manager\r\n     * @param {String} updateName the state element to update\r\n     * @param {Object} fields the new data\r\n     * @returns {Object} final fields data\r\n     */\r\n    defaultPrepareFields(stateManager, updateName, fields) {\r\n        return fields;\r\n    }\r\n\r\n\r\n    /**\r\n     * Process a create state message.\r\n     *\r\n     * @param {Object} stateManager the state manager\r\n     * @param {String} updateName the state element to update\r\n     * @param {Object} fields the new data\r\n     */\r\n    defaultCreate(stateManager, updateName, fields) {\r\n\r\n        let state = stateManager.state;\r\n\r\n        // Create can be applied only to lists, not to objects.\r\n        if (state[updateName] instanceof StateMap) {\r\n            state[updateName].add(fields);\r\n            return;\r\n        }\r\n        state[updateName] = fields;\r\n    }\r\n\r\n    /**\r\n     * Process a delete state message.\r\n     *\r\n     * @param {Object} stateManager the state manager\r\n     * @param {String} updateName the state element to update\r\n     * @param {Object} fields the new data\r\n     */\r\n    defaultDelete(stateManager, updateName, fields) {\r\n\r\n        // Get the current value.\r\n        let current = stateManager.get(updateName, fields.id);\r\n        if (!current) {\r\n            throw Error(`Inexistent ${updateName} ${fields.id}`);\r\n        }\r\n\r\n        // Process deletion.\r\n        let state = stateManager.state;\r\n\r\n        if (state[updateName] instanceof StateMap) {\r\n            state[updateName].delete(fields.id);\r\n            return;\r\n        }\r\n        delete state[updateName];\r\n    }\r\n\r\n    /**\r\n     * Process a remove state message.\r\n     *\r\n     * @param {Object} stateManager the state manager\r\n     * @param {String} updateName the state element to update\r\n     * @param {Object} fields the new data\r\n     */\r\n    defaultRemove(stateManager, updateName, fields) {\r\n\r\n        // Get the current value.\r\n        let current = stateManager.get(updateName, fields.id);\r\n        if (!current) {\r\n            return;\r\n        }\r\n\r\n        // Process deletion.\r\n        let state = stateManager.state;\r\n\r\n        if (state[updateName] instanceof StateMap) {\r\n            state[updateName].delete(fields.id);\r\n            return;\r\n        }\r\n        delete state[updateName];\r\n    }\r\n\r\n    /**\r\n     * Process a update state message.\r\n     *\r\n     * @param {Object} stateManager the state manager\r\n     * @param {String} updateName the state element to update\r\n     * @param {Object} fields the new data\r\n     */\r\n    defaultUpdate(stateManager, updateName, fields) {\r\n\r\n        // Get the current value.\r\n        let current = stateManager.get(updateName, fields.id);\r\n        if (!current) {\r\n            throw Error(`Inexistent ${updateName} ${fields.id}`);\r\n        }\r\n\r\n        // Execute updates.\r\n        for (const [fieldName, fieldValue] of Object.entries(fields)) {\r\n            current[fieldName] = fieldValue;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process a put state message.\r\n     *\r\n     * @param {Object} stateManager the state manager\r\n     * @param {String} updateName the state element to update\r\n     * @param {Object} fields the new data\r\n     */\r\n    defaultPut(stateManager, updateName, fields) {\r\n\r\n        // Get the current value.\r\n        let current = stateManager.get(updateName, fields.id);\r\n        if (current) {\r\n            // Update attributes.\r\n            for (const [fieldName, fieldValue] of Object.entries(fields)) {\r\n                current[fieldName] = fieldValue;\r\n            }\r\n        } else {\r\n            // Create new object.\r\n            let state = stateManager.state;\r\n            if (state[updateName] instanceof StateMap) {\r\n                state[updateName].add(fields);\r\n                return;\r\n            }\r\n            state[updateName] = fields;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Process an override state message.\r\n     *\r\n     * @param {Object} stateManager the state manager\r\n     * @param {String} updateName the state element to update\r\n     * @param {Object} fields the new data\r\n     */\r\n    defaultOverride(stateManager, updateName, fields) {\r\n\r\n        // Get the current value.\r\n        let current = stateManager.get(updateName, fields.id);\r\n        if (current) {\r\n            // Remove any unnecessary fields.\r\n            for (const [fieldName] of Object.entries(current)) {\r\n                if (fields[fieldName] === undefined) {\r\n                    delete current[fieldName];\r\n                }\r\n            }\r\n            // Update field.\r\n            for (const [fieldName, fieldValue] of Object.entries(fields)) {\r\n                current[fieldName] = fieldValue;\r\n            }\r\n        } else {\r\n            // Create the element if not exists.\r\n            let state = stateManager.state;\r\n            if (state[updateName] instanceof StateMap) {\r\n                state[updateName].add(fields);\r\n                return;\r\n            }\r\n            state[updateName] = fields;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set the logger class instance.\r\n     *\r\n     * Reactive instances can provide alternative loggers to provide advanced logging.\r\n     * @param {Logger} logger\r\n     */\r\n    setLogger(logger) {\r\n        this.logger = logger;\r\n    }\r\n\r\n    /**\r\n     * Add a new log entry into the reactive logger.\r\n     * @param {LoggerEntry} entry\r\n     */\r\n    addLoggerEntry(entry) {\r\n        this.logger.add(entry);\r\n    }\r\n\r\n    /**\r\n     * Get an element from the state or form an alternative state object.\r\n     *\r\n     * The altstate param is used by external update functions that gets the current\r\n     * state as param.\r\n     *\r\n     * @param {String} name the state object name\r\n     * @param {*} id and object id for state maps.\r\n     * @return {Object|undefined} the state object found\r\n     */\r\n    get(name, id) {\r\n        const state = this.state;\r\n\r\n        let current = state[name];\r\n        if (current instanceof StateMap) {\r\n            if (id === undefined) {\r\n                throw Error(`Missing id for ${name} state update`);\r\n            }\r\n            current = state[name].get(id);\r\n        }\r\n\r\n        return current;\r\n    }\r\n\r\n    /**\r\n     * Get all element ids from the given state.\r\n     *\r\n     * @param {String} name the state object name\r\n     * @return {Array} the element ids.\r\n     */\r\n    getIds(name) {\r\n        const state = this.state;\r\n        const current = state[name];\r\n        if (!(current instanceof StateMap)) {\r\n            throw Error(`${name} is not an instance of StateMap`);\r\n        }\r\n        return [...state[name].keys()];\r\n    }\r\n\r\n    /**\r\n     * Register a state modification and generate the necessary events.\r\n     *\r\n     * This method is used mainly by proxy helpers to dispatch state change event.\r\n     * However, mutations can use it to inform components about non reactive changes\r\n     * in the state (only the two first levels of the state are reactive).\r\n     *\r\n     * Each action can produce several events:\r\n     * - The specific attribute updated, created or deleter (example: \"cm.visible:updated\")\r\n     * - The general state object updated, created or deleted (example: \"cm:updated\")\r\n     * - If the element has an ID attribute, the specific event with id (example: \"cm[42].visible:updated\")\r\n     * - If the element has an ID attribute, the general event with id (example: \"cm[42]:updated\")\r\n     * - A generic state update event \"state:update\"\r\n     *\r\n     * @param {string} field the affected state field name\r\n     * @param {string|null} prop the affecter field property (null if affect the full object)\r\n     * @param {string} action the action done (created/updated/deleted)\r\n     * @param {*} data the affected data\r\n     */\r\n    registerStateAction(field, prop, action, data) {\r\n\r\n        let parentAction = 'updated';\r\n\r\n        if (prop !== null) {\r\n            this.eventsToPublish.push({\r\n                eventName: `${field}.${prop}:${action}`,\r\n                eventData: data,\r\n                action,\r\n            });\r\n        } else {\r\n            parentAction = action;\r\n        }\r\n\r\n        // Trigger extra events if the element has an ID attribute.\r\n        if (data.id !== undefined) {\r\n            if (prop !== null) {\r\n                this.eventsToPublish.push({\r\n                    eventName: `${field}[${data.id}].${prop}:${action}`,\r\n                    eventData: data,\r\n                    action,\r\n                });\r\n            }\r\n            this.eventsToPublish.push({\r\n                eventName: `${field}[${data.id}]:${parentAction}`,\r\n                eventData: data,\r\n                action: parentAction,\r\n            });\r\n        }\r\n\r\n        // Register the general change.\r\n        this.eventsToPublish.push({\r\n            eventName: `${field}:${parentAction}`,\r\n            eventData: data,\r\n            action: parentAction,\r\n        });\r\n\r\n        // Register state updated event.\r\n        this.eventsToPublish.push({\r\n            eventName: `state:updated`,\r\n            eventData: data,\r\n            action: 'updated',\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Internal method to publish events.\r\n     *\r\n     * This is a private method, it will be invoked when the state is set back to read only mode.\r\n     */\r\n    _publishEvents() {\r\n        const fieldChanges = this.eventsToPublish;\r\n        this.eventsToPublish = [];\r\n\r\n        // Dispatch a transaction start event.\r\n        this.dispatchEvent({\r\n            action: 'transaction:start',\r\n            state: this.state,\r\n            element: null,\r\n            changes: fieldChanges,\r\n        }, this.target);\r\n\r\n        // State changes can be registered in any order. However it will avoid many\r\n        // components errors if they are sorted to have creations-updates-deletes in case\r\n        // some component needs to create or destroy DOM elements before updating them.\r\n        fieldChanges.sort((a, b) => {\r\n            const weights = {\r\n                created: 0,\r\n                updated: 1,\r\n                deleted: 2,\r\n            };\r\n            const aweight = weights[a.action] ?? 0;\r\n            const bweight = weights[b.action] ?? 0;\r\n            // In case both have the same weight, the eventName length decide.\r\n            if (aweight === bweight) {\r\n                return a.eventName.length - b.eventName.length;\r\n            }\r\n            return aweight - bweight;\r\n        });\r\n\r\n        // List of the published events to prevent redundancies.\r\n        let publishedEvents = new Set();\r\n\r\n        fieldChanges.forEach((event) => {\r\n\r\n            const eventkey = `${event.eventName}.${event.eventData.id ?? 0}`;\r\n\r\n            if (!publishedEvents.has(eventkey)) {\r\n                this.dispatchEvent({\r\n                    action: event.eventName,\r\n                    state: this.state,\r\n                    element: event.eventData\r\n                }, this.target);\r\n\r\n                publishedEvents.add(eventkey);\r\n            }\r\n        });\r\n\r\n        // Dispatch a transaction end event.\r\n        this.dispatchEvent({\r\n            action: 'transaction:end',\r\n            state: this.state,\r\n            element: null,\r\n        }, this.target);\r\n    }\r\n}\r\n\r\n// Proxy helpers.\r\n\r\n/**\r\n * The proxy handler.\r\n *\r\n * This class will inform any value change directly to the state manager.\r\n *\r\n * The proxied variable will throw an error if it is altered when the state manager is\r\n * in read only mode.\r\n */\r\nclass Handler {\r\n\r\n    /**\r\n     * Class constructor.\r\n     *\r\n     * @param {string} name the variable name used for identify triggered actions\r\n     * @param {StateManager} stateManager the state manager object\r\n     * @param {boolean} proxyValues if new values must be proxied (used only at state root level)\r\n     */\r\n    constructor(name, stateManager, proxyValues) {\r\n        this.name = name;\r\n        this.stateManager = stateManager;\r\n        this.proxyValues = proxyValues ?? false;\r\n    }\r\n\r\n    /**\r\n     * Set trap to trigger events when the state changes.\r\n     *\r\n     * @param {object} obj the source object (not proxied)\r\n     * @param {string} prop the attribute to set\r\n     * @param {*} value the value to save\r\n     * @param {*} receiver the proxied element to be attached to events\r\n     * @returns {boolean} if the value is set\r\n     */\r\n    set(obj, prop, value, receiver) {\r\n\r\n        // Only mutations should be able to set state values.\r\n        if (this.stateManager.readonly) {\r\n            throw new Error(`State locked. Use mutations to change ${prop} value in ${this.name}.`);\r\n        }\r\n\r\n        // Check any data change.\r\n        if (JSON.stringify(obj[prop]) === JSON.stringify(value)) {\r\n            return true;\r\n        }\r\n\r\n        const action = (obj[prop] !== undefined) ? 'updated' : 'created';\r\n\r\n        // Proxy value if necessary (used at state root level).\r\n        if (this.proxyValues) {\r\n            if (Array.isArray(value)) {\r\n                obj[prop] = new StateMap(prop, this.stateManager).loadValues(value);\r\n            } else {\r\n                obj[prop] = new Proxy(value, new Handler(prop, this.stateManager));\r\n            }\r\n        } else {\r\n            obj[prop] = value;\r\n        }\r\n\r\n        // If the state is not ready yet means the initial state is not yet loaded.\r\n        if (this.stateManager.state === undefined) {\r\n            return true;\r\n        }\r\n\r\n        this.stateManager.registerStateAction(this.name, prop, action, receiver);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Delete property trap to trigger state change events.\r\n     *\r\n     * @param {*} obj the affected object (not proxied)\r\n     * @param {*} prop the prop to delete\r\n     * @returns {boolean} if prop is deleted\r\n     */\r\n    deleteProperty(obj, prop) {\r\n        // Only mutations should be able to set state values.\r\n        if (this.stateManager.readonly) {\r\n            throw new Error(`State locked. Use mutations to delete ${prop} in ${this.name}.`);\r\n        }\r\n        if (prop in obj) {\r\n\r\n            delete obj[prop];\r\n\r\n            this.stateManager.registerStateAction(this.name, prop, 'deleted', obj);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * Class to add events dispatching to the JS Map class.\r\n *\r\n * When the state has a list of objects (with IDs) it will be converted into a StateMap.\r\n * StateMap is used almost in the same way as a regular JS map. Because all elements have an\r\n * id attribute, it has some specific methods:\r\n *  - add: a convenient method to add an element without specifying the key (\"id\" attribute will be used as a key).\r\n *  - loadValues: to add many elements at once wihout specifying keys (\"id\" attribute will be used).\r\n *\r\n * Apart, the main difference between regular Map and MapState is that this one will inform any change to the\r\n * state manager.\r\n */\r\nclass StateMap extends Map {\r\n\r\n    /**\r\n     * Create a reactive Map.\r\n     *\r\n     * @param {string} name the property name\r\n     * @param {StateManager} stateManager the state manager\r\n     * @param {iterable} iterable an iterable object to create the Map\r\n     */\r\n    constructor(name, stateManager, iterable) {\r\n        // We don't have any \"this\" until be call super.\r\n        super(iterable);\r\n        this.name = name;\r\n        this.stateManager = stateManager;\r\n    }\r\n\r\n    /**\r\n     * Set an element into the map.\r\n     *\r\n     * Each value needs it's own id attribute. Objects without id will be rejected.\r\n     * The function will throw an error if the value id and the key are not the same.\r\n     *\r\n     * @param {*} key the key to store\r\n     * @param {*} value the value to store\r\n     * @returns {Map} the resulting Map object\r\n     */\r\n    set(key, value) {\r\n\r\n        // Only mutations should be able to set state values.\r\n        if (this.stateManager.readonly) {\r\n            throw new Error(`State locked. Use mutations to change ${key} value in ${this.name}.`);\r\n        }\r\n\r\n        // Normalize keys as string to prevent json decoding errors.\r\n        key = this.normalizeKey(key);\r\n\r\n        this.checkValue(value);\r\n\r\n        if (key === undefined || key === null) {\r\n            throw Error('State lists keys cannot be null or undefined');\r\n        }\r\n\r\n        // ID is mandatory and should be the same as the key.\r\n        if (this.normalizeKey(value.id) !== key) {\r\n            throw new Error(`State error: ${this.name} list element ID (${value.id}) and key (${key}) mismatch`);\r\n        }\r\n\r\n        const action = (super.has(key)) ? 'updated' : 'created';\r\n\r\n        // Save proxied data into the list.\r\n        const result = super.set(key, new Proxy(value, new Handler(this.name, this.stateManager)));\r\n\r\n        // If the state is not ready yet means the initial state is not yet loaded.\r\n        if (this.stateManager.state === undefined) {\r\n            return result;\r\n        }\r\n\r\n        this.stateManager.registerStateAction(this.name, null, action, super.get(key));\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Check if a value is valid to be stored in a a State List.\r\n     *\r\n     * Only objects with id attribute can be stored in State lists.\r\n     *\r\n     * This method throws an error if the value is not valid.\r\n     *\r\n     * @param {object} value (with ID)\r\n     */\r\n    checkValue(value) {\r\n        if (!typeof value === 'object' && value !== null) {\r\n            throw Error('State lists can contain objects only');\r\n        }\r\n\r\n        if (value.id === undefined) {\r\n            throw Error('State lists elements must contain at least an id attribute');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return a normalized key value for state map.\r\n     *\r\n     * Regular maps uses strict key comparissons but state maps are indexed by ID.JSON conversions\r\n     * and webservices sometimes do unexpected types conversions so we convert any integer key to string.\r\n     *\r\n     * @param {*} key the provided key\r\n     * @returns {string}\r\n     */\r\n    normalizeKey(key) {\r\n        return String(key).valueOf();\r\n    }\r\n\r\n    /**\r\n     * Insert a new element int a list.\r\n     *\r\n     * Each value needs it's own id attribute. Objects withouts id will be rejected.\r\n     *\r\n     * @param {object} value the value to add (needs an id attribute)\r\n     * @returns {Map} the resulting Map object\r\n     */\r\n    add(value) {\r\n        this.checkValue(value);\r\n        return this.set(value.id, value);\r\n    }\r\n\r\n    /**\r\n     * Return a state map element.\r\n     *\r\n     * @param {*} key the element id\r\n     * @return {Object}\r\n     */\r\n    get(key) {\r\n        return super.get(this.normalizeKey(key));\r\n    }\r\n\r\n    /**\r\n     * Check whether an element with the specified key exists or not.\r\n     *\r\n     * @param {*} key the key to find\r\n     * @return {boolean}\r\n     */\r\n    has(key) {\r\n        return super.has(this.normalizeKey(key));\r\n    }\r\n\r\n    /**\r\n     * Delete an element from the map.\r\n     *\r\n     * @param {*} key\r\n     * @returns {boolean}\r\n     */\r\n    delete(key) {\r\n        // State maps uses only string keys to avoid strict comparisons.\r\n        key = this.normalizeKey(key);\r\n\r\n        // Only mutations should be able to set state values.\r\n        if (this.stateManager.readonly) {\r\n            throw new Error(`State locked. Use mutations to change ${key} value in ${this.name}.`);\r\n        }\r\n\r\n        const previous = super.get(key);\r\n\r\n        const result = super.delete(key);\r\n        if (!result) {\r\n            return result;\r\n        }\r\n\r\n        this.stateManager.registerStateAction(this.name, null, 'deleted', previous);\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Return a suitable structure for JSON conversion.\r\n     *\r\n     * This function is needed because new values are compared in JSON. StateMap has Private\r\n     * attributes which cannot be stringified (like this.stateManager which will produce an\r\n     * infinite recursivity).\r\n     *\r\n     * @returns {array}\r\n     */\r\n    toJSON() {\r\n        let result = [];\r\n        this.forEach((value) => {\r\n            result.push(value);\r\n        });\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Insert a full list of values using the id attributes as keys.\r\n     *\r\n     * This method is used mainly to initialize the list. Note each element is indexed by its \"id\" attribute.\r\n     * This is a basic restriction of StateMap. All elements need an id attribute, otherwise it won't be saved.\r\n     *\r\n     * @param {iterable} values the values to load\r\n     * @returns {StateMap} return the this value\r\n     */\r\n    loadValues(values) {\r\n        values.forEach((data) => {\r\n            this.checkValue(data);\r\n            let key = data.id;\r\n            let newvalue = new Proxy(data, new Handler(this.name, this.stateManager));\r\n            this.set(key, newvalue);\r\n        });\r\n        return this;\r\n    }\r\n}\r\n"],"names":["e","_logger","__esModule","default","_exports","constructor","dispatchEvent","target","this","document","readonly","eventsToPublish","updateTypes","create","defaultCreate","bind","update","defaultUpdate","delete","defaultDelete","put","defaultPut","override","defaultOverride","remove","defaultRemove","prepareFields","defaultPrepareFields","initialPromise","Promise","resolve","addEventListener","event","detail","state","logger","Logger","setInitialState","initialState","undefined","Error","Proxy","Handler","prop","propValue","Object","entries","action","getInitialPromise","setReadOnly","mode","_publishEvents","element","addUpdateTypes","newFunctions","updateType","updateFunction","processUpdates","updates","Array","isArray","forEach","name","processUpdate","fields","updateName","method","stateManager","StateMap","add","get","id","current","fieldName","fieldValue","setLogger","addLoggerEntry","entry","getIds","keys","registerStateAction","field","data","parentAction","push","eventName","eventData","fieldChanges","changes","sort","a","b","weights","created","updated","deleted","aweight","bweight","length","publishedEvents","Set","eventkey","has","proxyValues","set","obj","value","receiver","JSON","stringify","loadValues","deleteProperty","Map","iterable","super","key","normalizeKey","checkValue","result","String","valueOf","previous","toJSON","values","newvalue"],"mappings":"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"}