{"version":3,"file":"reactive.min.js","sources":["../../../src/local/reactive/reactive.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * A generic single state reactive module.\r\n *\r\n * @module     core/local/reactive/reactive\r\n * @class      core/local/reactive/reactive\r\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\nimport log from 'core/log';\r\nimport StateManager from 'core/local/reactive/statemanager';\r\nimport Pending from 'core/pending';\r\n\r\n// Count the number of pending operations done to ensure we have a unique id for each one.\r\nlet pendingCount = 0;\r\n\r\n/**\r\n * Set up general reactive class to create a single state application with components.\r\n *\r\n * The reactive class is used for registering new UI components and manage the access to the state values\r\n * and mutations.\r\n *\r\n * When a new reactive instance is created, it will contain an empty state and and empty mutations\r\n * lists. When the state data is ready, the initial state can be loaded using the \"setInitialState\"\r\n * method. This will protect the state from writing and will trigger all the components \"stateReady\"\r\n * methods.\r\n *\r\n * State can only be altered by mutations. To replace all the mutations with a specific class,\r\n * use \"setMutations\" method. If you need to just add some new mutation methods, use \"addMutations\".\r\n *\r\n * To register new components into a reactive instance, use \"registerComponent\".\r\n *\r\n * Inside a component, use \"dispatch\" to invoke a mutation on the state (components can only access\r\n * the state in read only mode).\r\n */\r\nexport default class {\r\n\r\n    /**\r\n     * The component descriptor data structure.\r\n     *\r\n     * @typedef {object} description\r\n     * @property {string} eventName the custom event name used for state changed events\r\n     * @property {Function} eventDispatch the state update event dispatch function\r\n     * @property {Element} [target] the target of the event dispatch. If not passed a fake element will be created\r\n     * @property {Object} [mutations] an object with state mutations functions\r\n     * @property {Object} [state] an object to initialize the state.\r\n     */\r\n\r\n    /**\r\n     * Create a basic reactive manager.\r\n     *\r\n     * Note that if your state is not async loaded, you can pass directly on creation by using the\r\n     * description.state attribute. However, this will initialize the state, this means\r\n     * setInitialState will throw an exception because the state is already defined.\r\n     *\r\n     * @param {description} description reactive manager description.\r\n     */\r\n    constructor(description) {\r\n\r\n        if (description.eventName === undefined || description.eventDispatch === undefined) {\r\n            throw new Error(`Reactivity event required`);\r\n        }\r\n\r\n        if (description.name !== undefined) {\r\n            this.name = description.name;\r\n        }\r\n\r\n        // Each reactive instance has its own element anchor to propagate state changes internally.\r\n        // By default the module will create a fake DOM element to target custom events but\r\n        // if all reactive components is constrait to a single element, this can be passed as\r\n        // target in the description.\r\n        this.target = description.target ?? document.createTextNode(null);\r\n\r\n        this.eventName = description.eventName;\r\n        this.eventDispatch = description.eventDispatch;\r\n\r\n        // State manager is responsible for dispatch state change events when a mutation happens.\r\n        this.stateManager = new StateManager(this.eventDispatch, this.target);\r\n\r\n        // An internal registry of watchers and components.\r\n        this.watchers = new Map([]);\r\n        this.components = new Set([]);\r\n\r\n        // Mutations can be overridden later using setMutations method.\r\n        this.mutations = description.mutations ?? {};\r\n\r\n        // Register the event to alert watchers when specific state change happens.\r\n        this.target.addEventListener(this.eventName, this.callWatchersHandler.bind(this));\r\n\r\n        // Add a pending operation waiting for the initial state.\r\n        this.pendingState = new Pending(`core/reactive:registerInstance${pendingCount++}`);\r\n\r\n        // Set initial state if we already have it.\r\n        if (description.state !== undefined) {\r\n            this.setInitialState(description.state);\r\n        }\r\n\r\n        // Check if we have a debug instance to register the instance.\r\n        if (M.reactive !== undefined) {\r\n            M.reactive.registerNewInstance(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * State changed listener.\r\n     *\r\n     * This function take any state change and send it to the proper watchers.\r\n     *\r\n     * To prevent internal state changes from colliding with other reactive instances, only the\r\n     * general \"state changed\" is triggered at document level. All the internal changes are\r\n     * triggered at private target level without bubbling. This way any reactive instance can alert\r\n     * only its own watchers.\r\n     *\r\n     * @param {CustomEvent} event\r\n     */\r\n    callWatchersHandler(event) {\r\n        // Execute any registered component watchers.\r\n        this.target.dispatchEvent(new CustomEvent(event.detail.action, {\r\n            bubbles: false,\r\n            detail: event.detail,\r\n        }));\r\n    }\r\n\r\n    /**\r\n     * Set the initial state.\r\n     *\r\n     * @param {object} stateData the initial state data.\r\n     */\r\n    setInitialState(stateData) {\r\n        this.pendingState.resolve();\r\n        this.stateManager.setInitialState(stateData);\r\n    }\r\n\r\n    /**\r\n     * Add individual functions to the mutations.\r\n     *\r\n     * Note new mutations will be added to the existing ones. To replace the full mutation\r\n     * object with a new one, use setMutations method.\r\n     *\r\n     * @method addMutations\r\n     * @param {Object} newFunctions an object with new mutation functions.\r\n     */\r\n    addMutations(newFunctions) {\r\n        // Mutations can provide an init method to do some setup in the statemanager.\r\n        if (newFunctions.init !== undefined) {\r\n            newFunctions.init(this.stateManager);\r\n        }\r\n        // Save all mutations.\r\n        for (const [mutation, mutationFunction] of Object.entries(newFunctions)) {\r\n            this.mutations[mutation] = mutationFunction.bind(newFunctions);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Replace the current mutations with a new object.\r\n     *\r\n     * This method is designed to override the full mutations class, for example by extending\r\n     * the original one. To add some individual mutations, use addMutations instead.\r\n     *\r\n     * @param {object} manager the new mutations intance\r\n     */\r\n    setMutations(manager) {\r\n        this.mutations = manager;\r\n        // Mutations can provide an init method to do some setup in the statemanager.\r\n        if (manager.init !== undefined) {\r\n            manager.init(this.stateManager);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the current state.\r\n     *\r\n     * @return {object}\r\n     */\r\n    get state() {\r\n        return this.stateManager.state;\r\n    }\r\n\r\n    /**\r\n     * Get state data.\r\n     *\r\n     * Components access the state frequently. This convenience method is a shortcut to\r\n     * this.reactive.state.stateManager.get() method.\r\n     *\r\n     * @param {String} name the state object name\r\n     * @param {*} id an optional object id for state maps.\r\n     * @return {Object|undefined} the state object found\r\n     */\r\n    get(name, id) {\r\n        return this.stateManager.get(name, id);\r\n    }\r\n\r\n    /**\r\n     * Return the initial state promise.\r\n     *\r\n     * Typically, components do not require to use this promise because registerComponent\r\n     * will trigger their stateReady method automatically. But it could be useful for complex\r\n     * components that require to combine state, template and string loadings.\r\n     *\r\n     * @method getState\r\n     * @return {Promise}\r\n     */\r\n    getInitialStatePromise() {\r\n        return this.stateManager.getInitialPromise();\r\n    }\r\n\r\n    /**\r\n     * Register a new component.\r\n     *\r\n     * Component can provide some optional functions to the reactive module:\r\n     * - getWatchers: returns an array of watchers\r\n     * - stateReady: a method to call when the initial state is loaded\r\n     *\r\n     * It can also provide some optional attributes:\r\n     * - name: the component name (default value: \"Unkown component\") to customize debug messages.\r\n     *\r\n     * The method will also use dispatchRegistrationSuccess and dispatchRegistrationFail. Those\r\n     * are BaseComponent methods to inform parent components of the registration status.\r\n     * Components should not override those methods.\r\n     *\r\n     * @method registerComponent\r\n     * @param {object} component the new component\r\n     * @param {string} [component.name] the component name to display in warnings and errors.\r\n     * @param {Function} [component.dispatchRegistrationSuccess] method to notify registration success\r\n     * @param {Function} [component.dispatchRegistrationFail] method to notify registration fail\r\n     * @param {Function} [component.getWatchers] getter of the component watchers\r\n     * @param {Function} [component.stateReady] method to call when the state is ready\r\n     * @return {object} the registered component\r\n     */\r\n    registerComponent(component) {\r\n\r\n        // Component name is an optional attribute to customize debug messages.\r\n        const componentName = component.name ?? 'Unkown component';\r\n\r\n        // Components can provide special methods to communicate registration to parent components.\r\n        let dispatchSuccess = () => {\r\n            return;\r\n        };\r\n        let dispatchFail = dispatchSuccess;\r\n        if (component.dispatchRegistrationSuccess !== undefined) {\r\n            dispatchSuccess = component.dispatchRegistrationSuccess.bind(component);\r\n        }\r\n        if (component.dispatchRegistrationFail !== undefined) {\r\n            dispatchFail = component.dispatchRegistrationFail.bind(component);\r\n        }\r\n\r\n        // Components can be registered only one time.\r\n        if (this.components.has(component)) {\r\n            dispatchSuccess();\r\n            return component;\r\n        }\r\n\r\n        // Components are fully registered only when the state ready promise is resolved.\r\n        const pendingPromise = new Pending(`core/reactive:registerComponent${pendingCount++}`);\r\n\r\n        // Keep track of the event listeners.\r\n        let listeners = [];\r\n\r\n        // Register watchers.\r\n        let handlers = [];\r\n        if (component.getWatchers !== undefined) {\r\n            handlers = component.getWatchers();\r\n        }\r\n        handlers.forEach(({watch, handler}) => {\r\n\r\n            if (watch === undefined) {\r\n                dispatchFail();\r\n                throw new Error(`Missing watch attribute in ${componentName} watcher`);\r\n            }\r\n            if (handler === undefined) {\r\n                dispatchFail();\r\n                throw new Error(`Missing handler for watcher ${watch} in ${componentName}`);\r\n            }\r\n\r\n            const listener = (event) => {\r\n                // Prevent any watcher from losing the page focus.\r\n                const currentFocus = document.activeElement;\r\n                // Execute watcher.\r\n                handler.apply(component, [event.detail]);\r\n                // Restore focus in case it is lost.\r\n                if (document.activeElement === document.body && document.body.contains(currentFocus)) {\r\n                    currentFocus.focus();\r\n                }\r\n            };\r\n\r\n            // Save the listener information in case the component must be unregistered later.\r\n            listeners.push({target: this.target, watch, listener});\r\n\r\n            // The state manager triggers a general \"state changed\" event at a document level. However,\r\n            // for the internal watchers, each component can listen to specific state changed custom events\r\n            // in the target element. This way we can use the native event loop without colliding with other\r\n            // reactive instances.\r\n            this.target.addEventListener(watch, listener);\r\n        });\r\n\r\n        // Register state ready function. There's the possibility a component is registered after the initial state\r\n        // is loaded. For those cases we have a state promise to handle this specific state change.\r\n        if (component.stateReady !== undefined) {\r\n            this.getInitialStatePromise()\r\n                .then(state => {\r\n                    component.stateReady(state);\r\n                    pendingPromise.resolve();\r\n                    return true;\r\n                })\r\n                .catch(reason => {\r\n                    pendingPromise.resolve();\r\n                    log.error(`Initial state in ${componentName} rejected due to: ${reason}`);\r\n                    log.error(reason);\r\n                });\r\n        }\r\n\r\n        // Save unregister data.\r\n        this.watchers.set(component, listeners);\r\n        this.components.add(component);\r\n\r\n        // Dispatch an event to communicate the registration to the debug module.\r\n        this.target.dispatchEvent(new CustomEvent('registerComponent:success', {\r\n            bubbles: false,\r\n            detail: {component},\r\n        }));\r\n\r\n        dispatchSuccess();\r\n        return component;\r\n    }\r\n\r\n    /**\r\n     * Unregister a component and its watchers.\r\n     *\r\n     * @param {object} component the object instance to unregister\r\n     * @returns {object} the deleted component\r\n     */\r\n    unregisterComponent(component) {\r\n        if (!this.components.has(component)) {\r\n            return component;\r\n        }\r\n\r\n        this.components.delete(component);\r\n\r\n        // Remove event listeners.\r\n        const listeners = this.watchers.get(component);\r\n        if (listeners === undefined) {\r\n            return component;\r\n        }\r\n\r\n        listeners.forEach(({target, watch, listener}) => {\r\n            target.removeEventListener(watch, listener);\r\n        });\r\n\r\n        this.watchers.delete(component);\r\n\r\n        return component;\r\n    }\r\n\r\n    /**\r\n     * Dispatch a change in the state.\r\n     *\r\n     * This method is the only way for components to alter the state. Watchers will receive a\r\n     * read only state to prevent illegal changes. If some user action require a state change, the\r\n     * component should dispatch a mutation to trigger all the necessary logic to alter the state.\r\n     *\r\n     * @method dispatch\r\n     * @param {string} actionName the action name (usually the mutation name)\r\n     * @param {mixed} params any number of params the mutation needs.\r\n     */\r\n    async dispatch(actionName, ...params) {\r\n        if (typeof actionName !== 'string') {\r\n            throw new Error(`Dispatch action name must be a string`);\r\n        }\r\n        // JS does not have private methods yet. However, we prevent any component from calling\r\n        // a method starting with \"_\" because the most accepted convention for private methods.\r\n        if (actionName.charAt(0) === '_') {\r\n            throw new Error(`Illegal Private ${actionName} mutation method dispatch`);\r\n        }\r\n        if (this.mutations[actionName] === undefined) {\r\n            throw new Error(`Unkown ${actionName} mutation`);\r\n        }\r\n\r\n        const pendingPromise = new Pending(`core/reactive:${actionName}${pendingCount++}`);\r\n\r\n        const mutationFunction = this.mutations[actionName];\r\n        try {\r\n            await mutationFunction.apply(this.mutations, [this.stateManager, ...params]);\r\n            pendingPromise.resolve();\r\n        } catch (error) {\r\n            // Ensure the state is locked.\r\n            this.stateManager.setReadOnly(true);\r\n            pendingPromise.resolve();\r\n            throw error;\r\n        }\r\n    }\r\n}\r\n"],"names":["_interopRequireDefault","e","__esModule","default","_log","_statemanager","_pending","pendingCount","_exports","constructor","description","undefined","eventName","eventDispatch","Error","name","this","target","document","createTextNode","stateManager","StateManager","watchers","Map","components","Set","mutations","addEventListener","callWatchersHandler","bind","pendingState","Pending","state","setInitialState","M","reactive","registerNewInstance","event","dispatchEvent","CustomEvent","detail","action","bubbles","stateData","resolve","addMutations","newFunctions","init","mutation","mutationFunction","Object","entries","setMutations","manager","get","id","getInitialStatePromise","getInitialPromise","registerComponent","component","componentName","dispatchSuccess","dispatchFail","dispatchRegistrationSuccess","dispatchRegistrationFail","has","pendingPromise","listeners","handlers","getWatchers","forEach","_ref","watch","handler","listener","currentFocus","activeElement","apply","body","contains","focus","push","stateReady","then","catch","reason","log","error","set","add","unregisterComponent","delete","_ref2","removeEventListener","dispatch","actionName","charAt","_len","arguments","length","params","Array","_key","setReadOnly"],"mappings":"+JA0BmC,SAAAA,uBAAAC,GAAAA,OAAAA,GAAAA,EAAAC,WAAAD,EAAAE,CAAAA,QAAAF,EAAA;;;;;;;;qFAFnCG,KAAAJ,uBAAAI,MACAC,cAAAL,uBAAAK,eACAC,SAAAN,uBAAAM,UAGA,IAAIC,aAAe,EAwXlB,OAAAC,SAAAL,QAnWc,MAsBXM,WAAAA,CAAYC,aAER,QAA8BC,IAA1BD,YAAYE,gBAAyDD,IAA9BD,YAAYG,cACnD,MAAM,IAAIC,MAAM,kCAGKH,IAArBD,YAAYK,OACZC,KAAKD,KAAOL,YAAYK,MAO5BC,KAAKC,OAASP,YAAYO,QAAUC,SAASC,eAAe,MAE5DH,KAAKJ,UAAYF,YAAYE,UAC7BI,KAAKH,cAAgBH,YAAYG,cAGjCG,KAAKI,aAAe,IAAIC,cAAYlB,QAACa,KAAKH,cAAeG,KAAKC,QAG9DD,KAAKM,SAAW,IAAIC,IAAI,IACxBP,KAAKQ,WAAa,IAAIC,IAAI,IAG1BT,KAAKU,UAAYhB,YAAYgB,WAAa,CAAA,EAG1CV,KAAKC,OAAOU,iBAAiBX,KAAKJ,UAAWI,KAAKY,oBAAoBC,KAAKb,OAG3EA,KAAKc,aAAe,IAAIC,SAAAA,QAAQ,iCAAiCxB,qBAGvCI,IAAtBD,YAAYsB,OACZhB,KAAKiB,gBAAgBvB,YAAYsB,YAIlBrB,IAAfuB,EAAEC,UACFD,EAAEC,SAASC,oBAAoBpB,KAEvC,CAcAY,mBAAAA,CAAoBS,OAEhBrB,KAAKC,OAAOqB,cAAc,IAAIC,YAAYF,MAAMG,OAAOC,OAAQ,CAC3DC,SAAS,EACTF,OAAQH,MAAMG,SAEtB,CAOAP,eAAAA,CAAgBU,WACZ3B,KAAKc,aAAac,UAClB5B,KAAKI,aAAaa,gBAAgBU,UACtC,CAWAE,YAAAA,CAAaC,mBAEiBnC,IAAtBmC,aAAaC,MACbD,aAAaC,KAAK/B,KAAKI,cAG3B,IAAK,MAAO4B,SAAUC,oBAAqBC,OAAOC,QAAQL,cACtD9B,KAAKU,UAAUsB,UAAYC,iBAAiBpB,KAAKiB,aAEzD,CAUAM,YAAAA,CAAaC,SACTrC,KAAKU,UAAY2B,aAEI1C,IAAjB0C,QAAQN,MACRM,QAAQN,KAAK/B,KAAKI,aAE1B,CAOA,SAAIY,GACA,OAAOhB,KAAKI,aAAaY,KAC7B,CAYAsB,GAAAA,CAAIvC,KAAMwC,IACN,OAAOvC,KAAKI,aAAakC,IAAIvC,KAAMwC,GACvC,CAYAC,sBAAAA,GACI,OAAOxC,KAAKI,aAAaqC,mBAC7B,CAyBAC,iBAAAA,CAAkBC,WAGd,MAAMC,cAAgBD,UAAU5C,MAAQ,mBAGxC,IAAI8C,gBAAkBA,KAClB,EAEAC,aAAeD,gBASnB,QAR8ClD,IAA1CgD,UAAUI,8BACVF,gBAAkBF,UAAUI,4BAA4BlC,KAAK8B,iBAEtBhD,IAAvCgD,UAAUK,2BACVF,aAAeH,UAAUK,yBAAyBnC,KAAK8B,YAIvD3C,KAAKQ,WAAWyC,IAAIN,WAEpB,OADAE,kBACOF,UAIX,MAAMO,eAAiB,IAAInC,SAAAA,QAAQ,kCAAkCxB,gBAGrE,IAAI4D,UAAY,GAGZC,SAAW,GA+Df,YA9D8BzD,IAA1BgD,UAAUU,cACVD,SAAWT,UAAUU,eAEzBD,SAASE,SAAQC,OAAsB,IAArBC,MAACA,MAAKC,QAAEA,SAAQF,KAE9B,QAAc5D,IAAV6D,MAEA,MADAV,eACM,IAAIhD,MAAM,8BAA8B8C,yBAElD,QAAgBjD,IAAZ8D,QAEA,MADAX,eACM,IAAIhD,MAAM,+BAA+B0D,YAAYZ,iBAG/D,MAAMc,SAAYrC,QAEd,MAAMsC,aAAezD,SAAS0D,cAE9BH,QAAQI,MAAMlB,UAAW,CAACtB,MAAMG,SAE5BtB,SAAS0D,gBAAkB1D,SAAS4D,MAAQ5D,SAAS4D,KAAKC,SAASJ,eACnEA,aAAaK,OACjB,EAIJb,UAAUc,KAAK,CAAChE,OAAQD,KAAKC,OAAQuD,YAAOE,oBAM5C1D,KAAKC,OAAOU,iBAAiB6C,MAAOE,SAAS,SAKpB/D,IAAzBgD,UAAUuB,YACVlE,KAAKwC,yBACA2B,MAAKnD,QACF2B,UAAUuB,WAAWlD,OACrBkC,eAAetB,WACR,KAEVwC,OAAMC,SACHnB,eAAetB,UACf0C,KAAGnF,QAACoF,MAAM,oBAAoB3B,kCAAkCyB,UAChEC,KAAAA,QAAIC,MAAMF,OAAO,IAK7BrE,KAAKM,SAASkE,IAAI7B,UAAWQ,WAC7BnD,KAAKQ,WAAWiE,IAAI9B,WAGpB3C,KAAKC,OAAOqB,cAAc,IAAIC,YAAY,4BAA6B,CACnEG,SAAS,EACTF,OAAQ,CAACmB,wBAGbE,kBACOF,SACX,CAQA+B,mBAAAA,CAAoB/B,WAChB,IAAK3C,KAAKQ,WAAWyC,IAAIN,WACrB,OAAOA,UAGX3C,KAAKQ,WAAWmE,OAAOhC,WAGvB,MAAMQ,UAAYnD,KAAKM,SAASgC,IAAIK,WACpC,YAAkBhD,IAAdwD,YAIJA,UAAUG,SAAQsB,QAA+B,IAA9B3E,OAACA,OAAMuD,MAAEA,MAAKE,SAAEA,UAASkB,MACxC3E,OAAO4E,oBAAoBrB,MAAOE,SAAS,IAG/C1D,KAAKM,SAASqE,OAAOhC,YAPVA,SAUf,CAaA,cAAMmC,CAASC,YACX,GAA0B,iBAAfA,WACP,MAAM,IAAIjF,MAAM,yCAIpB,GAA6B,MAAzBiF,WAAWC,OAAO,GAClB,MAAM,IAAIlF,MAAM,mBAAmBiF,uCAEvC,QAAmCpF,IAA/BK,KAAKU,UAAUqE,YACf,MAAM,IAAIjF,MAAM,UAAUiF,uBAG9B,MAAM7B,eAAiB,IAAInC,SAAO5B,QAAC,iBAAiB4F,aAAaxF,kBAE3D0C,iBAAmBjC,KAAKU,UAAUqE,YACxC,IAAI,IAAAE,IAAAA,KAAAC,UAAAC,OAhBsBC,WAAMC,MAAAJ,KAAAA,EAAAA,UAAAK,KAAA,EAAAA,KAAAL,KAAAK,OAANF,OAAME,KAAAJ,GAAAA,UAAAI,YAiBtBrD,iBAAiB4B,MAAM7D,KAAKU,UAAW,CAACV,KAAKI,gBAAiBgF,SACpElC,eAAetB,SAClB,CAAC,MAAO2C,OAIL,MAFAvE,KAAKI,aAAamF,aAAY,GAC9BrC,eAAetB,UACT2C,KACV,CACJ,GACH/E,SAAAL,OAAA"}