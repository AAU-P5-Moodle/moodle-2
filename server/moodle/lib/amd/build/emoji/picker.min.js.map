{"version":3,"file":"picker.min.js","sources":["../../src/emoji/picker.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Emoji picker.\r\n *\r\n * @module core/emoji/picker\r\n * @copyright  2019 Ryan Wyllie <ryan@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nimport LocalStorage from 'core/localstorage';\r\nimport * as EmojiData from 'core/emoji/data';\r\nimport {throttle, debounce} from 'core/utils';\r\nimport {getString} from 'core/str';\r\nimport {render as renderTemplate} from 'core/templates';\r\n\r\nconst VISIBLE_ROW_COUNT = 10;\r\nconst ROW_RENDER_BUFFER_COUNT = 5;\r\nconst RECENT_EMOJIS_STORAGE_KEY = 'moodle-recent-emojis';\r\nconst ROW_HEIGHT_RAW = 40;\r\nconst EMOJIS_PER_ROW = 7;\r\nconst MAX_RECENT_COUNT = EMOJIS_PER_ROW * 3;\r\nconst ROW_TYPE = {\r\n    EMOJI: 0,\r\n    HEADER: 1\r\n};\r\nconst SELECTORS = {\r\n    CATEGORY_SELECTOR: '[data-action=\"show-category\"]',\r\n    EMOJIS_CONTAINER: '[data-region=\"emojis-container\"]',\r\n    EMOJI_PREVIEW: '[data-region=\"emoji-preview\"]',\r\n    EMOJI_SHORT_NAME: '[data-region=\"emoji-short-name\"]',\r\n    ROW_CONTAINER: '[data-region=\"row-container\"]',\r\n    SEARCH_INPUT: '[data-region=\"search-input\"]',\r\n    SEARCH_RESULTS_CONTAINER: '[data-region=\"search-results-container\"]'\r\n};\r\n\r\n/**\r\n * Create the row data for a category.\r\n *\r\n * @method\r\n * @param {String} categoryName The category name\r\n * @param {String} categoryDisplayName The category display name\r\n * @param {Array} emojis The emoji data\r\n * @param {Number} totalRowCount The total number of rows generated so far\r\n * @return {Array}\r\n */\r\nconst createRowDataForCategory = (categoryName, categoryDisplayName, emojis, totalRowCount) => {\r\n    const rowData = [];\r\n    rowData.push({\r\n        index: totalRowCount + rowData.length,\r\n        type: ROW_TYPE.HEADER,\r\n        data: {\r\n            name: categoryName,\r\n            displayName: categoryDisplayName\r\n        }\r\n    });\r\n\r\n    for (let i = 0; i < emojis.length; i += EMOJIS_PER_ROW) {\r\n        const rowEmojis = emojis.slice(i, i + EMOJIS_PER_ROW);\r\n        rowData.push({\r\n            index: totalRowCount + rowData.length,\r\n            type: ROW_TYPE.EMOJI,\r\n            data: rowEmojis\r\n        });\r\n    }\r\n\r\n    return rowData;\r\n};\r\n\r\n/**\r\n * Add each row's index to it's value in the row data.\r\n *\r\n * @method\r\n * @param {Array} rowData List of emoji row data\r\n * @return {Array}\r\n */\r\nconst addIndexesToRowData = (rowData) => {\r\n    return rowData.map((data, index) => {\r\n        return {...data, index};\r\n    });\r\n};\r\n\r\n/**\r\n * Calculate the scroll position for the beginning of each category from\r\n * the row data.\r\n *\r\n * @method\r\n * @param {Array} rowData List of emoji row data\r\n * @return {Object}\r\n */\r\nconst getCategoryScrollPositionsFromRowData = (rowData) => {\r\n    return rowData.reduce((carry, row, index) => {\r\n        if (row.type === ROW_TYPE.HEADER) {\r\n            carry[row.data.name] = index * ROW_HEIGHT_RAW;\r\n        }\r\n        return carry;\r\n    }, {});\r\n};\r\n\r\n/**\r\n * Create a header row element for the category name.\r\n *\r\n * @method\r\n * @param {Number} rowIndex Index of the row in the row data\r\n * @param {String} name The category display name\r\n * @return {Element}\r\n */\r\nconst createHeaderRow = async(rowIndex, name) => {\r\n    const context = {\r\n        index: rowIndex,\r\n        text: name\r\n    };\r\n    const html = await renderTemplate('core/emoji/header_row', context);\r\n    const temp = document.createElement('div');\r\n    temp.innerHTML = html;\r\n    return temp.firstChild;\r\n};\r\n\r\n/**\r\n * Create an emoji row element.\r\n *\r\n * @method\r\n * @param {Number} rowIndex Index of the row in the row data\r\n * @param {Array} emojis The list of emoji data for the row\r\n * @return {Element}\r\n */\r\nconst createEmojiRow = async(rowIndex, emojis) => {\r\n    const context = {\r\n        index: rowIndex,\r\n        emojis: emojis.map(emojiData => {\r\n            const charCodes = emojiData.unified.split('-').map(code => `0x${code}`);\r\n            const emojiText = String.fromCodePoint.apply(null, charCodes);\r\n            return {\r\n                shortnames: `:${emojiData.shortnames.join(': :')}:`,\r\n                unified: emojiData.unified,\r\n                text: emojiText,\r\n                spacer: false\r\n            };\r\n        }),\r\n        spacers: Array(EMOJIS_PER_ROW - emojis.length).fill(true)\r\n    };\r\n    const html = await renderTemplate('core/emoji/emoji_row', context);\r\n    const temp = document.createElement('div');\r\n    temp.innerHTML = html;\r\n    return temp.firstChild;\r\n};\r\n\r\n/**\r\n * Check if the element is an emoji element.\r\n *\r\n * @method\r\n * @param {Element} element Element to check\r\n * @return {Bool}\r\n */\r\nconst isEmojiElement = element => element.getAttribute('data-short-names') !== null;\r\n\r\n/**\r\n * Search from an element and up through it's ancestors to fine the category\r\n * selector element and return it.\r\n *\r\n * @method\r\n * @param {Element} element Element to begin searching from\r\n * @return {Element|null}\r\n */\r\nconst findCategorySelectorFromElement = element => {\r\n    if (!element) {\r\n        return null;\r\n    }\r\n\r\n    if (element.getAttribute('data-action') === 'show-category') {\r\n        return element;\r\n    } else {\r\n        return findCategorySelectorFromElement(element.parentElement);\r\n    }\r\n};\r\n\r\nconst getCategorySelectorByCategoryName = (root, name) => {\r\n    return root.querySelector(`[data-category=\"${name}\"]`);\r\n};\r\n\r\n/**\r\n * Sets the given category selector element as active.\r\n *\r\n * @method\r\n * @param {Element} root The root picker element\r\n * @param {Element} element The category selector element to make active\r\n */\r\nconst setCategorySelectorActive = (root, element) => {\r\n    const allCategorySelectors = root.querySelectorAll(SELECTORS.CATEGORY_SELECTOR);\r\n\r\n    for (let i = 0; i < allCategorySelectors.length; i++) {\r\n        const selector = allCategorySelectors[i];\r\n        selector.classList.remove('selected');\r\n    }\r\n\r\n    element.classList.add('selected');\r\n};\r\n\r\n/**\r\n * Get the category selector element and the scroll positions for the previous and\r\n * next categories for the given scroll position.\r\n *\r\n * @method\r\n * @param {Element} root The picker root element\r\n * @param {Number} position The position to get the category for\r\n * @param {Object} categoryScrollPositions Set of scroll positions for all categories\r\n * @return {Array}\r\n */\r\nconst getCategoryByScrollPosition = (root, position, categoryScrollPositions) => {\r\n    let positions = [];\r\n\r\n    if (position < 0) {\r\n        position = 0;\r\n    }\r\n\r\n    // Get all of the category positions.\r\n    for (const categoryName in categoryScrollPositions) {\r\n        const categoryPosition = categoryScrollPositions[categoryName];\r\n        positions.push([categoryPosition, categoryName]);\r\n    }\r\n\r\n    // Sort the positions in ascending order.\r\n    positions.sort(([a], [b]) => {\r\n        if (a < b) {\r\n            return -1;\r\n        } else if (a > b) {\r\n            return 1;\r\n        } else {\r\n            return 0;\r\n        }\r\n    });\r\n\r\n    // Get the current category name as well as the previous and next category\r\n    // positions from the sorted list of positions.\r\n    const {categoryName, previousPosition, nextPosition} = positions.reduce(\r\n        (carry, candidate) => {\r\n            const [categoryPosition, categoryName] = candidate;\r\n\r\n            if (categoryPosition <= position) {\r\n                carry.categoryName = categoryName;\r\n                carry.previousPosition = carry.currentPosition;\r\n                carry.currentPosition = position;\r\n            } else if (carry.nextPosition === null) {\r\n                carry.nextPosition = categoryPosition;\r\n            }\r\n\r\n            return carry;\r\n        },\r\n        {\r\n            categoryName: null,\r\n            currentPosition: null,\r\n            previousPosition: null,\r\n            nextPosition: null\r\n        }\r\n    );\r\n\r\n    return [getCategorySelectorByCategoryName(root, categoryName), previousPosition, nextPosition];\r\n};\r\n\r\n/**\r\n * Get the list of recent emojis data from local storage.\r\n *\r\n * @method\r\n * @return {Array}\r\n */\r\nconst getRecentEmojis = () => {\r\n    const storedData = LocalStorage.get(RECENT_EMOJIS_STORAGE_KEY);\r\n    return storedData ? JSON.parse(storedData) : [];\r\n};\r\n\r\n/**\r\n * Save the list of recent emojis in local storage.\r\n *\r\n * @method\r\n * @param {Array} recentEmojis List of emoji data to save\r\n */\r\nconst saveRecentEmoji = (recentEmojis) => {\r\n    LocalStorage.set(RECENT_EMOJIS_STORAGE_KEY, JSON.stringify(recentEmojis));\r\n};\r\n\r\n/**\r\n * Add an emoji data to the set of recent emojis. This function will update the row\r\n * data to ensure that the recent emoji rows are correct and all of the rows are\r\n * re-indexed.\r\n *\r\n * The new set of recent emojis are saved in local storage and the full set of updated\r\n * row data and new emoji row count are returned.\r\n *\r\n * @method\r\n * @param {Array} rowData The emoji rows data\r\n * @param {Number} recentEmojiRowCount Count of the recent emoji rows\r\n * @param {Object} newEmoji The emoji data for the emoji to add to the recent emoji list\r\n * @return {Array}\r\n */\r\nconst addRecentEmoji = (rowData, recentEmojiRowCount, newEmoji) => {\r\n    // The first set of rows is always the recent emojis.\r\n    const categoryName = rowData[0].data.name;\r\n    const categoryDisplayName = rowData[0].data.displayName;\r\n    const recentEmojis = getRecentEmojis();\r\n    // Add the new emoji to the start of the list of recent emojis.\r\n    let newRecentEmojis = [newEmoji, ...recentEmojis.filter(emoji => emoji.unified != newEmoji.unified)];\r\n    // Limit the number of recent emojis.\r\n    newRecentEmojis = newRecentEmojis.slice(0, MAX_RECENT_COUNT);\r\n    const newRecentEmojiRowData = createRowDataForCategory(categoryName, categoryDisplayName, newRecentEmojis);\r\n\r\n    // Save the new list in local storage.\r\n    saveRecentEmoji(newRecentEmojis);\r\n\r\n    return [\r\n        // Return the new rowData and re-index it to make sure it's all correct.\r\n        addIndexesToRowData(newRecentEmojiRowData.concat(rowData.slice(recentEmojiRowCount))),\r\n        newRecentEmojiRowData.length\r\n    ];\r\n};\r\n\r\n/**\r\n * Calculate which rows should be visible based on the given scroll position. Adds a\r\n * buffer to amount to either side of the total number of requested rows so that\r\n * scrolling the emoji rows container is smooth.\r\n *\r\n * @method\r\n * @param {Number} scrollPosition Scroll position within the emoji container\r\n * @param {Number} visibleRowCount How many rows should be visible\r\n * @param {Array} rowData The emoji rows data\r\n * @return {Array}\r\n */\r\nconst getRowsToRender = (scrollPosition, visibleRowCount, rowData) => {\r\n    const minVisibleRow = scrollPosition > ROW_HEIGHT_RAW ? Math.floor(scrollPosition / ROW_HEIGHT_RAW) : 0;\r\n    const start = minVisibleRow >= ROW_RENDER_BUFFER_COUNT ? minVisibleRow - ROW_RENDER_BUFFER_COUNT : minVisibleRow;\r\n    const end = minVisibleRow + visibleRowCount + ROW_RENDER_BUFFER_COUNT;\r\n    const rows = rowData.slice(start, end);\r\n    return rows;\r\n};\r\n\r\n/**\r\n * Create a row element from the row data.\r\n *\r\n * @method\r\n * @param {Object} rowData The emoji row data\r\n * @return {Element}\r\n */\r\nconst createRowElement = async(rowData) => {\r\n    let row = null;\r\n    if (rowData.type === ROW_TYPE.HEADER) {\r\n        row = await createHeaderRow(rowData.index, rowData.data.displayName);\r\n    } else {\r\n        row = await createEmojiRow(rowData.index, rowData.data);\r\n    }\r\n\r\n    row.style.position = 'absolute';\r\n    row.style.left = 0;\r\n    row.style.right = 0;\r\n    row.style.top = `${rowData.index * ROW_HEIGHT_RAW}px`;\r\n\r\n    return row;\r\n};\r\n\r\n/**\r\n * Check if the given rows match.\r\n *\r\n * @method\r\n * @param {Object} a The first row\r\n * @param {Object} b The second row\r\n * @return {Bool}\r\n */\r\nconst doRowsMatch = (a, b) => {\r\n    if (a.index !== b.index) {\r\n        return false;\r\n    }\r\n\r\n    if (a.type !== b.type) {\r\n        return false;\r\n    }\r\n\r\n    if (typeof a.data != typeof b.data) {\r\n        return false;\r\n    }\r\n\r\n    if (a.type === ROW_TYPE.HEADER) {\r\n        return a.data.name === b.data.name;\r\n    } else {\r\n        if (a.data.length !== b.data.length) {\r\n            return false;\r\n        }\r\n\r\n        for (let i = 0; i < a.data.length; i++) {\r\n            if (a.data[i].unified != b.data[i].unified) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n\r\n    return true;\r\n};\r\n\r\n/**\r\n * Update the visible rows. Deletes any row elements that should no longer\r\n * be visible and creates the newly visible row elements. Any rows that haven't\r\n * changed visibility will be left untouched.\r\n *\r\n * @method\r\n * @param {Element} rowContainer The container element for the emoji rows\r\n * @param {Array} currentRows List of row data that matches the currently visible rows\r\n * @param {Array} nextRows List of row data containing the new list of rows to be made visible\r\n */\r\nconst renderRows = async(rowContainer, currentRows, nextRows) => {\r\n    // We need to add any rows that are in nextRows but not in currentRows.\r\n    const toAdd = nextRows.filter(nextRow => !currentRows.some(currentRow => doRowsMatch(currentRow, nextRow)));\r\n    // Remember which rows will still be visible so that we can insert our element in the correct place in the DOM.\r\n    let toKeep = currentRows.filter(currentRow => nextRows.some(nextRow => doRowsMatch(currentRow, nextRow)));\r\n    // We need to remove any rows that are in currentRows but not in nextRows.\r\n    const toRemove = currentRows.filter(currentRow => !nextRows.some(nextRow => doRowsMatch(currentRow, nextRow)));\r\n    const toRemoveElements = toRemove.map(rowData => rowContainer.querySelectorAll(`[data-row=\"${rowData.index}\"]`));\r\n\r\n    // Render all of the templates first.\r\n    const rows = await Promise.all(toAdd.map(rowData => createRowElement(rowData)));\r\n\r\n    rows.forEach((row, index) => {\r\n        const rowData = toAdd[index];\r\n        let nextRowIndex = null;\r\n\r\n        for (let i = 0; i < toKeep.length; i++) {\r\n            const candidate = toKeep[i];\r\n            if (candidate.index > rowData.index) {\r\n                nextRowIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Make sure the elements get added to the DOM in the correct order (ascending by row data index)\r\n        // so that they appear naturally in the tab order.\r\n        if (nextRowIndex !== null) {\r\n            const nextRowData = toKeep[nextRowIndex];\r\n            const nextRowNode = rowContainer.querySelector(`[data-row=\"${nextRowData.index}\"]`);\r\n\r\n            rowContainer.insertBefore(row, nextRowNode);\r\n            toKeep.splice(nextRowIndex, 0, toKeep);\r\n        } else {\r\n            toKeep.push(rowData);\r\n            rowContainer.appendChild(row);\r\n        }\r\n    });\r\n\r\n    toRemoveElements.forEach(rows => {\r\n        for (let i = 0; i < rows.length; i++) {\r\n            const row = rows[i];\r\n            rowContainer.removeChild(row);\r\n        }\r\n    });\r\n};\r\n\r\n/**\r\n * Build a function to render the visible emoji rows for a given scroll\r\n * position.\r\n *\r\n * @method\r\n * @param {Element} rowContainer The container element for the emoji rows\r\n * @return {Function}\r\n */\r\nconst generateRenderRowsAtPositionFunction = (rowContainer) => {\r\n    let currentRows = [];\r\n    let nextRows = [];\r\n    let rowCount = 0;\r\n    let isRendering = false;\r\n    const renderNextRows = async() => {\r\n        if (!nextRows.length) {\r\n            return;\r\n        }\r\n\r\n        if (isRendering) {\r\n            return;\r\n        }\r\n\r\n        isRendering = true;\r\n        const nextRowsToRender = nextRows.slice();\r\n        nextRows = [];\r\n\r\n        await renderRows(rowContainer, currentRows, nextRowsToRender);\r\n        currentRows = nextRowsToRender;\r\n        isRendering = false;\r\n        renderNextRows();\r\n    };\r\n\r\n    return (scrollPosition, rowData, rowLimit = VISIBLE_ROW_COUNT) => {\r\n        nextRows = getRowsToRender(scrollPosition, rowLimit, rowData);\r\n        renderNextRows();\r\n\r\n        if (rowCount !== rowData.length) {\r\n            // Adjust the height of the container to match the number of rows.\r\n            rowContainer.style.height = `${rowData.length * ROW_HEIGHT_RAW}px`;\r\n        }\r\n\r\n        rowCount = rowData.length;\r\n    };\r\n};\r\n\r\n/**\r\n * Show the search results container and hide the emoji container.\r\n *\r\n * @method\r\n * @param {Element} emojiContainer The emojis container\r\n * @param {Element} searchResultsContainer The search results container\r\n */\r\nconst showSearchResults = (emojiContainer, searchResultsContainer) => {\r\n    searchResultsContainer.classList.remove('hidden');\r\n    emojiContainer.classList.add('hidden');\r\n};\r\n\r\n/**\r\n * Hide the search result container and show the emojis container.\r\n *\r\n * @method\r\n * @param {Element} emojiContainer The emojis container\r\n * @param {Element} searchResultsContainer The search results container\r\n * @param {Element} searchInput The search input\r\n */\r\nconst clearSearch = (emojiContainer, searchResultsContainer, searchInput) => {\r\n    searchResultsContainer.classList.add('hidden');\r\n    emojiContainer.classList.remove('hidden');\r\n    searchInput.value = '';\r\n};\r\n\r\n/**\r\n * Build function to handle mouse hovering an emoji. Shows the preview.\r\n *\r\n * @method\r\n * @param {Element} emojiPreview The emoji preview element\r\n * @param {Element} emojiShortName The emoji short name element\r\n * @return {Function}\r\n */\r\nconst getHandleMouseEnter = (emojiPreview, emojiShortName) => {\r\n    return (e) => {\r\n        const target = e.target;\r\n        if (isEmojiElement(target)) {\r\n            emojiShortName.textContent = target.getAttribute('data-short-names');\r\n            emojiPreview.textContent = target.textContent;\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n * Build function to handle mouse leaving an emoji. Removes the preview.\r\n *\r\n * @method\r\n * @param {Element} emojiPreview The emoji preview element\r\n * @param {Element} emojiShortName The emoji short name element\r\n * @return {Function}\r\n */\r\nconst getHandleMouseLeave = (emojiPreview, emojiShortName) => {\r\n    return (e) => {\r\n        const target = e.target;\r\n        if (isEmojiElement(target)) {\r\n            emojiShortName.textContent = '';\r\n            emojiPreview.textContent = '';\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n * Build the function to handle a user clicking something in the picker.\r\n *\r\n * The function currently handles clicking on the category selector or selecting\r\n * a specific emoji.\r\n *\r\n * @method\r\n * @param {Number} recentEmojiRowCount Number of rows of recent emojis\r\n * @param {Element} emojiContainer Container element for the visible of emojis\r\n * @param {Element} searchResultsContainer Contaienr element for the search results\r\n * @param {Element} searchInput Search input element\r\n * @param {Function} selectCallback Callback function to execute when a user selects an emoji\r\n * @param {Function} renderAtPosition Render function to display current visible emojis\r\n * @return {Function}\r\n */\r\nconst getHandleClick = (\r\n    recentEmojiRowCount,\r\n    emojiContainer,\r\n    searchResultsContainer,\r\n    searchInput,\r\n    selectCallback,\r\n    renderAtPosition\r\n) => {\r\n    return (e, rowData, categoryScrollPositions) => {\r\n        const target = e.target;\r\n        let newRowData = rowData;\r\n        let newCategoryScrollPositions = categoryScrollPositions;\r\n\r\n        // Hide the search results if they are visible.\r\n        clearSearch(emojiContainer, searchResultsContainer, searchInput);\r\n\r\n        if (isEmojiElement(target)) {\r\n            // Emoji selected.\r\n            const unified = target.getAttribute('data-unified');\r\n            const shortnames = target.getAttribute('data-short-names').replace(/:/g, '').split(' ');\r\n            // Build the emoji data from the selected element.\r\n            const emojiData = {unified, shortnames};\r\n            const currentScrollTop = emojiContainer.scrollTop;\r\n            const isRecentEmojiRowVisible = emojiContainer.querySelector(`[data-row=\"${recentEmojiRowCount - 1}\"]`) !== null;\r\n            // Save the selected emoji in the recent emojis list.\r\n            [newRowData, recentEmojiRowCount] = addRecentEmoji(rowData, recentEmojiRowCount, emojiData);\r\n            // Re-index the category scroll positions because the additional recent emoji may have\r\n            // changed their positions.\r\n            newCategoryScrollPositions = getCategoryScrollPositionsFromRowData(newRowData);\r\n\r\n            if (isRecentEmojiRowVisible) {\r\n                // If the list of recent emojis is currently visible then we need to re-render the emojis\r\n                // to update the display and show the newly selected recent emoji.\r\n                renderAtPosition(currentScrollTop, newRowData);\r\n            }\r\n\r\n            // Call the client's callback function with the selected emoji.\r\n            selectCallback(target.textContent);\r\n            // Return the newly calculated row data and scroll positions.\r\n            return [newRowData, newCategoryScrollPositions];\r\n        }\r\n\r\n        const categorySelector = findCategorySelectorFromElement(target);\r\n        if (categorySelector) {\r\n            // Category selector.\r\n            const selectedCategory = categorySelector.getAttribute('data-category');\r\n            const position = categoryScrollPositions[selectedCategory];\r\n            // Scroll the container to the selected category. This will trigger the\r\n            // on scroll handler to re-render the visibile emojis.\r\n            emojiContainer.scrollTop = position;\r\n        }\r\n\r\n        return [newRowData, newCategoryScrollPositions];\r\n    };\r\n};\r\n\r\n/**\r\n * Build the function that handles scrolling of the emoji container to display the\r\n * correct emojis.\r\n *\r\n * We render the emoji rows as they are needed rather than all up front so that we\r\n * can avoid adding tends of thousands of elements to the DOM unnecessarily which\r\n * would bog down performance.\r\n *\r\n * @method\r\n * @param {Element} root The picker root element\r\n * @param {Number} currentVisibleRowScrollPosition The current scroll position of the container\r\n * @param {Element} emojiContainer The emojis container element\r\n * @param {Object} initialCategoryScrollPositions Scroll positions for each category\r\n * @param {Function} renderAtPosition Function to render the appropriate emojis for a scroll position\r\n * @return {Function}\r\n */\r\nconst getHandleScroll = (\r\n    root,\r\n    currentVisibleRowScrollPosition,\r\n    emojiContainer,\r\n    initialCategoryScrollPositions,\r\n    renderAtPosition\r\n) => {\r\n    // Scope some local variables to track the scroll positions of the categories. We need to\r\n    // recalculate these because adding recent emojis can change those positions by adding\r\n    // additional rows.\r\n    let [\r\n        currentCategoryElement,\r\n        previousCategoryPosition,\r\n        nextCategoryPosition\r\n    ] = getCategoryByScrollPosition(root, emojiContainer.scrollTop, initialCategoryScrollPositions);\r\n\r\n    return (categoryScrollPositions, rowData) => {\r\n        const newScrollPosition = emojiContainer.scrollTop;\r\n        const upperScrollBound = currentVisibleRowScrollPosition + ROW_HEIGHT_RAW;\r\n        const lowerScrollBound = currentVisibleRowScrollPosition - ROW_HEIGHT_RAW;\r\n        // We only need to update the active category indicator if the user has scrolled into a\r\n        // new category scroll position.\r\n        const updateActiveCategory = (newScrollPosition >= nextCategoryPosition) ||\r\n                       (newScrollPosition < previousCategoryPosition);\r\n        // We only need to render new emoji rows if the user has scrolled far enough that a new row\r\n        // would be visible (i.e. they've scrolled up or down more than 40px - the height of a row).\r\n        const updateRenderRows = (newScrollPosition < lowerScrollBound) || (newScrollPosition > upperScrollBound);\r\n\r\n        if (updateActiveCategory) {\r\n            // New category is visible so update the active category selector and re-index the\r\n            // positions incase anything has changed.\r\n            [\r\n                currentCategoryElement,\r\n                previousCategoryPosition,\r\n                nextCategoryPosition\r\n            ] = getCategoryByScrollPosition(root, newScrollPosition, categoryScrollPositions);\r\n            setCategorySelectorActive(root, currentCategoryElement);\r\n        }\r\n\r\n        if (updateRenderRows) {\r\n            // A new row should be visible so re-render the visible emojis at this new position.\r\n            // We request an animation frame from the browser so that we're not blocking anything.\r\n            // The animation only needs to occur as soon as the browser is ready not immediately.\r\n            requestAnimationFrame(() => {\r\n                renderAtPosition(newScrollPosition, rowData);\r\n                // Remember the updated position.\r\n                currentVisibleRowScrollPosition = newScrollPosition;\r\n            });\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n * Build the function that handles search input from the user.\r\n *\r\n * @method\r\n * @param {Element} searchInput The search input element\r\n * @param {Element} searchResultsContainer Container element to display the search results\r\n * @param {Element} emojiContainer Container element for the emoji rows\r\n * @return {Function}\r\n */\r\nconst getHandleSearch = (searchInput, searchResultsContainer, emojiContainer) => {\r\n    const rowContainer = searchResultsContainer.querySelector(SELECTORS.ROW_CONTAINER);\r\n    // Build a render function for the search results.\r\n    const renderSearchResultsAtPosition = generateRenderRowsAtPositionFunction(rowContainer);\r\n    searchResultsContainer.appendChild(rowContainer);\r\n\r\n    return async() => {\r\n        const searchTerm = searchInput.value.toLowerCase();\r\n\r\n        if (searchTerm) {\r\n            // Display the search results container and hide the emojis container.\r\n            showSearchResults(emojiContainer, searchResultsContainer);\r\n\r\n            // Find which emojis match the user's search input.\r\n            const matchingEmojis = Object.keys(EmojiData.byShortName).reduce((carry, shortName) => {\r\n                if (shortName.includes(searchTerm)) {\r\n                    carry.push({\r\n                        shortnames: [shortName],\r\n                        unified: EmojiData.byShortName[shortName]\r\n                    });\r\n                }\r\n                return carry;\r\n            }, []);\r\n\r\n            const searchResultsString = await getString('searchresults', 'core');\r\n            const rowData = createRowDataForCategory(searchResultsString, searchResultsString, matchingEmojis, 0);\r\n            // Show the emoji rows for the search results.\r\n            renderSearchResultsAtPosition(0, rowData, rowData.length);\r\n        } else {\r\n            // Hide the search container and show the emojis container.\r\n            clearSearch(emojiContainer, searchResultsContainer, searchInput);\r\n        }\r\n    };\r\n};\r\n\r\n/**\r\n * Register the emoji picker event listeners.\r\n *\r\n * @method\r\n * @param {Element} root The picker root element\r\n * @param {Element} emojiContainer Root element containing the list of visible emojis\r\n * @param {Function} renderAtPosition Function to render the visible emojis at a given scroll position\r\n * @param {Number} currentVisibleRowScrollPosition What is the current scroll position\r\n * @param {Function} selectCallback Function to execute when the user picks an emoji\r\n * @param {Object} categoryScrollPositions Scroll positions for where each of the emoji categories begin\r\n * @param {Array} rowData Data representing each of the display rows for hte emoji container\r\n * @param {Number} recentEmojiRowCount Number of rows of recent emojis\r\n */\r\nconst registerEventListeners = (\r\n    root,\r\n    emojiContainer,\r\n    renderAtPosition,\r\n    currentVisibleRowScrollPosition,\r\n    selectCallback,\r\n    categoryScrollPositions,\r\n    rowData,\r\n    recentEmojiRowCount\r\n) => {\r\n    const searchInput = root.querySelector(SELECTORS.SEARCH_INPUT);\r\n    const searchResultsContainer = root.querySelector(SELECTORS.SEARCH_RESULTS_CONTAINER);\r\n    const emojiPreview = root.querySelector(SELECTORS.EMOJI_PREVIEW);\r\n    const emojiShortName = root.querySelector(SELECTORS.EMOJI_SHORT_NAME);\r\n    // Build the click handler function.\r\n    const clickHandler = getHandleClick(\r\n        recentEmojiRowCount,\r\n        emojiContainer,\r\n        searchResultsContainer,\r\n        searchInput,\r\n        selectCallback,\r\n        renderAtPosition\r\n    );\r\n    // Build the scroll handler function.\r\n    const scrollHandler = getHandleScroll(\r\n        root,\r\n        currentVisibleRowScrollPosition,\r\n        emojiContainer,\r\n        categoryScrollPositions,\r\n        renderAtPosition\r\n    );\r\n    const searchHandler = getHandleSearch(searchInput, searchResultsContainer, emojiContainer);\r\n\r\n    // Mouse enter/leave events to show the emoji preview on hover or focus.\r\n    root.addEventListener('focus', getHandleMouseEnter(emojiPreview, emojiShortName), true);\r\n    root.addEventListener('blur', getHandleMouseLeave(emojiPreview, emojiShortName), true);\r\n    root.addEventListener('mouseenter', getHandleMouseEnter(emojiPreview, emojiShortName), true);\r\n    root.addEventListener('mouseleave', getHandleMouseLeave(emojiPreview, emojiShortName), true);\r\n    // User selects an emoji or clicks on one of the emoji category selectors.\r\n    root.addEventListener('click', e => {\r\n        // Update the row data and category scroll positions because they may have changes if the\r\n        // user selects an emoji which updates the recent emojis list.\r\n        [rowData, categoryScrollPositions] = clickHandler(e, rowData, categoryScrollPositions);\r\n    });\r\n    // Throttle the scroll event to only execute once every 50 milliseconds to prevent performance issues\r\n    // in the browser when re-rendering the picker emojis. The scroll event fires a lot otherwise.\r\n    emojiContainer.addEventListener('scroll', throttle(() => scrollHandler(categoryScrollPositions, rowData), 50));\r\n    // Debounce the search input so that it only executes 200 milliseconds after the user has finished typing.\r\n    searchInput.addEventListener('input', debounce(searchHandler, 200));\r\n};\r\n\r\n/**\r\n * Initialise the emoji picker.\r\n *\r\n * @method\r\n * @param {Element} root The root element for the picker\r\n * @param {Function} selectCallback Callback for when the user selects an emoji\r\n */\r\nexport default (root, selectCallback) => {\r\n    const emojiContainer = root.querySelector(SELECTORS.EMOJIS_CONTAINER);\r\n    const rowContainer = emojiContainer.querySelector(SELECTORS.ROW_CONTAINER);\r\n    const recentEmojis = getRecentEmojis();\r\n    // Add the recent emojis category to the list of standard categories.\r\n    const allData = [{\r\n        name: 'Recent',\r\n        emojis: recentEmojis\r\n    }, ...EmojiData.byCategory];\r\n    let rowData = [];\r\n    let recentEmojiRowCount = 0;\r\n\r\n    /**\r\n     * Split categories data into rows which represent how they will be displayed in the\r\n     * picker. Each category will add a row containing the display name for the category\r\n     * and a row for every 9 emojis in the category. The row data will be used to calculate\r\n     * which emojis should be visible in the picker at any given time.\r\n     *\r\n     * E.g.\r\n     * input = [\r\n     *  {name: 'example1', emojis: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]},\r\n     *  {name: 'example2', emojis: [13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]},\r\n     * ]\r\n     * output = [\r\n     *      {type: 'categoryName': data: 'Example 1'},\r\n     *      {type: 'emojiRow': data: [1, 2, 3, 4, 5, 6, 7, 8, 9]},\r\n     *      {type: 'emojiRow': data: [10, 11, 12]},\r\n     *      {type: 'categoryName': data: 'Example 2'},\r\n     *      {type: 'emojiRow': data: [13, 14, 15, 16, 17, 18, 19, 20, 21]},\r\n     *      {type: 'emojiRow': data: [22, 23]},\r\n     * ]\r\n     */\r\n    allData.forEach(category => {\r\n        const categorySelector = getCategorySelectorByCategoryName(root, category.name);\r\n        // Get the display name from the category selector button so that we don't need to\r\n        // send an ajax request for the string.\r\n        const categoryDisplayName = categorySelector.title;\r\n        const categoryRowData = createRowDataForCategory(category.name, categoryDisplayName, category.emojis, rowData.length);\r\n\r\n        if (category.name === 'Recent') {\r\n            // Remember how many recent emoji rows there are because it needs to be used to\r\n            // re-index the row data later when we're adding more recent emojis.\r\n            recentEmojiRowCount = categoryRowData.length;\r\n        }\r\n\r\n        rowData = rowData.concat(categoryRowData);\r\n    });\r\n\r\n    // Index the row data so that we can calculate which rows should be visible.\r\n    rowData = addIndexesToRowData(rowData);\r\n    // Calculate the scroll positions for each of the categories within the emoji container.\r\n    // These are used to know where to jump to when the user selects a specific category.\r\n    const categoryScrollPositions = getCategoryScrollPositionsFromRowData(rowData);\r\n    const renderAtPosition = generateRenderRowsAtPositionFunction(rowContainer);\r\n    // Display the initial set of emojis.\r\n    renderAtPosition(0, rowData);\r\n\r\n    registerEventListeners(\r\n        root,\r\n        emojiContainer,\r\n        renderAtPosition,\r\n        0,\r\n        selectCallback,\r\n        categoryScrollPositions,\r\n        rowData,\r\n        recentEmojiRowCount\r\n    );\r\n};\r\n"],"names":["e","_getRequireWildcardCache","WeakMap","r","t","_localstorage","__esModule","default","EmojiData","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_interopRequireWildcard","ROW_TYPE","SELECTORS","createRowDataForCategory","categoryName","categoryDisplayName","emojis","totalRowCount","rowData","push","index","length","type","data","name","displayName","rowEmojis","slice","addIndexesToRowData","map","getCategoryScrollPositionsFromRowData","reduce","carry","row","isEmojiElement","element","getAttribute","findCategorySelectorFromElement","parentElement","getCategorySelectorByCategoryName","root","querySelector","getCategoryByScrollPosition","position","categoryScrollPositions","positions","categoryPosition","sort","_ref","_ref2","b","previousPosition","nextPosition","candidate","currentPosition","getRecentEmojis","storedData","LocalStorage","JSON","parse","addRecentEmoji","recentEmojiRowCount","newEmoji","recentEmojis","newRecentEmojis","filter","emoji","unified","EMOJIS_PER_ROW","newRecentEmojiRowData","stringify","saveRecentEmoji","concat","createRowElement","async","rowIndex","context","text","html","renderTemplate","temp","document","createElement","innerHTML","firstChild","createHeaderRow","emojiData","charCodes","split","code","emojiText","String","fromCodePoint","apply","shortnames","join","spacer","spacers","Array","fill","createEmojiRow","style","left","right","top","doRowsMatch","generateRenderRowsAtPositionFunction","rowContainer","currentRows","nextRows","rowCount","isRendering","renderNextRows","nextRowsToRender","toAdd","nextRow","some","currentRow","toKeep","toRemoveElements","querySelectorAll","Promise","all","forEach","nextRowIndex","nextRowData","nextRowNode","insertBefore","splice","appendChild","rows","removeChild","renderRows","scrollPosition","getRowsToRender","visibleRowCount","minVisibleRow","Math","floor","start","end","arguments","undefined","height","clearSearch","emojiContainer","searchResultsContainer","searchInput","classList","add","remove","value","getHandleMouseEnter","emojiPreview","emojiShortName","target","textContent","getHandleMouseLeave","getHandleScroll","currentVisibleRowScrollPosition","initialCategoryScrollPositions","renderAtPosition","currentCategoryElement","previousCategoryPosition","nextCategoryPosition","scrollTop","newScrollPosition","updateRenderRows","setCategorySelectorActive","allCategorySelectors","requestAnimationFrame","registerEventListeners","selectCallback","clickHandler","getHandleClick","newRowData","newCategoryScrollPositions","replace","currentScrollTop","isRecentEmojiRowVisible","categorySelector","scrollHandler","searchHandler","getHandleSearch","renderSearchResultsAtPosition","searchTerm","toLowerCase","showSearchResults","matchingEmojis","keys","byShortName","shortName","includes","searchResultsString","getString","addEventListener","throttle","debounce","_exports","_default","allData","byCategory","category","title","categoryRowData"],"mappings":"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"}