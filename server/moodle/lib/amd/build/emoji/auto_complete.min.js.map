{"version":3,"file":"auto_complete.min.js","sources":["../../src/emoji/auto_complete.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Emoji auto complete.\r\n *\r\n * @module core/emoji/auto_complete\r\n * @copyright  2019 Ryan Wyllie <ryan@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nimport * as EmojiData from 'core/emoji/data';\r\nimport {render as renderTemplate} from 'core/templates';\r\nimport {debounce} from 'core/utils';\r\nimport LocalStorage from 'core/localstorage';\r\nimport KeyCodes from 'core/key_codes';\r\n\r\nconst INPUT_DEBOUNCE_TIMER = 200;\r\nconst SUGGESTION_LIMIT = 50;\r\nconst MAX_RECENT_COUNT = 27;\r\nconst RECENT_EMOJIS_STORAGE_KEY = 'moodle-recent-emojis';\r\n\r\nconst SELECTORS = {\r\n    EMOJI_BUTTON: '[data-region=\"emoji-button\"]',\r\n    ACTIVE_EMOJI_BUTTON: '[data-region=\"emoji-button\"].active',\r\n};\r\n\r\n/**\r\n * Get the list of recent emojis data from local storage.\r\n *\r\n * @return {Array}\r\n */\r\nconst getRecentEmojis = () => {\r\n    const storedData = LocalStorage.get(RECENT_EMOJIS_STORAGE_KEY);\r\n    return storedData ? JSON.parse(storedData) : [];\r\n};\r\n\r\n/**\r\n * Add an emoji data to the set of recent emojis. The new set of recent emojis are\r\n * saved in local storage.\r\n *\r\n * @param {String} unified The char chodes for the emoji\r\n * @param {String} shortName The emoji short name\r\n */\r\nconst addRecentEmoji = (unified, shortName) => {\r\n    const newEmoji = {\r\n        unified,\r\n        shortnames: [shortName]\r\n    };\r\n    const recentEmojis = getRecentEmojis();\r\n    // Add the new emoji to the start of the list of recent emojis.\r\n    let newRecentEmojis = [newEmoji, ...recentEmojis.filter(emoji => emoji.unified != newEmoji.unified)];\r\n    // Limit the number of recent emojis.\r\n    newRecentEmojis = newRecentEmojis.slice(0, MAX_RECENT_COUNT);\r\n\r\n    LocalStorage.set(RECENT_EMOJIS_STORAGE_KEY, JSON.stringify(newRecentEmojis));\r\n};\r\n\r\n/**\r\n * Get the actual emoji string from the short name.\r\n *\r\n * @param {String} shortName Emoji short name\r\n * @return {String|null}\r\n */\r\nconst getEmojiTextFromShortName = (shortName) => {\r\n    const unified = EmojiData.byShortName[shortName];\r\n\r\n    if (unified) {\r\n        const charCodes = unified.split('-').map(code => `0x${code}`);\r\n        return String.fromCodePoint.apply(null, charCodes);\r\n    } else {\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Render the auto complete list for the given short names.\r\n *\r\n * @param {Element} root The root container for the emoji auto complete\r\n * @param {Array} shortNames The list of short names for emoji suggestions to show\r\n */\r\nconst render = async(root, shortNames) => {\r\n    const renderContext = {\r\n        emojis: shortNames.map((shortName, index) => {\r\n            return {\r\n                active: index === 0,\r\n                emojitext: getEmojiTextFromShortName(shortName),\r\n                displayshortname: `:${shortName}:`,\r\n                shortname: shortName,\r\n                unified: EmojiData.byShortName[shortName]\r\n            };\r\n        })\r\n    };\r\n    const html = await renderTemplate('core/emoji/auto_complete', renderContext);\r\n    root.innerHTML = html;\r\n};\r\n\r\n/**\r\n * Get the list of emoji short names that include the given search term. If\r\n * the search term is an empty string then the list of recently used emojis\r\n * will be returned.\r\n *\r\n * @param {String} searchTerm Text to match on\r\n * @param {Number} limit Maximum number of results to return\r\n * @return {Array}\r\n */\r\nconst searchEmojis = (searchTerm, limit) => {\r\n    if (searchTerm === '') {\r\n        return getRecentEmojis().map(data => data.shortnames[0]).slice(0, limit);\r\n    } else {\r\n        searchTerm = searchTerm.toLowerCase();\r\n        return Object.keys(EmojiData.byShortName)\r\n                .filter(shortName => shortName.includes(searchTerm))\r\n                .slice(0, limit);\r\n    }\r\n};\r\n\r\n/**\r\n * Get the current word at the given position (index) within the text.\r\n *\r\n * @param {String} text The text to process\r\n * @param {Number} position The position (index) within the text to match the word\r\n * @return {String}\r\n */\r\nconst getWordFromPosition = (text, position) => {\r\n    const startMatches = text.slice(0, position).match(/(\\S*)$/);\r\n    const endMatches = text.slice(position).match(/^(\\S*)/);\r\n    let startText = '';\r\n    let endText = '';\r\n\r\n    if (startMatches) {\r\n        startText = startMatches[startMatches.length - 1];\r\n    }\r\n\r\n    if (endMatches) {\r\n        endText = endMatches[endMatches.length - 1];\r\n    }\r\n\r\n    return `${startText}${endText}`;\r\n};\r\n\r\n/**\r\n * Check if the given text is a full short name, i.e. has leading and trialing colon\r\n * characters.\r\n *\r\n * @param {String} text The text to process\r\n * @return {Bool}\r\n */\r\nconst isCompleteShortName = text => /^:[^:\\s]+:$/.test(text);\r\n\r\n/**\r\n * Check if the given text is a partial short name, i.e. has a leading colon but no\r\n * trailing colon.\r\n *\r\n * @param {String} text The text to process\r\n * @return {Bool}\r\n */\r\nconst isPartialShortName = text => /^:[^:\\s]*$/.test(text);\r\n\r\n/**\r\n * Remove the colon characters from the given text.\r\n *\r\n * @param {String} text The text to process\r\n * @return {String}\r\n */\r\nconst getShortNameFromText = text => text.replace(/:/g, '');\r\n\r\n/**\r\n * Get the currently active emoji button element in the list of suggestions.\r\n *\r\n * @param {Element} root The emoji auto complete container element\r\n * @return {Element|null}\r\n */\r\nconst getActiveEmojiSuggestion = (root) => {\r\n    return root.querySelector(SELECTORS.ACTIVE_EMOJI_BUTTON);\r\n};\r\n\r\n/**\r\n * Make the previous sibling of the current active emoji active.\r\n *\r\n * @param {Element} root The emoji auto complete container element\r\n */\r\nconst selectPreviousEmojiSuggestion = (root) => {\r\n    const activeEmojiSuggestion = getActiveEmojiSuggestion(root);\r\n    const previousSuggestion = activeEmojiSuggestion.previousElementSibling;\r\n\r\n    if (previousSuggestion) {\r\n        activeEmojiSuggestion.classList.remove('active');\r\n        previousSuggestion.classList.add('active');\r\n        previousSuggestion.scrollIntoView({behaviour: 'smooth', inline: 'center'});\r\n    }\r\n};\r\n\r\n/**\r\n * Make the next sibling to the current active emoji active.\r\n *\r\n * @param {Element} root The emoji auto complete container element\r\n */\r\nconst selectNextEmojiSuggestion = (root) => {\r\n    const activeEmojiSuggestion = getActiveEmojiSuggestion(root);\r\n    const nextSuggestion = activeEmojiSuggestion.nextElementSibling;\r\n\r\n    if (nextSuggestion) {\r\n        activeEmojiSuggestion.classList.remove('active');\r\n        nextSuggestion.classList.add('active');\r\n        nextSuggestion.scrollIntoView({behaviour: 'smooth', inline: 'center'});\r\n    }\r\n};\r\n\r\n/**\r\n * Trigger the select callback for the given emoji button element.\r\n *\r\n * @param {Element} element The emoji button element\r\n * @param {Function} selectCallback The callback for when the user selects an emoji\r\n */\r\nconst selectEmojiElement = (element, selectCallback) => {\r\n    const shortName = element.getAttribute('data-short-name');\r\n    const unified = element.getAttribute('data-unified');\r\n    addRecentEmoji(unified, shortName);\r\n    selectCallback(element.innerHTML.trim());\r\n};\r\n\r\n/**\r\n * Initialise the emoji auto complete.\r\n *\r\n * @method\r\n * @param {Element} root The root container element for the auto complete\r\n * @param {Element} textArea The text area element to monitor for auto complete\r\n * @param {Function} hasSuggestionCallback Callback for when there are auto-complete suggestions\r\n * @param {Function} selectCallback Callback for when the user selects an emoji\r\n */\r\nexport default (root, textArea, hasSuggestionCallback, selectCallback) => {\r\n    let hasSuggestions = false;\r\n    let previousSearchText = '';\r\n\r\n    // Debounce the listener so that each keypress delays the execution of the handler. The\r\n    // handler should only run 200 milliseconds after the last keypress.\r\n    textArea.addEventListener('keyup', debounce(() => {\r\n        // This is a \"keyup\" listener so that it only executes after the text area value\r\n        // has been updated.\r\n        const text = textArea.value;\r\n        const cursorPos = textArea.selectionStart;\r\n        const searchText = getWordFromPosition(text, cursorPos);\r\n\r\n        if (searchText === previousSearchText) {\r\n            // Nothing has changed so no need to take any action.\r\n            return;\r\n        } else {\r\n            previousSearchText = searchText;\r\n        }\r\n\r\n        if (isCompleteShortName(searchText)) {\r\n            // If the user has entered a full short name (with leading and trialing colons)\r\n            // then see if we can find a match for it and auto complete it.\r\n            const shortName = getShortNameFromText(searchText);\r\n            const emojiText = getEmojiTextFromShortName(shortName);\r\n            hasSuggestions = false;\r\n            if (emojiText) {\r\n                addRecentEmoji(EmojiData.byShortName[shortName], shortName);\r\n                selectCallback(emojiText);\r\n            }\r\n        } else if (isPartialShortName(searchText)) {\r\n            // If the user has entered a partial short name (leading colon but no trailing) then\r\n            // search on the text to see if we can find some suggestions for them.\r\n            const suggestions = searchEmojis(getShortNameFromText(searchText), SUGGESTION_LIMIT);\r\n\r\n            if (suggestions.length) {\r\n                render(root, suggestions);\r\n                hasSuggestions = true;\r\n            } else {\r\n                hasSuggestions = false;\r\n            }\r\n        } else {\r\n            hasSuggestions = false;\r\n        }\r\n\r\n        hasSuggestionCallback(hasSuggestions);\r\n    }, INPUT_DEBOUNCE_TIMER));\r\n\r\n    textArea.addEventListener('keydown', (e) => {\r\n        if (hasSuggestions) {\r\n            const isModifierPressed = (e.shiftKey || e.metaKey || e.altKey || e.ctrlKey);\r\n            if (!isModifierPressed) {\r\n                switch (e.which) {\r\n                    case KeyCodes.escape:\r\n                        // Escape key closes the auto complete.\r\n                        hasSuggestions = false;\r\n                        hasSuggestionCallback(false);\r\n                        break;\r\n                    case KeyCodes.arrowLeft:\r\n                        // Arrow keys navigate through the list of suggetions.\r\n                        selectPreviousEmojiSuggestion(root);\r\n                        e.preventDefault();\r\n                        break;\r\n                    case KeyCodes.arrowRight:\r\n                        // Arrow keys navigate through the list of suggetions.\r\n                        selectNextEmojiSuggestion(root);\r\n                        e.preventDefault();\r\n                        break;\r\n                    case KeyCodes.enter:\r\n                        // Enter key selects the current suggestion.\r\n                        selectEmojiElement(getActiveEmojiSuggestion(root), selectCallback);\r\n                        e.preventDefault();\r\n                        e.stopPropagation();\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    });\r\n\r\n    root.addEventListener('click', (e) => {\r\n        const target = e.target;\r\n        if (target.matches(SELECTORS.EMOJI_BUTTON)) {\r\n            selectEmojiElement(target, selectCallback);\r\n        }\r\n    });\r\n};\r\n"],"names":["_interopRequireDefault","e","__esModule","default","_getRequireWildcardCache","WeakMap","r","t","EmojiData","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_interopRequireWildcard","_localstorage","_key_codes","SELECTORS","getRecentEmojis","storedData","LocalStorage","JSON","parse","addRecentEmoji","unified","shortName","newEmoji","shortnames","recentEmojis","newRecentEmojis","filter","emoji","slice","stringify","getEmojiTextFromShortName","byShortName","charCodes","split","map","code","String","fromCodePoint","apply","getShortNameFromText","text","replace","getActiveEmojiSuggestion","root","querySelector","selectEmojiElement","element","selectCallback","getAttribute","innerHTML","trim","_exports","_default","textArea","hasSuggestionCallback","hasSuggestions","previousSearchText","addEventListener","debounce","searchText","getWordFromPosition","position","startMatches","match","endMatches","startText","endText","length","value","selectionStart","test","isCompleteShortName","emojiText","isPartialShortName","suggestions","searchTerm","limit","data","toLowerCase","keys","includes","async","shortNames","renderContext","emojis","index","active","emojitext","displayshortname","shortname","html","renderTemplate","render","searchEmojis","shiftKey","metaKey","altKey","ctrlKey","which","KeyCodes","escape","arrowLeft","activeEmojiSuggestion","previousSuggestion","previousElementSibling","classList","remove","add","scrollIntoView","behaviour","inline","selectPreviousEmojiSuggestion","preventDefault","arrowRight","nextSuggestion","nextElementSibling","selectNextEmojiSuggestion","enter","stopPropagation","target","matches"],"mappings":"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"}