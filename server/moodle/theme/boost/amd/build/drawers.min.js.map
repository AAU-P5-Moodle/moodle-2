{"version":3,"file":"drawers.min.js","sources":["../src/drawers.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * Toggling the visibility of the secondary navigation on mobile.\r\n *\r\n * @module     theme_boost/drawers\r\n * @copyright  2021 Bas Brands\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nimport ModalBackdrop from 'core/modal_backdrop';\r\nimport Templates from 'core/templates';\r\nimport * as Aria from 'core/aria';\r\nimport {dispatchEvent} from 'core/event_dispatcher';\r\nimport {debounce} from 'core/utils';\r\nimport {isSmall, isLarge} from 'core/pagehelpers';\r\nimport Pending from 'core/pending';\r\nimport {setUserPreference} from 'core_user/repository';\r\n// The jQuery module is only used for interacting with Boostrap 4. It can we removed when MDL-71979 is integrated.\r\nimport jQuery from 'jquery';\r\n\r\nlet backdropPromise = null;\r\n\r\nconst drawerMap = new Map();\r\n\r\nconst SELECTORS = {\r\n    BUTTONS: '[data-toggler=\"drawers\"]',\r\n    CLOSEBTN: '[data-toggler=\"drawers\"][data-action=\"closedrawer\"]',\r\n    OPENBTN: '[data-toggler=\"drawers\"][data-action=\"opendrawer\"]',\r\n    TOGGLEBTN: '[data-toggler=\"drawers\"][data-action=\"toggle\"]',\r\n    DRAWERS: '[data-region=\"fixed-drawer\"]',\r\n    DRAWERCONTENT: '.drawercontent',\r\n    PAGECONTENT: '#page-content',\r\n    HEADERCONTENT: '.drawerheadercontent',\r\n};\r\n\r\nconst CLASSES = {\r\n    SCROLLED: 'scrolled',\r\n    SHOW: 'show',\r\n    NOTINITIALISED: 'not-initialized',\r\n};\r\n\r\n/**\r\n * Pixel thresshold to auto-hide drawers.\r\n *\r\n * @type {Number}\r\n */\r\nconst THRESHOLD = 20;\r\n\r\n/**\r\n * Try to get the drawer z-index from the page content.\r\n *\r\n * @returns {Number|null} the z-index of the drawer.\r\n * @private\r\n */\r\nconst getDrawerZIndex = () => {\r\n    const drawer = document.querySelector(SELECTORS.DRAWERS);\r\n    if (!drawer) {\r\n        return null;\r\n    }\r\n    return parseInt(window.getComputedStyle(drawer).zIndex, 10);\r\n};\r\n\r\n/**\r\n * Add a backdrop to the page.\r\n *\r\n * @returns {Promise} rendering of modal backdrop.\r\n * @private\r\n */\r\nconst getBackdrop = () => {\r\n    if (!backdropPromise) {\r\n        backdropPromise = Templates.render('core/modal_backdrop', {})\r\n        .then(html => new ModalBackdrop(html))\r\n        .then(modalBackdrop => {\r\n            const drawerZindex = getDrawerZIndex();\r\n            if (drawerZindex) {\r\n                modalBackdrop.setZIndex(getDrawerZIndex() - 1);\r\n            }\r\n            modalBackdrop.getAttachmentPoint().get(0).addEventListener('click', e => {\r\n                e.preventDefault();\r\n                Drawers.closeAllDrawers();\r\n            });\r\n            return modalBackdrop;\r\n        })\r\n        .catch();\r\n    }\r\n    return backdropPromise;\r\n};\r\n\r\n/**\r\n * Get the button element to open a specific drawer.\r\n *\r\n * @param {String} drawerId the drawer element Id\r\n * @return {HTMLElement|undefined} the open button element\r\n * @private\r\n */\r\nconst getDrawerOpenButton = (drawerId) => {\r\n    let openButton = document.querySelector(`${SELECTORS.OPENBTN}[data-target=\"${drawerId}\"]`);\r\n    if (!openButton) {\r\n        openButton = document.querySelector(`${SELECTORS.TOGGLEBTN}[data-target=\"${drawerId}\"]`);\r\n    }\r\n    return openButton;\r\n};\r\n\r\n/**\r\n * Disable drawer tooltips.\r\n *\r\n * @param {HTMLElement} drawerNode the drawer main node\r\n * @private\r\n */\r\nconst disableDrawerTooltips = (drawerNode) => {\r\n    const buttons = [\r\n        drawerNode.querySelector(SELECTORS.CLOSEBTN),\r\n        getDrawerOpenButton(drawerNode.id),\r\n    ];\r\n    buttons.forEach(button => {\r\n        if (!button) {\r\n            return;\r\n        }\r\n        disableButtonTooltip(button);\r\n    });\r\n};\r\n\r\n/**\r\n * Disable the button tooltips.\r\n *\r\n * @param {HTMLElement} button the button element\r\n * @param {boolean} enableOnBlur if the tooltip must be re-enabled on blur.\r\n * @private\r\n */\r\nconst disableButtonTooltip = (button, enableOnBlur) => {\r\n    if (button.hasAttribute('data-original-title')) {\r\n        // The jQuery is still used in Boostrap 4. It can we removed when MDL-71979 is integrated.\r\n        jQuery(button).tooltip('disable');\r\n        button.setAttribute('title', button.dataset.originalTitle);\r\n    } else {\r\n        button.dataset.disabledToggle = button.dataset.toggle;\r\n        button.removeAttribute('data-toggle');\r\n    }\r\n    if (enableOnBlur) {\r\n        button.dataset.restoreTooltipOnBlur = true;\r\n    }\r\n};\r\n\r\n/**\r\n * Enable drawer tooltips.\r\n *\r\n * @param {HTMLElement} drawerNode the drawer main node\r\n * @private\r\n */\r\nconst enableDrawerTooltips = (drawerNode) => {\r\n    const buttons = [\r\n        drawerNode.querySelector(SELECTORS.CLOSEBTN),\r\n        getDrawerOpenButton(drawerNode.id),\r\n    ];\r\n    buttons.forEach(button => {\r\n        if (!button) {\r\n            return;\r\n        }\r\n        enableButtonTooltip(button);\r\n    });\r\n};\r\n\r\n/**\r\n * Enable the button tooltips.\r\n *\r\n * @param {HTMLElement} button the button element\r\n * @private\r\n */\r\nconst enableButtonTooltip = (button) => {\r\n    // The jQuery is still used in Boostrap 4. It can we removed when MDL-71979 is integrated.\r\n    if (button.hasAttribute('data-original-title')) {\r\n        jQuery(button).tooltip('enable');\r\n        button.removeAttribute('title');\r\n    } else if (button.dataset.disabledToggle) {\r\n        button.dataset.toggle = button.dataset.disabledToggle;\r\n        jQuery(button).tooltip();\r\n    }\r\n    delete button.dataset.restoreTooltipOnBlur;\r\n};\r\n\r\n/**\r\n * Add scroll listeners to a drawer element.\r\n *\r\n * @param {HTMLElement} drawerNode the drawer main node\r\n * @private\r\n */\r\nconst addInnerScrollListener = (drawerNode) => {\r\n    const content = drawerNode.querySelector(SELECTORS.DRAWERCONTENT);\r\n    if (!content) {\r\n        return;\r\n    }\r\n    content.addEventListener(\"scroll\", () => {\r\n        drawerNode.classList.toggle(\r\n            CLASSES.SCROLLED,\r\n            content.scrollTop != 0\r\n        );\r\n    });\r\n};\r\n\r\n/**\r\n * The Drawers class is used to control on-screen drawer elements.\r\n *\r\n * It handles opening, and closing of drawer elements, as well as more detailed behaviours such as closing a drawer when\r\n * another drawer is opened, and supports closing a drawer when the screen is resized.\r\n *\r\n * Drawers are instantiated on page load, and can also be toggled lazily when toggling any drawer toggle, open button,\r\n * or close button.\r\n *\r\n * A range of show and hide events are also dispatched as detailed in the class\r\n * {@link module:theme_boost/drawers#eventTypes eventTypes} object.\r\n *\r\n * @example <caption>Standard usage</caption>\r\n *\r\n * // The module just needs to be included to add drawer support.\r\n * import 'theme_boost/drawers';\r\n *\r\n * @example <caption>Manually open or close any drawer</caption>\r\n *\r\n * import Drawers from 'theme_boost/drawers';\r\n *\r\n * const myDrawer = Drawers.getDrawerInstanceForNode(document.querySelector('.myDrawerNode');\r\n * myDrawer.closeDrawer();\r\n *\r\n * @example <caption>Listen to the before show event and cancel it</caption>\r\n *\r\n * import Drawers from 'theme_boost/drawers';\r\n *\r\n * document.addEventListener(Drawers.eventTypes.drawerShow, e => {\r\n *     // The drawer which will be shown.\r\n *     window.console.log(e.target);\r\n *\r\n *     // The instance of the Drawers class for this drawer.\r\n *     window.console.log(e.detail.drawerInstance);\r\n *\r\n *     // Prevent this drawer from being shown.\r\n *     e.preventDefault();\r\n * });\r\n *\r\n * @example <caption>Listen to the shown event</caption>\r\n *\r\n * document.addEventListener(Drawers.eventTypes.drawerShown, e => {\r\n *     // The drawer which was shown.\r\n *     window.console.log(e.target);\r\n *\r\n *     // The instance of the Drawers class for this drawer.\r\n *     window.console.log(e.detail.drawerInstance);\r\n * });\r\n */\r\nexport default class Drawers {\r\n    /**\r\n     * The underlying HTMLElement which is controlled.\r\n     */\r\n    drawerNode = null;\r\n\r\n    /**\r\n     * The drawer page bounding box dimensions.\r\n     * @var {DOMRect} boundingRect\r\n     */\r\n    boundingRect = null;\r\n\r\n    constructor(drawerNode) {\r\n        // Some behat tests may use fake drawer divs to test components in drawers.\r\n        if (drawerNode.dataset.behatFakeDrawer !== undefined) {\r\n            return;\r\n        }\r\n\r\n        this.drawerNode = drawerNode;\r\n\r\n        if (isSmall()) {\r\n            this.closeDrawer({focusOnOpenButton: false, updatePreferences: false});\r\n        }\r\n\r\n        if (this.drawerNode.classList.contains(CLASSES.SHOW)) {\r\n            this.openDrawer({focusOnCloseButton: false, setUserPref: false});\r\n        } else if (this.drawerNode.dataset.forceopen == 1) {\r\n            if (!isSmall()) {\r\n                this.openDrawer({focusOnCloseButton: false, setUserPref: false});\r\n            }\r\n        } else {\r\n            Aria.hide(this.drawerNode);\r\n        }\r\n\r\n        // Disable tooltips in small screens.\r\n        if (isSmall()) {\r\n            disableDrawerTooltips(this.drawerNode);\r\n        }\r\n\r\n        addInnerScrollListener(this.drawerNode);\r\n\r\n        drawerMap.set(drawerNode, this);\r\n\r\n        drawerNode.classList.remove(CLASSES.NOTINITIALISED);\r\n    }\r\n\r\n    /**\r\n     * Whether the drawer is open.\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    get isOpen() {\r\n        return this.drawerNode.classList.contains(CLASSES.SHOW);\r\n    }\r\n\r\n    /**\r\n     * Whether the drawer should close when the window is resized\r\n     *\r\n     * @returns {boolean}\r\n     */\r\n    get closeOnResize() {\r\n        return !!parseInt(this.drawerNode.dataset.closeOnResize);\r\n    }\r\n\r\n    /**\r\n     * The list of event types.\r\n     *\r\n     * @static\r\n     * @property {String} drawerShow See {@link event:theme_boost/drawers:show}\r\n     * @property {String} drawerShown See {@link event:theme_boost/drawers:shown}\r\n     * @property {String} drawerHide See {@link event:theme_boost/drawers:hide}\r\n     * @property {String} drawerHidden See {@link event:theme_boost/drawers:hidden}\r\n     */\r\n    static eventTypes = {\r\n        /**\r\n         * An event triggered before a drawer is shown.\r\n         *\r\n         * @event theme_boost/drawers:show\r\n         * @type {CustomEvent}\r\n         * @property {HTMLElement} target The drawer that will be opened.\r\n         */\r\n        drawerShow: 'theme_boost/drawers:show',\r\n\r\n        /**\r\n         * An event triggered after a drawer is shown.\r\n         *\r\n         * @event theme_boost/drawers:shown\r\n         * @type {CustomEvent}\r\n         * @property {HTMLElement} target The drawer that was be opened.\r\n         */\r\n        drawerShown: 'theme_boost/drawers:shown',\r\n\r\n        /**\r\n         * An event triggered before a drawer is hidden.\r\n         *\r\n         * @event theme_boost/drawers:hide\r\n         * @type {CustomEvent}\r\n         * @property {HTMLElement} target The drawer that will be hidden.\r\n         */\r\n        drawerHide: 'theme_boost/drawers:hide',\r\n\r\n        /**\r\n         * An event triggered after a drawer is hidden.\r\n         *\r\n         * @event theme_boost/drawers:hidden\r\n         * @type {CustomEvent}\r\n         * @property {HTMLElement} target The drawer that was be hidden.\r\n         */\r\n        drawerHidden: 'theme_boost/drawers:hidden',\r\n    };\r\n\r\n\r\n    /**\r\n     * Get the drawer instance for the specified node\r\n     *\r\n     * @param {HTMLElement} drawerNode\r\n     * @returns {module:theme_boost/drawers}\r\n     */\r\n    static getDrawerInstanceForNode(drawerNode) {\r\n        if (!drawerMap.has(drawerNode)) {\r\n            new Drawers(drawerNode);\r\n        }\r\n\r\n        return drawerMap.get(drawerNode);\r\n    }\r\n\r\n    /**\r\n     * Dispatch a drawer event.\r\n     *\r\n     * @param {string} eventname the event name\r\n     * @param {boolean} cancelable if the event is cancelable\r\n     * @returns {CustomEvent} the resulting custom event\r\n     */\r\n    dispatchEvent(eventname, cancelable = false) {\r\n        return dispatchEvent(\r\n            eventname,\r\n            {\r\n                drawerInstance: this,\r\n            },\r\n            this.drawerNode,\r\n            {\r\n                cancelable,\r\n            }\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Open the drawer.\r\n     *\r\n     * By default, openDrawer sets the page focus to the close drawer button. However, when a drawer is open at page\r\n     * load, this represents an accessibility problem as the initial focus changes without any user interaction. The\r\n     * focusOnCloseButton parameter can be set to false to prevent this behaviour.\r\n     *\r\n     * @param {object} args\r\n     * @param {boolean} [args.focusOnCloseButton=true] Whether to alter page focus when opening the drawer\r\n     * @param {boolean} [args.setUserPref=true] Whether to store the opened drawer state as a user preference\r\n     */\r\n    openDrawer({focusOnCloseButton = true, setUserPref = true} = {}) {\r\n\r\n        const pendingPromise = new Pending('theme_boost/drawers:open');\r\n        const showEvent = this.dispatchEvent(Drawers.eventTypes.drawerShow, true);\r\n        if (showEvent.defaultPrevented) {\r\n            return;\r\n        }\r\n\r\n        // Hide close button and header content while the drawer is showing to prevent glitchy effects.\r\n        this.drawerNode.querySelector(SELECTORS.CLOSEBTN)?.classList.toggle('hidden', true);\r\n        this.drawerNode.querySelector(SELECTORS.HEADERCONTENT)?.classList.toggle('hidden', true);\r\n\r\n\r\n        // Remove open tooltip if still visible.\r\n        let openButton = getDrawerOpenButton(this.drawerNode.id);\r\n        if (openButton && openButton.hasAttribute('data-original-title')) {\r\n            // The jQuery is still used in Boostrap 4. It can we removed when MDL-71979 is integrated.\r\n            jQuery(openButton)?.tooltip('hide');\r\n        }\r\n\r\n        Aria.unhide(this.drawerNode);\r\n        this.drawerNode.classList.add(CLASSES.SHOW);\r\n\r\n        const preference = this.drawerNode.dataset.preference;\r\n        if (preference && !isSmall() && (this.drawerNode.dataset.forceopen != 1) && setUserPref) {\r\n            setUserPreference(preference, true);\r\n        }\r\n\r\n        const state = this.drawerNode.dataset.state;\r\n        if (state) {\r\n            const page = document.getElementById('page');\r\n            page.classList.add(state);\r\n        }\r\n\r\n        this.boundingRect = this.drawerNode.getBoundingClientRect();\r\n\r\n        if (isSmall()) {\r\n            getBackdrop().then(backdrop => {\r\n                backdrop.show();\r\n\r\n                const pageWrapper = document.getElementById('page');\r\n                pageWrapper.style.overflow = 'hidden';\r\n                return backdrop;\r\n            })\r\n            .catch();\r\n        }\r\n\r\n        // Show close button and header content once the drawer is fully opened.\r\n        const closeButton = this.drawerNode.querySelector(SELECTORS.CLOSEBTN);\r\n        const headerContent = this.drawerNode.querySelector(SELECTORS.HEADERCONTENT);\r\n        if (focusOnCloseButton && closeButton) {\r\n            disableButtonTooltip(closeButton, true);\r\n        }\r\n        setTimeout(() => {\r\n            closeButton.classList.toggle('hidden', false);\r\n            headerContent.classList.toggle('hidden', false);\r\n            if (focusOnCloseButton) {\r\n                closeButton.focus();\r\n            }\r\n            pendingPromise.resolve();\r\n        }, 300);\r\n\r\n        this.dispatchEvent(Drawers.eventTypes.drawerShown);\r\n    }\r\n\r\n    /**\r\n     * Close the drawer.\r\n     *\r\n     * @param {object} args\r\n     * @param {boolean} [args.focusOnOpenButton=true] Whether to alter page focus when opening the drawer\r\n     * @param {boolean} [args.updatePreferences=true] Whether to update the user prewference\r\n     */\r\n    closeDrawer({focusOnOpenButton = true, updatePreferences = true} = {}) {\r\n\r\n        const pendingPromise = new Pending('theme_boost/drawers:close');\r\n\r\n        const hideEvent = this.dispatchEvent(Drawers.eventTypes.drawerHide, true);\r\n        if (hideEvent.defaultPrevented) {\r\n            return;\r\n        }\r\n\r\n        // Hide close button and header content while the drawer is hiding to prevent glitchy effects.\r\n        const closeButton = this.drawerNode.querySelector(SELECTORS.CLOSEBTN);\r\n        closeButton?.classList.toggle('hidden', true);\r\n        const headerContent = this.drawerNode.querySelector(SELECTORS.HEADERCONTENT);\r\n        headerContent?.classList.toggle('hidden', true);\r\n        // Remove the close button tooltip if visible.\r\n        if (closeButton.hasAttribute('data-original-title')) {\r\n            // The jQuery is still used in Boostrap 4. It can we removed when MDL-71979 is integrated.\r\n            jQuery(closeButton)?.tooltip('hide');\r\n        }\r\n\r\n        const preference = this.drawerNode.dataset.preference;\r\n        if (preference && updatePreferences && !isSmall()) {\r\n            setUserPreference(preference, false);\r\n        }\r\n\r\n        const state = this.drawerNode.dataset.state;\r\n        if (state) {\r\n            const page = document.getElementById('page');\r\n            page.classList.remove(state);\r\n        }\r\n\r\n        Aria.hide(this.drawerNode);\r\n        this.drawerNode.classList.remove(CLASSES.SHOW);\r\n\r\n        getBackdrop().then(backdrop => {\r\n            backdrop.hide();\r\n\r\n            if (isSmall()) {\r\n                const pageWrapper = document.getElementById('page');\r\n                pageWrapper.style.overflow = 'visible';\r\n            }\r\n            return backdrop;\r\n        })\r\n        .catch();\r\n\r\n        // Move focus to the open drawer (or toggler) button once the drawer is hidden.\r\n        let openButton = getDrawerOpenButton(this.drawerNode.id);\r\n        if (openButton) {\r\n            disableButtonTooltip(openButton, true);\r\n        }\r\n        setTimeout(() => {\r\n            if (openButton && focusOnOpenButton) {\r\n                openButton.focus();\r\n            }\r\n            pendingPromise.resolve();\r\n        }, 300);\r\n\r\n        this.dispatchEvent(Drawers.eventTypes.drawerHidden);\r\n    }\r\n\r\n    /**\r\n     * Toggle visibility of the drawer.\r\n     */\r\n    toggleVisibility() {\r\n        if (this.drawerNode.classList.contains(CLASSES.SHOW)) {\r\n            this.closeDrawer();\r\n        } else {\r\n            this.openDrawer();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Displaces the drawer outsite the page.\r\n     *\r\n     * @param {Number} scrollPosition the page current scroll position\r\n     */\r\n    displace(scrollPosition) {\r\n        let displace = scrollPosition;\r\n        let openButton = getDrawerOpenButton(this.drawerNode.id);\r\n        if (scrollPosition === 0) {\r\n            this.drawerNode.style.transform = '';\r\n            if (openButton) {\r\n                openButton.style.transform = '';\r\n            }\r\n            return;\r\n        }\r\n        const state = this.drawerNode.dataset?.state;\r\n        const drawrWidth = this.drawerNode.offsetWidth;\r\n        let scrollThreshold = drawrWidth;\r\n        let direction = -1;\r\n        if (state === 'show-drawer-right') {\r\n            direction = 1;\r\n            scrollThreshold = THRESHOLD;\r\n        }\r\n        // LTR scroll is positive while RTL scroll is negative.\r\n        if (Math.abs(scrollPosition) > scrollThreshold) {\r\n            displace = Math.sign(scrollPosition) * (drawrWidth + THRESHOLD);\r\n        }\r\n        displace *= direction;\r\n        const transform = `translateX(${displace}px)`;\r\n        if (openButton) {\r\n            openButton.style.transform = transform;\r\n        }\r\n        this.drawerNode.style.transform = transform;\r\n    }\r\n\r\n    /**\r\n     * Prevent drawer from overlapping an element.\r\n     *\r\n     * @param {HTMLElement} currentFocus\r\n     */\r\n    preventOverlap(currentFocus) {\r\n        // Start position drawer (aka. left drawer) will never overlap with the page content.\r\n        if (!this.isOpen || this.drawerNode.dataset?.state === 'show-drawer-left') {\r\n            return;\r\n        }\r\n        const drawrWidth = this.drawerNode.offsetWidth;\r\n        const element = currentFocus.getBoundingClientRect();\r\n\r\n        // The this.boundingRect is calculated only once and it is reliable\r\n        // for horizontal overlapping (which is the most common). However,\r\n        // it is not reliable for vertical overlapping because the drawer\r\n        // height can be changed by other elements like sticky footer.\r\n        // To prevent recalculating the boundingRect on every\r\n        // focusin event, we use horizontal overlapping as first fast check.\r\n        let overlapping = (\r\n            (element.right + THRESHOLD) > this.boundingRect.left &&\r\n            (element.left - THRESHOLD) < this.boundingRect.right\r\n        );\r\n        if (overlapping) {\r\n            const currentBoundingRect = this.drawerNode.getBoundingClientRect();\r\n            overlapping = (\r\n                (element.bottom) > currentBoundingRect.top &&\r\n                (element.top) < currentBoundingRect.bottom\r\n            );\r\n        }\r\n\r\n        if (overlapping) {\r\n            // Force drawer to displace out of the page.\r\n            let displaceOut = drawrWidth + 1;\r\n            if (window.right_to_left()) {\r\n                displaceOut *= -1;\r\n            }\r\n            this.displace(displaceOut);\r\n        } else {\r\n            // Reset drawer displacement.\r\n            this.displace(window.scrollX);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Close all drawers.\r\n     */\r\n    static closeAllDrawers() {\r\n        drawerMap.forEach(drawerInstance => {\r\n            drawerInstance.closeDrawer();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Close all drawers except for the specified drawer.\r\n     *\r\n     * @param {module:theme_boost/drawers} comparisonInstance\r\n     */\r\n    static closeOtherDrawers(comparisonInstance) {\r\n        drawerMap.forEach(drawerInstance => {\r\n            if (drawerInstance === comparisonInstance) {\r\n                return;\r\n            }\r\n\r\n            drawerInstance.closeDrawer();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Prevent drawers from covering the focused element.\r\n     */\r\n    static preventCoveringFocusedElement() {\r\n        const currentFocus = document.activeElement;\r\n        // Focus on page layout elements should be ignored.\r\n        const pagecontent = document.querySelector(SELECTORS.PAGECONTENT);\r\n        if (!currentFocus || !pagecontent?.contains(currentFocus)) {\r\n            Drawers.displaceDrawers(window.scrollX);\r\n            return;\r\n        }\r\n        drawerMap.forEach(drawerInstance => {\r\n            drawerInstance.preventOverlap(currentFocus);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Prevent drawer from covering the content when the page content covers the full page.\r\n     *\r\n     * @param {Number} displace\r\n     */\r\n    static displaceDrawers(displace) {\r\n        drawerMap.forEach(drawerInstance => {\r\n            drawerInstance.displace(displace);\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Set the last used attribute for the last used toggle button for a drawer.\r\n *\r\n * @param {object} toggleButton The clicked button.\r\n */\r\nconst setLastUsedToggle = (toggleButton) => {\r\n    if (toggleButton.dataset.target) {\r\n        document.querySelectorAll(`${SELECTORS.BUTTONS}[data-target=\"${toggleButton.dataset.target}\"]`)\r\n        .forEach(btn => {\r\n            btn.dataset.lastused = false;\r\n        });\r\n        toggleButton.dataset.lastused = true;\r\n    }\r\n};\r\n\r\n/**\r\n * Set the focus to the last used button to open this drawer.\r\n * @param {string} target The drawer target.\r\n */\r\nconst focusLastUsedToggle = (target) => {\r\n    const lastUsedButton = document.querySelector(`${SELECTORS.BUTTONS}[data-target=\"${target}\"][data-lastused=\"true\"`);\r\n    if (lastUsedButton) {\r\n        lastUsedButton.focus();\r\n    }\r\n};\r\n\r\n/**\r\n * Register the event listeners for the drawer.\r\n *\r\n * @private\r\n */\r\nconst registerListeners = () => {\r\n    // Listen for show/hide events.\r\n    document.addEventListener('click', e => {\r\n        const toggleButton = e.target.closest(SELECTORS.TOGGLEBTN);\r\n        if (toggleButton && toggleButton.dataset.target) {\r\n            e.preventDefault();\r\n            const targetDrawer = document.getElementById(toggleButton.dataset.target);\r\n            const drawerInstance = Drawers.getDrawerInstanceForNode(targetDrawer);\r\n            setLastUsedToggle(toggleButton);\r\n\r\n            drawerInstance.toggleVisibility();\r\n        }\r\n\r\n        const openDrawerButton = e.target.closest(SELECTORS.OPENBTN);\r\n        if (openDrawerButton && openDrawerButton.dataset.target) {\r\n            e.preventDefault();\r\n            const targetDrawer = document.getElementById(openDrawerButton.dataset.target);\r\n            const drawerInstance = Drawers.getDrawerInstanceForNode(targetDrawer);\r\n            setLastUsedToggle(toggleButton);\r\n\r\n            drawerInstance.openDrawer();\r\n        }\r\n\r\n        const closeDrawerButton = e.target.closest(SELECTORS.CLOSEBTN);\r\n        if (closeDrawerButton && closeDrawerButton.dataset.target) {\r\n            e.preventDefault();\r\n            const targetDrawer = document.getElementById(closeDrawerButton.dataset.target);\r\n            const drawerInstance = Drawers.getDrawerInstanceForNode(targetDrawer);\r\n\r\n            drawerInstance.closeDrawer();\r\n            focusLastUsedToggle(closeDrawerButton.dataset.target);\r\n        }\r\n    });\r\n\r\n    // Close drawer when another drawer opens.\r\n    document.addEventListener(Drawers.eventTypes.drawerShow, e => {\r\n        if (isLarge()) {\r\n            return;\r\n        }\r\n        Drawers.closeOtherDrawers(e.detail.drawerInstance);\r\n    });\r\n\r\n    // Tooglers and openers blur listeners.\r\n    const btnSelector = `${SELECTORS.TOGGLEBTN}, ${SELECTORS.OPENBTN}, ${SELECTORS.CLOSEBTN}`;\r\n    document.addEventListener('focusout', (e) => {\r\n        const button = e.target.closest(btnSelector);\r\n        if (button?.dataset.restoreTooltipOnBlur !== undefined) {\r\n            enableButtonTooltip(button);\r\n        }\r\n    });\r\n\r\n    const closeOnResizeListener = () => {\r\n        if (isSmall()) {\r\n            let anyOpen = false;\r\n            drawerMap.forEach(drawerInstance => {\r\n                disableDrawerTooltips(drawerInstance.drawerNode);\r\n                if (drawerInstance.isOpen) {\r\n                    if (drawerInstance.closeOnResize) {\r\n                        drawerInstance.closeDrawer();\r\n                    } else {\r\n                        anyOpen = true;\r\n                    }\r\n                }\r\n            });\r\n\r\n            if (anyOpen) {\r\n                getBackdrop().then(backdrop => backdrop.show()).catch();\r\n            }\r\n        } else {\r\n            drawerMap.forEach(drawerInstance => {\r\n                enableDrawerTooltips(drawerInstance.drawerNode);\r\n            });\r\n            getBackdrop().then(backdrop => backdrop.hide()).catch();\r\n        }\r\n    };\r\n\r\n    document.addEventListener('scroll', () => {\r\n        const body = document.querySelector('body');\r\n        if (window.scrollY >= window.innerHeight) {\r\n            body.classList.add(CLASSES.SCROLLED);\r\n        } else {\r\n            body.classList.remove(CLASSES.SCROLLED);\r\n        }\r\n        // Horizontal scroll listener to displace the drawers to prevent covering\r\n        // any possible sticky content.\r\n        Drawers.displaceDrawers(window.scrollX);\r\n    });\r\n\r\n    const preventOverlap = debounce(Drawers.preventCoveringFocusedElement, 100);\r\n    document.addEventListener('focusin', preventOverlap);\r\n    document.addEventListener('focusout', preventOverlap);\r\n\r\n    window.addEventListener('resize', debounce(closeOnResizeListener, 400));\r\n};\r\n\r\nregisterListeners();\r\n\r\nconst drawers = document.querySelectorAll(SELECTORS.DRAWERS);\r\ndrawers.forEach(drawerNode => Drawers.getDrawerInstanceForNode(drawerNode));\r\n"],"names":["_getRequireWildcardCache","e","WeakMap","r","t","_interopRequireDefault","__esModule","default","_modal_backdrop","_templates","Aria","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_interopRequireWildcard","_pending","_jquery","backdropPromise","drawerMap","Map","SELECTORS","CLASSES","getDrawerZIndex","drawer","document","querySelector","parseInt","window","getComputedStyle","zIndex","getBackdrop","Templates","render","then","html","ModalBackdrop","modalBackdrop","setZIndex","getAttachmentPoint","addEventListener","preventDefault","Drawers","closeAllDrawers","catch","getDrawerOpenButton","drawerId","openButton","disableDrawerTooltips","drawerNode","id","forEach","button","disableButtonTooltip","enableOnBlur","hasAttribute","jQuery","tooltip","setAttribute","dataset","originalTitle","disabledToggle","toggle","removeAttribute","restoreTooltipOnBlur","enableButtonTooltip","boundingRect","constructor","undefined","behatFakeDrawer","this","isSmall","closeDrawer","focusOnOpenButton","updatePreferences","classList","contains","openDrawer","focusOnCloseButton","setUserPref","forceopen","hide","content","scrollTop","addInnerScrollListener","remove","isOpen","closeOnResize","static","drawerShow","drawerShown","drawerHide","drawerHidden","getDrawerInstanceForNode","dispatchEvent","eventname","cancelable","arguments","length","drawerInstance","pendingPromise","Pending","eventTypes","defaultPrevented","unhide","add","preference","setUserPreference","state","getElementById","getBoundingClientRect","backdrop","show","style","overflow","closeButton","headerContent","setTimeout","focus","resolve","toggleVisibility","displace","scrollPosition","transform","drawrWidth","offsetWidth","scrollThreshold","direction","Math","abs","sign","preventOverlap","currentFocus","element","overlapping","right","left","currentBoundingRect","bottom","top","displaceOut","right_to_left","scrollX","closeOtherDrawers","comparisonInstance","preventCoveringFocusedElement","activeElement","pagecontent","displaceDrawers","_exports","setLastUsedToggle","toggleButton","target","querySelectorAll","btn","lastused","registerListeners","closest","targetDrawer","openDrawerButton","closeDrawerButton","lastUsedButton","focusLastUsedToggle","isLarge","detail","btnSelector","body","scrollY","innerHeight","debounce","closeOnResizeListener","anyOpen"],"mappings":"0TA+B4B,SAAAA,yBAAAC,GAAA,GAAA,mBAAAC,QAAA,OAAA,KAAA,IAAAC,EAAAD,IAAAA,QAAAE,EAAAF,IAAAA,eAAAF,yBAAA,SAAAC,GAAAA,OAAAA,EAAAG,EAAAD,IAAAF,EAAA,CAAA,SAAAI,uBAAAJ,GAAAA,OAAAA,GAAAA,EAAAK,WAAAL,EAAAM,CAAAA,QAAAN,EAAA;;;;;;;qFAT5BO,gBAAAH,uBAAAG,iBACAC,WAAAJ,uBAAAI,YACAC,KAO4B,SAAAT,EAAAE,GAAAA,IAAAA,GAAAF,GAAAA,EAAAK,WAAAL,OAAAA,EAAAA,GAAAA,OAAAA,GAAAA,iBAAAA,GAAAA,mBAAAA,EAAAM,MAAAA,CAAAA,QAAAN,GAAAG,IAAAA,EAAAJ,yBAAAG,GAAA,GAAAC,GAAAA,EAAAO,IAAAV,GAAA,OAAAG,EAAAQ,IAAAX,GAAA,IAAAY,EAAA,CAAAC,UAAA,MAAAC,EAAAC,OAAAC,gBAAAD,OAAAE,yBAAA,IAAA,IAAAC,KAAAlB,EAAAkB,GAAAA,YAAAA,GAAAC,CAAAA,EAAAA,eAAAC,KAAApB,EAAAkB,GAAAG,CAAAA,IAAAA,EAAAP,EAAAC,OAAAE,yBAAAjB,EAAAkB,GAAAG,KAAAA,IAAAA,EAAAV,KAAAU,EAAAC,KAAAP,OAAAC,eAAAJ,EAAAM,EAAAG,GAAAT,EAAAM,GAAAlB,EAAAkB,GAAAN,OAAAA,EAAAN,QAAAN,EAAAG,GAAAA,EAAAmB,IAAAtB,EAAAY,GAAAA,CAAA,CAP5BW,CAAAd,MAIAe,SAAApB,uBAAAoB,UAGAC,QAAArB,uBAAAqB,SAEA,IAAIC,gBAAkB,KAEtB,MAAMC,UAAY,IAAIC,IAEhBC,kBACO,2BADPA,mBAEQ,sDAFRA,kBAGO,qDAHPA,oBAIS,iDAJTA,kBAKO,+BALPA,wBAMa,iBANbA,sBAOW,gBAPXA,wBAQa,uBAGbC,iBACQ,WADRA,aAEI,OAFJA,uBAGc,kBAgBdC,gBAAkBA,KACpB,MAAMC,OAASC,SAASC,cAAcL,mBACtC,OAAKG,OAGEG,SAASC,OAAOC,iBAAiBL,QAAQM,OAAQ,IAF7C,IAEgD,EASzDC,YAAcA,KACXb,kBACDA,gBAAkBc,WAASlC,QAACmC,OAAO,sBAAuB,CAAE,GAC3DC,MAAKC,MAAQ,IAAIC,gBAAAA,QAAcD,QAC/BD,MAAKG,gBACmBd,mBAEjBc,cAAcC,UAAUf,kBAAoB,GAEhDc,cAAcE,qBAAqBpC,IAAI,GAAGqC,iBAAiB,SAAShD,IAChEA,EAAEiD,iBACFC,QAAQC,iBAAiB,IAEtBN,iBAEVO,SAEE1B,iBAUL2B,oBAAuBC,WACzB,IAAIC,WAAatB,SAASC,cAAc,GAAGL,kCAAkCyB,cAI7E,OAHKC,aACDA,WAAatB,SAASC,cAAc,GAAGL,oCAAoCyB,eAExEC,UAAU,EASfC,sBAAyBC,aACX,CACZA,WAAWvB,cAAcL,oBACzBwB,oBAAoBI,WAAWC,KAE3BC,SAAQC,SACPA,QAGLC,qBAAqBD,OAAO,GAC9B,EAUAC,qBAAuBA,CAACD,OAAQE,gBAC9BF,OAAOG,aAAa,yBAEpB,EAAAC,QAAAA,SAAOJ,QAAQK,QAAQ,WACvBL,OAAOM,aAAa,QAASN,OAAOO,QAAQC,iBAE5CR,OAAOO,QAAQE,eAAiBT,OAAOO,QAAQG,OAC/CV,OAAOW,gBAAgB,gBAEvBT,eACAF,OAAOO,QAAQK,sBAAuB,EAC1C,EA4BEC,oBAAuBb,SAErBA,OAAOG,aAAa,yBACpB,EAAAC,QAAAA,SAAOJ,QAAQK,QAAQ,UACvBL,OAAOW,gBAAgB,UAChBX,OAAOO,QAAQE,iBACtBT,OAAOO,QAAQG,OAASV,OAAOO,QAAQE,gBACvC,EAAAL,iBAAOJ,QAAQK,kBAEZL,OAAOO,QAAQK,oBAAoB,EAuE/B,MAAMtB,QAIjBO,WAAa,KAMbiB,aAAe,KAEfC,WAAAA,CAAYlB,iBAEmCmB,IAAvCnB,WAAWU,QAAQU,kBAIvBC,KAAKrB,WAAaA,YAEd,EAAAsB,aAAAA,YACAD,KAAKE,YAAY,CAACC,mBAAmB,EAAOC,mBAAmB,IAG/DJ,KAAKrB,WAAW0B,UAAUC,SAAStD,cACnCgD,KAAKO,WAAW,CAACC,oBAAoB,EAAOC,aAAa,IACb,GAArCT,KAAKrB,WAAWU,QAAQqB,WAC1B,EAAAT,aAAOA,YACRD,KAAKO,WAAW,CAACC,oBAAoB,EAAOC,aAAa,IAG7D9E,KAAKgF,KAAKX,KAAKrB,aAIf,EAAAsB,aAAAA,YACAvB,sBAAsBsB,KAAKrB,YAlGPA,cAC5B,MAAMiC,QAAUjC,WAAWvB,cAAcL,yBACpC6D,SAGLA,QAAQ1C,iBAAiB,UAAU,KAC/BS,WAAW0B,UAAUb,OACjBxC,iBACqB,GAArB4D,QAAQC,UACX,GACH,EA2FEC,CAAuBd,KAAKrB,YAE5B9B,UAAUL,IAAImC,WAAYqB,MAE1BrB,WAAW0B,UAAUU,OAAO/D,wBAChC,CAOA,UAAIgE,GACA,OAAOhB,KAAKrB,WAAW0B,UAAUC,SAAStD,aAC9C,CAOA,iBAAIiE,GACA,QAAS5D,SAAS2C,KAAKrB,WAAWU,QAAQ4B,cAC9C,CAWAC,kBAAoB,CAQhBC,WAAY,2BASZC,YAAa,4BASbC,WAAY,2BASZC,aAAc,8BAUlB,+BAAOC,CAAyB5C,YAK5B,OAJK9B,UAAUjB,IAAI+C,aACf,IAAIP,QAAQO,YAGT9B,UAAUhB,IAAI8C,WACzB,CASA6C,aAAAA,CAAcC,WAA+B,IAApBC,WAAUC,UAAAC,OAAA,QAAA9B,IAAA6B,UAAA,IAAAA,UAAA,GAC/B,OAAO,EAAAH,kBAAAA,eACHC,UACA,CACII,eAAgB7B,MAEpBA,KAAKrB,WACL,CACI+C,uBAGZ,CAaAnB,UAAAA,GAAiE,IAAtDC,mBAACA,oBAAqB,EAAIC,YAAEA,aAAc,GAAKkB,UAAAC,OAAAD,QAAA7B,IAAA6B,UAAA7B,GAAA6B,UAAG,GAAA,GAEzD,MAAMG,eAAiB,IAAIC,SAAOvG,QAAC,4BAEnC,GADkBwE,KAAKwB,cAAcpD,QAAQ4D,WAAWb,YAAY,GACtDc,iBACV,OAIJjC,KAAKrB,WAAWvB,cAAcL,qBAAqBsD,UAAUb,OAAO,UAAU,GAC9EQ,KAAKrB,WAAWvB,cAAcL,0BAA0BsD,UAAUb,OAAO,UAAU,GAInF,IAAIf,WAAaF,oBAAoByB,KAAKrB,WAAWC,IACjDH,YAAcA,WAAWQ,aAAa,yBAEtC,EAAAC,QAAAA,SAAOT,aAAaU,QAAQ,QAGhCxD,KAAKuG,OAAOlC,KAAKrB,YACjBqB,KAAKrB,WAAW0B,UAAU8B,IAAInF,cAE9B,MAAMoF,WAAapC,KAAKrB,WAAWU,QAAQ+C,WACvCA,cAAe,EAAAnC,aAAOA,YAA4C,GAArCD,KAAKrB,WAAWU,QAAQqB,WAAmBD,cACxE,EAAA4B,YAAiBA,mBAACD,YAAY,GAGlC,MAAME,MAAQtC,KAAKrB,WAAWU,QAAQiD,MACtC,GAAIA,MAAO,CACMnF,SAASoF,eAAe,QAChClC,UAAU8B,IAAIG,MACvB,CAEAtC,KAAKJ,aAAeI,KAAKrB,WAAW6D,yBAEhC,EAAAvC,aAAAA,YACAxC,cAAcG,MAAK6E,WACfA,SAASC,OAIT,OAFoBvF,SAASoF,eAAe,QAChCI,MAAMC,SAAW,SACtBH,QAAQ,IAElBnE,QAIL,MAAMuE,YAAc7C,KAAKrB,WAAWvB,cAAcL,oBAC5C+F,cAAgB9C,KAAKrB,WAAWvB,cAAcL,yBAChDyD,oBAAsBqC,aACtB9D,qBAAqB8D,aAAa,GAEtCE,YAAW,KACPF,YAAYxC,UAAUb,OAAO,UAAU,GACvCsD,cAAczC,UAAUb,OAAO,UAAU,GACrCgB,oBACAqC,YAAYG,QAEhBlB,eAAemB,SAAS,GACzB,KAEHjD,KAAKwB,cAAcpD,QAAQ4D,WAAWZ,YAC1C,CASAlB,WAAAA,GAAuE,IAA3DC,kBAACA,mBAAoB,EAAIC,kBAAEA,mBAAoB,GAAKuB,UAAAC,OAAAD,QAAA7B,IAAA6B,UAAA7B,GAAA6B,UAAG,GAAA,GAE/D,MAAMG,eAAiB,IAAIC,SAAOvG,QAAC,6BAGnC,GADkBwE,KAAKwB,cAAcpD,QAAQ4D,WAAWX,YAAY,GACtDY,iBACV,OAIJ,MAAMY,YAAc7C,KAAKrB,WAAWvB,cAAcL,oBAClD8F,aAAaxC,UAAUb,OAAO,UAAU,GACxC,MAAMsD,cAAgB9C,KAAKrB,WAAWvB,cAAcL,yBACpD+F,eAAezC,UAAUb,OAAO,UAAU,GAEtCqD,YAAY5D,aAAa,yBAEzB,EAAAC,QAAAA,SAAO2D,cAAc1D,QAAQ,QAGjC,MAAMiD,WAAapC,KAAKrB,WAAWU,QAAQ+C,WACvCA,YAAchC,qBAAsB,EAAAH,aAAAA,aACpC,EAAAoC,YAAiBA,mBAACD,YAAY,GAGlC,MAAME,MAAQtC,KAAKrB,WAAWU,QAAQiD,MACtC,GAAIA,MAAO,CACMnF,SAASoF,eAAe,QAChClC,UAAUU,OAAOuB,MAC1B,CAEA3G,KAAKgF,KAAKX,KAAKrB,YACfqB,KAAKrB,WAAW0B,UAAUU,OAAO/D,cAEjCS,cAAcG,MAAK6E,WAGf,GAFAA,SAAS9B,QAEL,EAAAV,aAAAA,WAAW,CACS9C,SAASoF,eAAe,QAChCI,MAAMC,SAAW,SACjC,CACA,OAAOH,QAAQ,IAElBnE,QAGD,IAAIG,WAAaF,oBAAoByB,KAAKrB,WAAWC,IACjDH,YACAM,qBAAqBN,YAAY,GAErCsE,YAAW,KACHtE,YAAc0B,mBACd1B,WAAWuE,QAEflB,eAAemB,SAAS,GACzB,KAEHjD,KAAKwB,cAAcpD,QAAQ4D,WAAWV,aAC1C,CAKA4B,gBAAAA,GACQlD,KAAKrB,WAAW0B,UAAUC,SAAStD,cACnCgD,KAAKE,cAELF,KAAKO,YAEb,CAOA4C,QAAAA,CAASC,gBACL,IAAID,SAAWC,eACX3E,WAAaF,oBAAoByB,KAAKrB,WAAWC,IACrD,GAAuB,IAAnBwE,eAKA,OAJApD,KAAKrB,WAAWgE,MAAMU,UAAY,QAC9B5E,aACAA,WAAWkE,MAAMU,UAAY,KAIrC,MAAMf,MAAQtC,KAAKrB,WAAWU,SAASiD,MACjCgB,WAAatD,KAAKrB,WAAW4E,YACnC,IAAIC,gBAAkBF,WAClBG,WAAa,EACH,sBAAVnB,QACAmB,UAAY,EACZD,gBA3gBM,IA8gBNE,KAAKC,IAAIP,gBAAkBI,kBAC3BL,SAAWO,KAAKE,KAAKR,iBAAmBE,WA/gBlC,KAihBVH,UAAYM,UACZ,MAAMJ,UAAY,cAAcF,cAC5B1E,aACAA,WAAWkE,MAAMU,UAAYA,WAEjCrD,KAAKrB,WAAWgE,MAAMU,UAAYA,SACtC,CAOAQ,cAAAA,CAAeC,cAEX,IAAK9D,KAAKgB,QAA6C,qBAAnChB,KAAKrB,WAAWU,SAASiD,MACzC,OAEJ,MAAMgB,WAAatD,KAAKrB,WAAW4E,YAC7BQ,QAAUD,aAAatB,wBAQ7B,IAAIwB,YACCD,QAAQE,MA7iBH,GA6iBwBjE,KAAKJ,aAAasE,MAC/CH,QAAQG,KA9iBH,GA8iBuBlE,KAAKJ,aAAaqE,MAEnD,GAAID,YAAa,CACb,MAAMG,oBAAsBnE,KAAKrB,WAAW6D,wBAC5CwB,YACKD,QAAQK,OAAUD,oBAAoBE,KACtCN,QAAQM,IAAOF,oBAAoBC,MAE5C,CAEA,GAAIJ,YAAa,CAEb,IAAIM,YAAchB,WAAa,EAC3BhG,OAAOiH,kBACPD,cAAgB,GAEpBtE,KAAKmD,SAASmB,YAClB,MAEItE,KAAKmD,SAAS7F,OAAOkH,QAE7B,CAKA,sBAAOnG,GACHxB,UAAUgC,SAAQgD,iBACdA,eAAe3B,aAAa,GAEpC,CAOA,wBAAOuE,CAAkBC,oBACrB7H,UAAUgC,SAAQgD,iBACVA,iBAAmB6C,oBAIvB7C,eAAe3B,aAAa,GAEpC,CAKA,oCAAOyE,GACH,MAAMb,aAAe3G,SAASyH,cAExBC,YAAc1H,SAASC,cAAcL,uBACtC+G,cAAiBe,aAAavE,SAASwD,cAI5CjH,UAAUgC,SAAQgD,iBACdA,eAAegC,eAAeC,aAAa,IAJ3C1F,QAAQ0G,gBAAgBxH,OAAOkH,QAMvC,CAOA,sBAAOM,CAAgB3B,UACnBtG,UAAUgC,SAAQgD,iBACdA,eAAesB,SAASA,SAAS,GAEzC,EACH4B,SAAAvJ,QAAA4C,QAOD,MAAM4G,kBAAqBC,eACnBA,aAAa5F,QAAQ6F,SACrB/H,SAASgI,iBAAiB,GAAGpI,kCAAkCkI,aAAa5F,QAAQ6F,YACnFrG,SAAQuG,MACLA,IAAI/F,QAAQgG,UAAW,CAAK,IAEhCJ,aAAa5F,QAAQgG,UAAW,EACpC,EAmBsBC,MAEtBnI,SAASe,iBAAiB,SAAShD,IAC/B,MAAM+J,aAAe/J,EAAEgK,OAAOK,QAAQxI,qBACtC,GAAIkI,cAAgBA,aAAa5F,QAAQ6F,OAAQ,CAC7ChK,EAAEiD,iBACF,MAAMqH,aAAerI,SAASoF,eAAe0C,aAAa5F,QAAQ6F,QAC5DrD,eAAiBzD,QAAQmD,yBAAyBiE,cACxDR,kBAAkBC,cAElBpD,eAAeqB,kBACnB,CAEA,MAAMuC,iBAAmBvK,EAAEgK,OAAOK,QAAQxI,mBAC1C,GAAI0I,kBAAoBA,iBAAiBpG,QAAQ6F,OAAQ,CACrDhK,EAAEiD,iBACF,MAAMqH,aAAerI,SAASoF,eAAekD,iBAAiBpG,QAAQ6F,QAChErD,eAAiBzD,QAAQmD,yBAAyBiE,cACxDR,kBAAkBC,cAElBpD,eAAetB,YACnB,CAEA,MAAMmF,kBAAoBxK,EAAEgK,OAAOK,QAAQxI,oBAC3C,GAAI2I,mBAAqBA,kBAAkBrG,QAAQ6F,OAAQ,CACvDhK,EAAEiD,iBACF,MAAMqH,aAAerI,SAASoF,eAAemD,kBAAkBrG,QAAQ6F,QAChD9G,QAAQmD,yBAAyBiE,cAEzCtF,cAzCEgF,UACzB,MAAMS,eAAiBxI,SAASC,cAAc,GAAGL,kCAAkCmI,iCAC/ES,gBACAA,eAAe3C,OACnB,EAsCQ4C,CAAoBF,kBAAkBrG,QAAQ6F,OAClD,KAIJ/H,SAASe,iBAAiBE,QAAQ4D,WAAWb,YAAYjG,KACjD,EAAA2K,aAAAA,YAGJzH,QAAQqG,kBAAkBvJ,EAAE4K,OAAOjE,eAAe,IAItD,MAAMkE,YAAc,GAAGhJ,wBAAwBA,sBAAsBA,qBACrEI,SAASe,iBAAiB,YAAahD,IACnC,MAAM4D,OAAS5D,EAAEgK,OAAOK,QAAQQ,kBACajG,IAAzChB,QAAQO,QAAQK,sBAChBC,oBAAoBb,OACxB,IA4BJ3B,SAASe,iBAAiB,UAAU,KAChC,MAAM8H,KAAO7I,SAASC,cAAc,QAChCE,OAAO2I,SAAW3I,OAAO4I,YACzBF,KAAK3F,UAAU8B,IAAInF,kBAEnBgJ,KAAK3F,UAAUU,OAAO/D,kBAI1BoB,QAAQ0G,gBAAgBxH,OAAOkH,QAAQ,IAG3C,MAAMX,gBAAiB,EAAAsC,OAAQA,UAAC/H,QAAQuG,8BAA+B,KACvExH,SAASe,iBAAiB,UAAW2F,gBACrC1G,SAASe,iBAAiB,WAAY2F,gBAEtCvG,OAAOY,iBAAiB,UAAU,EAAAiI,OAAQA,WAzCZC,KAC1B,IAAI,EAAAnG,aAAAA,WAAW,CACX,IAAIoG,SAAU,EACdxJ,UAAUgC,SAAQgD,iBACdnD,sBAAsBmD,eAAelD,YACjCkD,eAAeb,SACXa,eAAeZ,cACfY,eAAe3B,cAEfmG,SAAU,EAElB,IAGAA,SACA5I,cAAcG,MAAK6E,UAAYA,SAASC,SAAQpE,OAExD,MACIzB,UAAUgC,SAAQgD,iBAtnBAlD,eACV,EADUA,WAunBOkD,eAAelD,YArnBjCvB,cAAcL,oBACzBwB,oBAAoBI,WAAWC,KAE3BC,SAAQC,SACPA,QAGLa,oBAAoBb,OAAO,GA8mB4B,IAEnDrB,cAAcG,MAAK6E,UAAYA,SAAS9B,SAAQrC,OACpD,GAmB8D,KAAK,EAG3EgH,GAG4E,OAD5DnI,SAASgI,iBAAiBpI,mBAClC8B,SAAQF,YAAcP,QAAQmD,yBAAyB5C,cAAaoG,SAAAvJ,OAAA"}