{"version":3,"file":"mutations.min.js","sources":["../../../src/local/courseeditor/mutations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nimport ajax from 'core/ajax';\r\nimport {getString} from \"core/str\";\r\nimport log from 'core/log';\r\nimport SRLogger from \"core/local/reactive/srlogger\";\r\n\r\n/**\r\n * Flag to determine whether the screen reader-only logger has already been set, so we only need to set it once.\r\n *\r\n * @type {boolean}\r\n */\r\nlet isLoggerSet = false;\r\n\r\n/**\r\n * Default mutation manager\r\n *\r\n * @module     core_courseformat/local/courseeditor/mutations\r\n * @class     core_courseformat/local/courseeditor/mutations\r\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nexport default class {\r\n\r\n    // All course editor mutations for Moodle 4.0 will be located in this file.\r\n\r\n    /**\r\n     * Private method to call core_courseformat_update_course webservice.\r\n     *\r\n     * @method _callEditWebservice\r\n     * @param {string} action\r\n     * @param {number} courseId\r\n     * @param {array} ids\r\n     * @param {number} targetSectionId optional target section id (for moving actions)\r\n     * @param {number} targetCmId optional target cm id (for moving actions)\r\n     */\r\n    async _callEditWebservice(action, courseId, ids, targetSectionId, targetCmId) {\r\n        const args = {\r\n            action,\r\n            courseid: courseId,\r\n            ids,\r\n        };\r\n        if (targetSectionId) {\r\n            args.targetsectionid = targetSectionId;\r\n        }\r\n        if (targetCmId) {\r\n            args.targetcmid = targetCmId;\r\n        }\r\n        let ajaxresult = await ajax.call([{\r\n            methodname: 'core_courseformat_update_course',\r\n            args,\r\n        }])[0];\r\n        return JSON.parse(ajaxresult);\r\n    }\r\n\r\n    /**\r\n     * Execute a basic section state action.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {string} action the action name\r\n     * @param {array} sectionIds the section ids\r\n     * @param {number} targetSectionId optional target section id (for moving actions)\r\n     * @param {number} targetCmId optional target cm id (for moving actions)\r\n     */\r\n    async _sectionBasicAction(stateManager, action, sectionIds, targetSectionId, targetCmId) {\r\n        const logEntry = this._getLoggerEntry(stateManager, action, sectionIds, {\r\n            targetSectionId,\r\n            targetCmId,\r\n            itemType: 'section',\r\n        });\r\n        const course = stateManager.get('course');\r\n        this.sectionLock(stateManager, sectionIds, true);\r\n        const updates = await this._callEditWebservice(\r\n            action,\r\n            course.id,\r\n            sectionIds,\r\n            targetSectionId,\r\n            targetCmId\r\n        );\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n        this.sectionLock(stateManager, sectionIds, false);\r\n        stateManager.addLoggerEntry(await logEntry);\r\n    }\r\n\r\n    /**\r\n     * Execute a basic course module state action.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {string} action the action name\r\n     * @param {array} cmIds the cm ids\r\n     * @param {number} targetSectionId optional target section id (for moving actions)\r\n     * @param {number} targetCmId optional target cm id (for moving actions)\r\n     */\r\n    async _cmBasicAction(stateManager, action, cmIds, targetSectionId, targetCmId) {\r\n        const logEntry = this._getLoggerEntry(stateManager, action, cmIds, {\r\n            targetSectionId,\r\n            targetCmId,\r\n            itemType: 'cm',\r\n        });\r\n        const course = stateManager.get('course');\r\n        this.cmLock(stateManager, cmIds, true);\r\n        const updates = await this._callEditWebservice(\r\n            action,\r\n            course.id,\r\n            cmIds,\r\n            targetSectionId,\r\n            targetCmId\r\n        );\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n        this.cmLock(stateManager, cmIds, false);\r\n        stateManager.addLoggerEntry(await logEntry);\r\n    }\r\n\r\n    /**\r\n     * Get log entry for the current action.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {string} action the action name\r\n     * @param {int[]|null} itemIds the element ids\r\n     * @param {Object|undefined} data extra params for the log entry\r\n     * @param {string|undefined} data.itemType the element type (will be taken from action if none)\r\n     * @param {int|null|undefined} data.targetSectionId the target section id\r\n     * @param {int|null|undefined} data.targetCmId the target cm id\r\n     * @param {String|null|undefined} data.component optional component (for format plugins)\r\n     * @return {Object} the log entry\r\n     */\r\n    async _getLoggerEntry(stateManager, action, itemIds, data = {}) {\r\n        if (!isLoggerSet) {\r\n            // In case the logger has not been set from init(), ensure we set the logger.\r\n            stateManager.setLogger(new SRLogger());\r\n            isLoggerSet = true;\r\n        }\r\n        const feedbackParams = {\r\n            action,\r\n            itemType: data.itemType ?? action.split('_')[0],\r\n        };\r\n        let batch = '';\r\n        if (itemIds.length > 1) {\r\n            feedbackParams.count = itemIds.length;\r\n            batch = '_batch';\r\n        } else if (itemIds.length === 1) {\r\n            const itemInfo = stateManager.get(feedbackParams.itemType, itemIds[0]);\r\n            feedbackParams.name = itemInfo.title ?? itemInfo.name;\r\n            // Apply shortener for modules like label.\r\n        }\r\n        if (data.targetSectionId) {\r\n            feedbackParams.targetSectionName = stateManager.get('section', data.targetSectionId).title;\r\n        }\r\n        if (data.targetCmId) {\r\n            feedbackParams.targetCmName = stateManager.get('cm', data.targetCmId).name;\r\n        }\r\n\r\n        const message = await getString(\r\n            `${action.toLowerCase()}_feedback${batch}`,\r\n            data.component ?? 'core_courseformat',\r\n            feedbackParams\r\n        );\r\n\r\n        return {\r\n            feedbackMessage: message,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Mutation module initialize.\r\n     *\r\n     * The reactive instance will execute this method when addMutations or setMutation is invoked.\r\n     *\r\n     * @param {StateManager} stateManager the state manager\r\n     */\r\n    init(stateManager) {\r\n        // Add a method to prepare the fields when some update is coming from the server.\r\n        stateManager.addUpdateTypes({\r\n            prepareFields: this._prepareFields,\r\n        });\r\n        // Use the screen reader-only logger (SRLogger) to handle the feedback messages from the mutations.\r\n        stateManager.setLogger(new SRLogger());\r\n        isLoggerSet = true;\r\n    }\r\n\r\n    /**\r\n     * Add default values to state elements.\r\n     *\r\n     * This method is called every time a webservice returns a update state message.\r\n     *\r\n     * @param {Object} stateManager the state manager\r\n     * @param {String} updateName the state element to update\r\n     * @param {Object} fields the new data\r\n     * @returns {Object} final fields data\r\n     */\r\n    _prepareFields(stateManager, updateName, fields) {\r\n        // Any update should unlock the element.\r\n        fields.locked = false;\r\n        return fields;\r\n    }\r\n\r\n    /**\r\n     * Hides sections.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of section ids\r\n     */\r\n    async sectionHide(stateManager, sectionIds) {\r\n        await this._sectionBasicAction(stateManager, 'section_hide', sectionIds);\r\n    }\r\n\r\n    /**\r\n     * Show sections.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of section ids\r\n     */\r\n    async sectionShow(stateManager, sectionIds) {\r\n        await this._sectionBasicAction(stateManager, 'section_show', sectionIds);\r\n    }\r\n\r\n    /**\r\n     * Show cms.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmShow(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_show', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Hide cms.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmHide(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_hide', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Stealth cms.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmStealth(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_stealth', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Duplicate course modules\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of course modules ids\r\n     * @param {number|undefined} targetSectionId the optional target sectionId\r\n     * @param {number|undefined} targetCmId the target course module id\r\n     */\r\n    async cmDuplicate(stateManager, cmIds, targetSectionId, targetCmId) {\r\n        const logEntry = this._getLoggerEntry(stateManager, 'cm_duplicate', cmIds);\r\n        const course = stateManager.get('course');\r\n        // Lock all target sections.\r\n        const sectionIds = new Set();\r\n        if (targetSectionId) {\r\n            sectionIds.add(targetSectionId);\r\n        } else {\r\n            cmIds.forEach((cmId) => {\r\n                const cm = stateManager.get('cm', cmId);\r\n                sectionIds.add(cm.sectionid);\r\n            });\r\n        }\r\n        this.sectionLock(stateManager, Array.from(sectionIds), true);\r\n\r\n        const updates = await this._callEditWebservice('cm_duplicate', course.id, cmIds, targetSectionId, targetCmId);\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n\r\n        this.sectionLock(stateManager, Array.from(sectionIds), false);\r\n        stateManager.addLoggerEntry(await logEntry);\r\n    }\r\n\r\n    /**\r\n     * Move course modules to specific course location.\r\n     *\r\n     * Note that one of targetSectionId or targetCmId should be provided in order to identify the\r\n     * new location:\r\n     *  - targetCmId: the activities will be located avobe the target cm. The targetSectionId\r\n     *                value will be ignored in this case.\r\n     *  - targetSectionId: the activities will be appended to the section. In this case\r\n     *                     targetSectionId should not be present.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmids the list of cm ids to move\r\n     * @param {number} targetSectionId the target section id\r\n     * @param {number} targetCmId the target course module id\r\n     */\r\n    async cmMove(stateManager, cmids, targetSectionId, targetCmId) {\r\n        if (!targetSectionId && !targetCmId) {\r\n            throw new Error(`Mutation cmMove requires targetSectionId or targetCmId`);\r\n        }\r\n        const course = stateManager.get('course');\r\n        this.cmLock(stateManager, cmids, true);\r\n        const updates = await this._callEditWebservice('cm_move', course.id, cmids, targetSectionId, targetCmId);\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n        this.cmLock(stateManager, cmids, false);\r\n    }\r\n\r\n    /**\r\n     * Move course modules to specific course location.\r\n     *\r\n     * @deprecated since Moodle 4.4 MDL-77038.\r\n     * @todo MDL-80116 This will be deleted in Moodle 4.8.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of section ids to move\r\n     * @param {number} targetSectionId the target section id\r\n     */\r\n    async sectionMove(stateManager, sectionIds, targetSectionId) {\r\n        log.debug('sectionMove() is deprecated. Use sectionMoveAfter() instead');\r\n        if (!targetSectionId) {\r\n            throw new Error(`Mutation sectionMove requires targetSectionId`);\r\n        }\r\n        const course = stateManager.get('course');\r\n        this.sectionLock(stateManager, sectionIds, true);\r\n        const updates = await this._callEditWebservice('section_move', course.id, sectionIds, targetSectionId);\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n        this.sectionLock(stateManager, sectionIds, false);\r\n    }\r\n\r\n    /**\r\n     * Move course modules after a specific course location.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of section ids to move\r\n     * @param {number} targetSectionId the target section id\r\n     */\r\n    async sectionMoveAfter(stateManager, sectionIds, targetSectionId) {\r\n        if (!targetSectionId) {\r\n            throw new Error(`Mutation sectionMoveAfter requires targetSectionId`);\r\n        }\r\n        const course = stateManager.get('course');\r\n        this.sectionLock(stateManager, sectionIds, true);\r\n        const updates = await this._callEditWebservice('section_move_after', course.id, sectionIds, targetSectionId);\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n        this.sectionLock(stateManager, sectionIds, false);\r\n    }\r\n\r\n    /**\r\n     * Add a new section to a specific course location.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {number} targetSectionId optional the target section id\r\n     */\r\n    async addSection(stateManager, targetSectionId) {\r\n        if (!targetSectionId) {\r\n            targetSectionId = 0;\r\n        }\r\n        const course = stateManager.get('course');\r\n        const updates = await this._callEditWebservice('section_add', course.id, [], targetSectionId);\r\n        stateManager.processUpdates(updates);\r\n    }\r\n\r\n    /**\r\n     * Delete sections.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of course modules ids\r\n     */\r\n    async sectionDelete(stateManager, sectionIds) {\r\n        const course = stateManager.get('course');\r\n        const updates = await this._callEditWebservice('section_delete', course.id, sectionIds);\r\n        this.bulkReset(stateManager);\r\n        stateManager.processUpdates(updates);\r\n    }\r\n\r\n    /**\r\n     * Delete cms.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of section ids\r\n     */\r\n    async cmDelete(stateManager, cmIds) {\r\n        const course = stateManager.get('course');\r\n        this.cmLock(stateManager, cmIds, true);\r\n        const updates = await this._callEditWebservice('cm_delete', course.id, cmIds);\r\n        this.bulkReset(stateManager);\r\n        this.cmLock(stateManager, cmIds, false);\r\n        stateManager.processUpdates(updates);\r\n    }\r\n\r\n    /**\r\n     * Mark or unmark course modules as dragging.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of course modules ids\r\n     * @param {bool} dragValue the new dragging value\r\n     */\r\n    cmDrag(stateManager, cmIds, dragValue) {\r\n        this.setPageItem(stateManager);\r\n        this._setElementsValue(stateManager, 'cm', cmIds, 'dragging', dragValue);\r\n    }\r\n\r\n    /**\r\n     * Mark or unmark course sections as dragging.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of section ids\r\n     * @param {bool} dragValue the new dragging value\r\n     */\r\n    sectionDrag(stateManager, sectionIds, dragValue) {\r\n        this.setPageItem(stateManager);\r\n        this._setElementsValue(stateManager, 'section', sectionIds, 'dragging', dragValue);\r\n    }\r\n\r\n    /**\r\n     * Mark or unmark course modules as complete.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of course modules ids\r\n     * @param {bool} complete the new completion value\r\n     */\r\n    cmCompletion(stateManager, cmIds, complete) {\r\n        const newValue = (complete) ? 1 : 0;\r\n        this._setElementsValue(stateManager, 'cm', cmIds, 'completionstate', newValue);\r\n    }\r\n\r\n    /**\r\n     * Move cms to the right: indent = 1.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmMoveRight(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_moveright', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Move cms to the left: indent = 0.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmMoveLeft(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_moveleft', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Set cms group mode to NOGROUPS.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmNoGroups(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_nogroups', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Set cms group mode to VISIBLEGROUPS.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmVisibleGroups(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_visiblegroups', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Set cms group mode to SEPARATEGROUPS.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    async cmSeparateGroups(stateManager, cmIds) {\r\n        await this._cmBasicAction(stateManager, 'cm_separategroups', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Lock or unlock course modules.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of course modules ids\r\n     * @param {bool} lockValue the new locked value\r\n     */\r\n    cmLock(stateManager, cmIds, lockValue) {\r\n        this._setElementsValue(stateManager, 'cm', cmIds, 'locked', lockValue);\r\n    }\r\n\r\n    /**\r\n     * Lock or unlock course sections.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of section ids\r\n     * @param {bool} lockValue the new locked value\r\n     */\r\n    sectionLock(stateManager, sectionIds, lockValue) {\r\n        this._setElementsValue(stateManager, 'section', sectionIds, 'locked', lockValue);\r\n    }\r\n\r\n    _setElementsValue(stateManager, name, ids, fieldName, newValue) {\r\n        stateManager.setReadOnly(false);\r\n        ids.forEach((id) => {\r\n            const element = stateManager.get(name, id);\r\n            if (element) {\r\n                element[fieldName] = newValue;\r\n            }\r\n        });\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Set the page current item.\r\n     *\r\n     * Only one element of the course state can be the page item at a time.\r\n     *\r\n     * There are several actions that can alter the page current item. For example, when the user is in an activity\r\n     * page, the page item is always the activity one. However, in a course page, when the user scrolls to an element,\r\n     * this element get the page item.\r\n     *\r\n     * If the page item is static means that it is not meant to change. This is important because\r\n     * static page items has some special logic. For example, if a cm is the static page item\r\n     * and it is inside a collapsed section, the course index will expand the section to make it visible.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {String|undefined} type the element type (section or cm). Undefined will remove the current page item.\r\n     * @param {Number|undefined} id the element id\r\n     * @param {boolean|undefined} isStatic if the page item is static\r\n     */\r\n    setPageItem(stateManager, type, id, isStatic) {\r\n        let newPageItem;\r\n        if (type !== undefined) {\r\n            newPageItem = stateManager.get(type, id);\r\n            if (!newPageItem) {\r\n                return;\r\n            }\r\n        }\r\n        stateManager.setReadOnly(false);\r\n        // Remove the current page item.\r\n        const course = stateManager.get('course');\r\n        course.pageItem = null;\r\n        // Save the new page item.\r\n        if (newPageItem) {\r\n            course.pageItem = {\r\n                id,\r\n                type,\r\n                sectionId: (type == 'section') ? newPageItem.id : newPageItem.sectionid,\r\n                isStatic,\r\n            };\r\n        }\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Unlock all course elements.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     */\r\n    unlockAll(stateManager) {\r\n        const state = stateManager.state;\r\n        stateManager.setReadOnly(false);\r\n        state.section.forEach((section) => {\r\n            section.locked = false;\r\n        });\r\n        state.cm.forEach((cm) => {\r\n            cm.locked = false;\r\n        });\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Update the course index collapsed attribute of some sections.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the affected section ids\r\n     * @param {boolean} collapsed the new collapsed value\r\n     */\r\n    async sectionIndexCollapsed(stateManager, sectionIds, collapsed) {\r\n        const affectedSections = this._updateStateSectionPreference(stateManager, 'indexcollapsed', sectionIds, collapsed);\r\n        if (!affectedSections) {\r\n            return;\r\n        }\r\n        const course = stateManager.get('course');\r\n        let actionName = 'section_index_collapsed';\r\n        if (!collapsed) {\r\n            actionName = 'section_index_expanded';\r\n        }\r\n        await this._callEditWebservice(actionName, course.id, affectedSections);\r\n    }\r\n\r\n    /**\r\n     * Update the course index collapsed attribute of all sections.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {boolean} collapsed the new collapsed value\r\n     */\r\n    async allSectionsIndexCollapsed(stateManager, collapsed) {\r\n        const sectionIds = stateManager.getIds('section');\r\n        this.sectionIndexCollapsed(stateManager, sectionIds, collapsed);\r\n    }\r\n\r\n    /**\r\n     * Update the course content collapsed attribute of some sections.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the affected section ids\r\n     * @param {boolean} collapsed the new collapsed value\r\n     */\r\n    async sectionContentCollapsed(stateManager, sectionIds, collapsed) {\r\n        const affectedSections = this._updateStateSectionPreference(stateManager, 'contentcollapsed', sectionIds, collapsed);\r\n        if (!affectedSections) {\r\n            return;\r\n        }\r\n        const course = stateManager.get('course');\r\n        let actionName = 'section_content_collapsed';\r\n        if (!collapsed) {\r\n            actionName = 'section_content_expanded';\r\n        }\r\n        await this._callEditWebservice(actionName, course.id, affectedSections);\r\n    }\r\n\r\n    /**\r\n     * Private batch update for a section preference attribute.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {string} preferenceName the preference name\r\n     * @param {array} sectionIds the affected section ids\r\n     * @param {boolean} preferenceValue the new preferenceValue value\r\n     * @return {Number[]|null} sections ids with the preference value true or null if no update is required\r\n     */\r\n    _updateStateSectionPreference(stateManager, preferenceName, sectionIds, preferenceValue) {\r\n        stateManager.setReadOnly(false);\r\n        const affectedSections = [];\r\n        // Check if we need to update preferences.\r\n        sectionIds.forEach(sectionId => {\r\n            const section = stateManager.get('section', sectionId);\r\n            if (section === undefined) {\r\n                stateManager.setReadOnly(true);\r\n                return null;\r\n            }\r\n            const newValue = preferenceValue ?? section[preferenceName];\r\n            if (section[preferenceName] != newValue) {\r\n                section[preferenceName] = newValue;\r\n                affectedSections.push(section.id);\r\n            }\r\n        });\r\n        stateManager.setReadOnly(true);\r\n        return affectedSections;\r\n    }\r\n\r\n    /**\r\n     * Enable/disable bulk editing.\r\n     *\r\n     * Note: reenabling the bulk will clean the current selection.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {Boolean} enabled the new bulk state.\r\n     */\r\n    bulkEnable(stateManager, enabled) {\r\n        const state = stateManager.state;\r\n        stateManager.setReadOnly(false);\r\n        state.bulk.enabled = enabled;\r\n        state.bulk.selectedType = '';\r\n        state.bulk.selection = [];\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Reset the current selection.\r\n     * @param {StateManager} stateManager the current state manager\r\n     */\r\n    bulkReset(stateManager) {\r\n        const state = stateManager.state;\r\n        stateManager.setReadOnly(false);\r\n        state.bulk.selectedType = '';\r\n        state.bulk.selection = [];\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Select a list of cms.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    cmSelect(stateManager, cmIds) {\r\n        this._addIdsToSelection(stateManager, 'cm', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Unselect a list of cms.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} cmIds the list of cm ids\r\n     */\r\n    cmUnselect(stateManager, cmIds) {\r\n        this._removeIdsFromSelection(stateManager, 'cm', cmIds);\r\n    }\r\n\r\n    /**\r\n     * Select a list of sections.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of cm ids\r\n     */\r\n    sectionSelect(stateManager, sectionIds) {\r\n        this._addIdsToSelection(stateManager, 'section', sectionIds);\r\n    }\r\n\r\n    /**\r\n     * Unselect a list of sections.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {array} sectionIds the list of cm ids\r\n     */\r\n    sectionUnselect(stateManager, sectionIds) {\r\n        this._removeIdsFromSelection(stateManager, 'section', sectionIds);\r\n    }\r\n\r\n    /**\r\n     * Add some ids to the current bulk selection.\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {String} typeName the type name (section/cm)\r\n     * @param {array} ids the list of ids\r\n     */\r\n    _addIdsToSelection(stateManager, typeName, ids) {\r\n        const bulk = stateManager.state.bulk;\r\n        if (!bulk?.enabled) {\r\n            throw new Error(`Bulk is not enabled`);\r\n        }\r\n        if (bulk?.selectedType !== \"\" && bulk?.selectedType !== typeName) {\r\n            throw new Error(`Cannot add ${typeName} to the current selection`);\r\n        }\r\n\r\n        // Stored ids are strings for compatability with HTML data attributes.\r\n        ids = ids.map(value => value.toString());\r\n\r\n        stateManager.setReadOnly(false);\r\n        bulk.selectedType = typeName;\r\n        const newSelection = new Set([...bulk.selection, ...ids]);\r\n        bulk.selection = [...newSelection];\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Remove some ids to the current bulk selection.\r\n     *\r\n     * The method resets the selection type if the current selection is empty.\r\n     *\r\n     * @param {StateManager} stateManager the current state manager\r\n     * @param {String} typeName the type name (section/cm)\r\n     * @param {array} ids the list of ids\r\n     */\r\n    _removeIdsFromSelection(stateManager, typeName, ids) {\r\n        const bulk = stateManager.state.bulk;\r\n        if (!bulk?.enabled) {\r\n            throw new Error(`Bulk is not enabled`);\r\n        }\r\n        if (bulk?.selectedType !== \"\" && bulk?.selectedType !== typeName) {\r\n            throw new Error(`Cannot remove ${typeName} from the current selection`);\r\n        }\r\n\r\n        // Stored ids are strings for compatability with HTML data attributes.\r\n        ids = ids.map(value => value.toString());\r\n\r\n        stateManager.setReadOnly(false);\r\n        const IdsToFilter = new Set(ids);\r\n        bulk.selection = bulk.selection.filter(current => !IdsToFilter.has(current));\r\n        if (bulk.selection.length === 0) {\r\n            bulk.selectedType = '';\r\n        }\r\n        stateManager.setReadOnly(true);\r\n    }\r\n\r\n    /**\r\n     * Get updated state data related to some cm ids.\r\n     *\r\n     * @method cmState\r\n     * @param {StateManager} stateManager the current state\r\n     * @param {array} cmids the list of cm ids to update\r\n     */\r\n    async cmState(stateManager, cmids) {\r\n        this.cmLock(stateManager, cmids, true);\r\n        const course = stateManager.get('course');\r\n        const updates = await this._callEditWebservice('cm_state', course.id, cmids);\r\n        stateManager.processUpdates(updates);\r\n        this.cmLock(stateManager, cmids, false);\r\n    }\r\n\r\n    /**\r\n     * Get updated state data related to some section ids.\r\n     *\r\n     * @method sectionState\r\n     * @param {StateManager} stateManager the current state\r\n     * @param {array} sectionIds the list of section ids to update\r\n     */\r\n    async sectionState(stateManager, sectionIds) {\r\n        this.sectionLock(stateManager, sectionIds, true);\r\n        const course = stateManager.get('course');\r\n        const updates = await this._callEditWebservice('section_state', course.id, sectionIds);\r\n        stateManager.processUpdates(updates);\r\n        this.sectionLock(stateManager, sectionIds, false);\r\n    }\r\n\r\n    /**\r\n     * Get the full updated state data of the course.\r\n     *\r\n     * @param {StateManager} stateManager the current state\r\n     */\r\n    async courseState(stateManager) {\r\n        const course = stateManager.get('course');\r\n        const updates = await this._callEditWebservice('course_state', course.id);\r\n        stateManager.processUpdates(updates);\r\n    }\r\n\r\n}\r\n"],"names":["_interopRequireDefault","e","__esModule","default","_ajax","_log","_srlogger","isLoggerSet","_exports","_callEditWebservice","action","courseId","ids","targetSectionId","targetCmId","args","courseid","targetsectionid","targetcmid","ajaxresult","ajax","call","methodname","JSON","parse","_sectionBasicAction","stateManager","sectionIds","logEntry","this","_getLoggerEntry","itemType","course","get","sectionLock","updates","id","bulkReset","processUpdates","addLoggerEntry","_cmBasicAction","cmIds","cmLock","itemIds","data","arguments","length","undefined","setLogger","SRLogger","feedbackParams","split","batch","count","itemInfo","name","title","targetSectionName","targetCmName","feedbackMessage","getString","toLowerCase","component","init","addUpdateTypes","prepareFields","_prepareFields","updateName","fields","locked","sectionHide","sectionShow","cmShow","cmHide","cmStealth","cmDuplicate","Set","add","forEach","cmId","cm","sectionid","Array","from","cmMove","cmids","Error","sectionMove","log","debug","sectionMoveAfter","addSection","sectionDelete","cmDelete","cmDrag","dragValue","setPageItem","_setElementsValue","sectionDrag","cmCompletion","complete","newValue","cmMoveRight","cmMoveLeft","cmNoGroups","cmVisibleGroups","cmSeparateGroups","lockValue","fieldName","setReadOnly","element","type","isStatic","newPageItem","pageItem","sectionId","unlockAll","state","section","sectionIndexCollapsed","collapsed","affectedSections","_updateStateSectionPreference","actionName","allSectionsIndexCollapsed","getIds","sectionContentCollapsed","preferenceName","preferenceValue","push","bulkEnable","enabled","bulk","selectedType","selection","cmSelect","_addIdsToSelection","cmUnselect","_removeIdsFromSelection","sectionSelect","sectionUnselect","typeName","map","value","toString","newSelection","IdsToFilter","filter","current","has","cmState","sectionState","courseState"],"mappings":"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"}