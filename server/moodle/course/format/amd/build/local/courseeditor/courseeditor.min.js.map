{"version":3,"file":"courseeditor.min.js","sources":["../../../src/local/courseeditor/courseeditor.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nimport {getString} from 'core/str';\r\nimport {Reactive} from 'core/reactive';\r\nimport notification from 'core/notification';\r\nimport Exporter from 'core_courseformat/local/courseeditor/exporter';\r\nimport log from 'core/log';\r\nimport ajax from 'core/ajax';\r\nimport * as Storage from 'core/sessionstorage';\r\nimport {uploadFilesToCourse} from 'core_courseformat/local/courseeditor/fileuploader';\r\n\r\n/**\r\n * Main course editor module.\r\n *\r\n * All formats can register new components on this object to create new reactive\r\n * UI components that watch the current course state.\r\n *\r\n * @module     core_courseformat/local/courseeditor/courseeditor\r\n * @class     core_courseformat/local/courseeditor/courseeditor\r\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\nexport default class extends Reactive {\r\n\r\n    /**\r\n     * The current state cache key\r\n     *\r\n     * The state cache is considered dirty if the state changes from the last page or\r\n     * if the page has editing mode on.\r\n     *\r\n     * @attribute stateKey\r\n     * @type number|null\r\n     * @default 1\r\n     * @package\r\n     */\r\n    stateKey = 1;\r\n\r\n    /**\r\n     * The current page section return\r\n     * @attribute sectionReturn\r\n     * @type number\r\n     * @default null\r\n     */\r\n    sectionReturn = null;\r\n\r\n    /**\r\n     * Set up the course editor when the page is ready.\r\n     *\r\n     * The course can only be loaded once per instance. Otherwise an error is thrown.\r\n     *\r\n     * The backend can inform the module of the current state key. This key changes every time some\r\n     * update in the course affect the current user state. Some examples are:\r\n     *  - The course content has been edited\r\n     *  - The user marks some activity as completed\r\n     *  - The user collapses or uncollapses a section (it is stored as a user preference)\r\n     *\r\n     * @param {number} courseId course id\r\n     * @param {string} serverStateKey the current backend course cache reference\r\n     */\r\n    async loadCourse(courseId, serverStateKey) {\r\n\r\n        if (this.courseId) {\r\n            throw new Error(`Cannot load ${courseId}, course already loaded with id ${this.courseId}`);\r\n        }\r\n\r\n        if (!serverStateKey) {\r\n            // The server state key is not provided, we use a invalid statekey to force reloading.\r\n            serverStateKey = `invalidStateKey_${Date.now()}`;\r\n        }\r\n\r\n        // Default view format setup.\r\n        this._editing = false;\r\n        this._supportscomponents = false;\r\n        this._fileHandlers = null;\r\n\r\n        this.courseId = courseId;\r\n\r\n        let stateData;\r\n\r\n        const storeStateKey = Storage.get(`course/${courseId}/stateKey`);\r\n        try {\r\n            // Check if the backend state key is the same we have in our session storage.\r\n            if (!this.isEditing && serverStateKey == storeStateKey) {\r\n                stateData = JSON.parse(Storage.get(`course/${courseId}/staticState`));\r\n            }\r\n            if (!stateData) {\r\n                stateData = await this.getServerCourseState();\r\n            }\r\n\r\n        } catch (error) {\r\n            log.error(\"EXCEPTION RAISED WHILE INIT COURSE EDITOR\");\r\n            log.error(error);\r\n            return;\r\n        }\r\n\r\n        // The bulk editing only applies to the frontend and the state data is not created in the backend.\r\n        stateData.bulk = {\r\n            enabled: false,\r\n            selectedType: '',\r\n            selection: [],\r\n        };\r\n\r\n        this.setInitialState(stateData);\r\n\r\n        // In editing mode, the session cache is considered dirty always.\r\n        if (this.isEditing) {\r\n            this.stateKey = null;\r\n        } else {\r\n            // Check if the last state is the same as the cached one.\r\n            const newState = JSON.stringify(stateData);\r\n            const previousState = Storage.get(`course/${courseId}/staticState`);\r\n            if (previousState !== newState || storeStateKey !== serverStateKey) {\r\n                Storage.set(`course/${courseId}/staticState`, newState);\r\n                Storage.set(`course/${courseId}/stateKey`, stateData?.course?.statekey ?? serverStateKey);\r\n            }\r\n            this.stateKey = Storage.get(`course/${courseId}/stateKey`);\r\n        }\r\n\r\n        this._loadFileHandlers();\r\n\r\n        this._pageAnchorCmInfo = this._scanPageAnchorCmInfo();\r\n    }\r\n\r\n    /**\r\n     * Load the file hanlders promise.\r\n     */\r\n    _loadFileHandlers() {\r\n        // Load the course file extensions.\r\n        this._fileHandlersPromise = new Promise((resolve) => {\r\n            if (!this.isEditing) {\r\n                resolve([]);\r\n                return;\r\n            }\r\n            // Check the cache.\r\n            const handlersCacheKey = `course/${this.courseId}/fileHandlers`;\r\n\r\n            const cacheValue = Storage.get(handlersCacheKey);\r\n            if (cacheValue) {\r\n                try {\r\n                    const cachedHandlers = JSON.parse(cacheValue);\r\n                    resolve(cachedHandlers);\r\n                    return;\r\n                } catch (error) {\r\n                    log.error(\"ERROR PARSING CACHED FILE HANDLERS\");\r\n                }\r\n            }\r\n            // Call file handlers webservice.\r\n            ajax.call([{\r\n                methodname: 'core_courseformat_file_handlers',\r\n                args: {\r\n                    courseid: this.courseId,\r\n                }\r\n            }])[0].then((handlers) => {\r\n                Storage.set(handlersCacheKey, JSON.stringify(handlers));\r\n                resolve(handlers);\r\n                return;\r\n            }).catch(error => {\r\n                log.error(error);\r\n                resolve([]);\r\n                return;\r\n            });\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Setup the current view settings\r\n     *\r\n     * @param {Object} setup format, page and course settings\r\n     * @param {boolean} setup.editing if the page is in edit mode\r\n     * @param {boolean} setup.supportscomponents if the format supports components for content\r\n     * @param {string} setup.cacherev the backend cached state revision\r\n     * @param {Array} setup.overriddenStrings optional overridden strings\r\n     */\r\n    setViewFormat(setup) {\r\n        this._editing = setup.editing ?? false;\r\n        this._supportscomponents = setup.supportscomponents ?? false;\r\n        const overriddenStrings = setup.overriddenStrings ?? [];\r\n        this._overriddenStrings = overriddenStrings.reduce(\r\n            (indexed, currentValue) => indexed.set(currentValue.key, currentValue),\r\n            new Map()\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Execute a get string for a possible format overriden editor string.\r\n     *\r\n     * Return the proper getString promise for an editor string using the core_courseformat\r\n     * of the format_PLUGINNAME compoment depending on the current view format setup.\r\n     * @param {String} key the string key\r\n     * @param {string|undefined} param The param for variable expansion in the string.\r\n     * @returns {Promise<String>} a getString promise\r\n     */\r\n    getFormatString(key, param) {\r\n        if (this._overriddenStrings.has(key)) {\r\n            const override = this._overriddenStrings.get(key);\r\n            return getString(key, override.component ?? 'core_courseformat', param);\r\n        }\r\n        // All format overridable strings are from core_courseformat lang file.\r\n        return getString(key, 'core_courseformat', param);\r\n    }\r\n\r\n    /**\r\n     * Load the current course state from the server.\r\n     *\r\n     * @returns {Object} the current course state\r\n     */\r\n    async getServerCourseState() {\r\n        const courseState = await ajax.call([{\r\n            methodname: 'core_courseformat_get_state',\r\n            args: {\r\n                courseid: this.courseId,\r\n            }\r\n        }])[0];\r\n\r\n        const stateData = JSON.parse(courseState);\r\n\r\n        return {\r\n            course: {},\r\n            section: [],\r\n            cm: [],\r\n            ...stateData,\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Return the current edit mode.\r\n     *\r\n     * Components should use this method to check if edit mode is active.\r\n     *\r\n     * @return {boolean} if edit is enabled\r\n     */\r\n    get isEditing() {\r\n        return this._editing ?? false;\r\n    }\r\n\r\n    /**\r\n     * Return a data exporter to transform state part into mustache contexts.\r\n     *\r\n     * @return {Exporter} the exporter class\r\n     */\r\n    getExporter() {\r\n        return new Exporter(this);\r\n    }\r\n\r\n    /**\r\n     * Return if the current course support components to refresh the content.\r\n     *\r\n     * @returns {boolean} if the current content support components\r\n     */\r\n    get supportComponents() {\r\n        return this._supportscomponents ?? false;\r\n    }\r\n\r\n    /**\r\n     * Return the course file handlers promise.\r\n     * @returns {Promise} the promise for file handlers.\r\n     */\r\n    async getFileHandlersPromise() {\r\n        return this._fileHandlersPromise ?? [];\r\n    }\r\n\r\n    /**\r\n     * Upload a file list to the course.\r\n     *\r\n     * This method is a wrapper to the course file uploader.\r\n     *\r\n     * @param {number} sectionId the section id\r\n     * @param {number} sectionNum the section number\r\n     * @param {Array} files and array of files\r\n     * @return {Promise} the file queue promise\r\n     */\r\n    uploadFiles(sectionId, sectionNum, files) {\r\n        return uploadFilesToCourse(this.courseId, sectionId, sectionNum, files);\r\n    }\r\n\r\n    /**\r\n     * Get a value from the course editor static storage if any.\r\n     *\r\n     * The course editor static storage uses the sessionStorage to store values from the\r\n     * components. This is used to prevent unnecesary template loadings on every page. However,\r\n     * the storage does not work if no sessionStorage can be used (in debug mode for example),\r\n     * if the page is in editing mode or if the initial state change from the last page.\r\n     *\r\n     * @param {string} key the key to get\r\n     * @return {boolean|string} the storage value or false if cannot be loaded\r\n     */\r\n    getStorageValue(key) {\r\n        if (this.isEditing || !this.stateKey) {\r\n            return false;\r\n        }\r\n        const dataJson = Storage.get(`course/${this.courseId}/${key}`);\r\n        if (!dataJson) {\r\n            return false;\r\n        }\r\n        // Check the stateKey.\r\n        try {\r\n            const data = JSON.parse(dataJson);\r\n            if (data?.stateKey !== this.stateKey) {\r\n                return false;\r\n            }\r\n            return data.value;\r\n        } catch (error) {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Stores a value into the course editor static storage if available\r\n     *\r\n     * @param {String} key the key to store\r\n     * @param {*} value the value to store (must be compatible with JSON,stringify)\r\n     * @returns {boolean} true if the value is stored\r\n     */\r\n    setStorageValue(key, value) {\r\n        // Values cannot be stored on edit mode.\r\n        if (this.isEditing) {\r\n            return false;\r\n        }\r\n        const data = {\r\n            stateKey: this.stateKey,\r\n            value,\r\n        };\r\n        return Storage.set(`course/${this.courseId}/${key}`, JSON.stringify(data));\r\n    }\r\n\r\n    /**\r\n     * Convert a file dragging event into a proper dragging file list.\r\n     * @param {DataTransfer} dataTransfer the event to convert\r\n     * @return {Array} of file list info.\r\n     */\r\n    getFilesDraggableData(dataTransfer) {\r\n        const exporter = this.getExporter();\r\n        return exporter.fileDraggableData(this.state, dataTransfer);\r\n    }\r\n\r\n    /**\r\n     * Dispatch a change in the state.\r\n     *\r\n     * Usually reactive modules throw an error directly to the components when something\r\n     * goes wrong. However, course editor can directly display a notification.\r\n     *\r\n     * @method dispatch\r\n     * @param {mixed} args any number of params the mutation needs.\r\n     */\r\n    async dispatch(...args) {\r\n        try {\r\n            await super.dispatch(...args);\r\n        } catch (error) {\r\n            // Display error modal.\r\n            notification.exception(error);\r\n            // Force unlock all elements.\r\n            super.dispatch('unlockAll');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate the cm info from the current page anchor.\r\n     *\r\n     * @returns {Object|null} the cm info or null if not found.\r\n     */\r\n    _scanPageAnchorCmInfo() {\r\n        const anchor = new URL(window.location.href).hash;\r\n        if (!anchor.startsWith('#module-')) {\r\n            return null;\r\n        }\r\n        // The anchor is always #module-CMID.\r\n        const cmid = anchor.split('-')[1];\r\n        return this.stateManager.get('cm', parseInt(cmid));\r\n    }\r\n\r\n    /**\r\n     * Return the current page anchor cm info.\r\n     */\r\n    getPageAnchorCmInfo() {\r\n        return this._pageAnchorCmInfo;\r\n    }\r\n}\r\n"],"names":["_getRequireWildcardCache","e","WeakMap","r","t","_interopRequireDefault","__esModule","default","_notification","_exporter","_log","_ajax","Storage","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","hasOwnProperty","call","i","set","_interopRequireWildcard","_default","Reactive","stateKey","sectionReturn","loadCourse","courseId","serverStateKey","this","Error","stateData","Date","now","_editing","_supportscomponents","_fileHandlers","storeStateKey","isEditing","JSON","parse","getServerCourseState","error","log","bulk","enabled","selectedType","selection","setInitialState","newState","stringify","course","statekey","_loadFileHandlers","_pageAnchorCmInfo","_scanPageAnchorCmInfo","_fileHandlersPromise","Promise","resolve","handlersCacheKey","cacheValue","cachedHandlers","ajax","methodname","args","courseid","then","handlers","catch","setViewFormat","setup","editing","supportscomponents","overriddenStrings","_overriddenStrings","reduce","indexed","currentValue","key","Map","getFormatString","param","override","getString","component","courseState","section","cm","getExporter","Exporter","supportComponents","getFileHandlersPromise","uploadFiles","sectionId","sectionNum","files","uploadFilesToCourse","getStorageValue","dataJson","data","value","setStorageValue","getFilesDraggableData","dataTransfer","fileDraggableData","state","dispatch","super","arguments","notification","exception","anchor","URL","window","location","href","hash","startsWith","cmid","split","stateManager","parseInt","getPageAnchorCmInfo","_exports"],"mappings":"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"}