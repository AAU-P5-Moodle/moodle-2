{"version":3,"file":"fileuploader.min.js","sources":["../../../src/local/courseeditor/fileuploader.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\r\n//\r\n// Moodle is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n//\r\n// Moodle is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n//\r\n// You should have received a copy of the GNU General Public License\r\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n/**\r\n * The course file uploader.\r\n *\r\n * This module is used to upload files directly into the course.\r\n *\r\n * @module     core_courseformat/local/courseeditor/fileuploader\r\n * @copyright  2022 Ferran Recio <ferran@moodle.com>\r\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\r\n */\r\n\r\n/**\r\n * @typedef {Object} Handler\r\n * @property {String} extension the handled extension or * for any\r\n * @property {String} message the handler message\r\n * @property {String} module the module name\r\n */\r\n\r\nimport Config from 'core/config';\r\nimport ModalSaveCancel from 'core/modal_save_cancel';\r\nimport ModalEvents from 'core/modal_events';\r\nimport Templates from 'core/templates';\r\nimport {getFirst} from 'core/normalise';\r\nimport {prefetchStrings} from 'core/prefetch';\r\nimport {getString, getStrings} from 'core/str';\r\nimport {getCourseEditor} from 'core_courseformat/courseeditor';\r\nimport {processMonitor} from 'core/process_monitor';\r\nimport {debounce} from 'core/utils';\r\n\r\n// Uploading url.\r\nconst UPLOADURL = Config.wwwroot + '/course/dndupload.php';\r\nconst DEBOUNCETIMER = 500;\r\nconst USERCANIGNOREFILESIZELIMITS = -1;\r\n\r\n/** @var {ProcessQueue} uploadQueue the internal uploadQueue instance.  */\r\nlet uploadQueue = null;\r\n/** @var {Object} handlerManagers the courseId indexed loaded handler managers. */\r\nlet handlerManagers = {};\r\n/** @var {Map} courseUpdates the pending course sections updates. */\r\nlet courseUpdates = new Map();\r\n/** @var {Object} errors the error messages. */\r\nlet errors = null;\r\n\r\n// Load global strings.\r\nprefetchStrings('moodle', ['addresourceoractivity', 'upload']);\r\nprefetchStrings('core_error', ['dndmaxbytes', 'dndread', 'dndupload', 'dndunkownfile']);\r\n\r\n/**\r\n * Class to upload a file into the course.\r\n * @private\r\n */\r\nclass FileUploader {\r\n    /**\r\n     * Class constructor.\r\n     *\r\n     * @param {number} courseId the course id\r\n     * @param {number} sectionId the section id\r\n     * @param {number} sectionNum the section number\r\n     * @param {File} fileInfo the file information object\r\n     * @param {Handler} handler the file selected file handler\r\n     */\r\n    constructor(courseId, sectionId, sectionNum, fileInfo, handler) {\r\n        this.courseId = courseId;\r\n        this.sectionId = sectionId;\r\n        this.sectionNum = sectionNum;\r\n        this.fileInfo = fileInfo;\r\n        this.handler = handler;\r\n    }\r\n\r\n    /**\r\n     * Execute the file upload and update the state in the given process.\r\n     *\r\n     * @param {LoadingProcess} process the process to store the upload result\r\n     */\r\n    execute(process) {\r\n        const fileInfo = this.fileInfo;\r\n        const xhr = this._createXhrRequest(process);\r\n        const formData = this._createUploadFormData();\r\n\r\n        // Try reading the file to check it is not a folder, before sending it to the server.\r\n        const reader = new FileReader();\r\n        reader.onload = function() {\r\n            // File was read OK - send it to the server.\r\n            xhr.open(\"POST\", UPLOADURL, true);\r\n            xhr.send(formData);\r\n        };\r\n        reader.onerror = function() {\r\n            // Unable to read the file (it is probably a folder) - display an error message.\r\n            process.setError(errors.dndread);\r\n        };\r\n        if (fileInfo.size > 0) {\r\n            // If this is a non-empty file, try reading the first few bytes.\r\n            // This will trigger reader.onerror() for folders and reader.onload() for ordinary, readable files.\r\n            reader.readAsText(fileInfo.slice(0, 5));\r\n        } else {\r\n            // If you call slice() on a 0-byte folder, before calling readAsText, then Firefox triggers reader.onload(),\r\n            // instead of reader.onerror().\r\n            // So, for 0-byte files, just call readAsText on the whole file (and it will trigger load/error functions as expected).\r\n            reader.readAsText(fileInfo);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Returns the bind version of execute function.\r\n     *\r\n     * This method is used to queue the process into a ProcessQueue instance.\r\n     *\r\n     * @returns {Function} the bind function to execute the process\r\n     */\r\n    getExecutionFunction() {\r\n        return this.execute.bind(this);\r\n    }\r\n\r\n    /**\r\n     * Generate a upload XHR file request.\r\n     *\r\n     * @param {LoadingProcess} process the current process\r\n     * @return {XMLHttpRequest} the XHR request\r\n     */\r\n    _createXhrRequest(process) {\r\n        const xhr = new XMLHttpRequest();\r\n        // Update the progress bar as the file is uploaded.\r\n        xhr.upload.addEventListener(\r\n            'progress',\r\n            (event) => {\r\n                if (event.lengthComputable) {\r\n                    const percent = Math.round((event.loaded * 100) / event.total);\r\n                    process.setPercentage(percent);\r\n                }\r\n            },\r\n            false\r\n        );\r\n        // Wait for the AJAX call to complete.\r\n        xhr.onreadystatechange = () => {\r\n            if (xhr.readyState == 1) {\r\n                // Add a 1% just to indicate that it is uploading.\r\n                process.setPercentage(1);\r\n            }\r\n            // State 4 is DONE. Otherwise the connection is still ongoing.\r\n            if (xhr.readyState != 4) {\r\n                return;\r\n            }\r\n            if (xhr.status == 200) {\r\n                var result = JSON.parse(xhr.responseText);\r\n                if (result && result.error == 0) {\r\n                    // All OK.\r\n                    this._finishProcess(process);\r\n                } else {\r\n                    process.setError(result.error);\r\n                }\r\n            } else {\r\n                process.setError(errors.dndupload);\r\n            }\r\n        };\r\n        return xhr;\r\n    }\r\n\r\n    /**\r\n     * Upload a file into the course.\r\n     *\r\n     * @return {FormData|null} the new form data object\r\n     */\r\n    _createUploadFormData() {\r\n        const formData = new FormData();\r\n        try {\r\n            formData.append('repo_upload_file', this.fileInfo);\r\n        } catch (error) {\r\n            throw Error(error.dndread);\r\n        }\r\n        formData.append('sesskey', Config.sesskey);\r\n        formData.append('course', this.courseId);\r\n        formData.append('section', this.sectionNum);\r\n        formData.append('module', this.handler.module);\r\n        formData.append('type', 'Files');\r\n        return formData;\r\n    }\r\n\r\n    /**\r\n     * Finishes the current process.\r\n     * @param {LoadingProcess} process the process\r\n     */\r\n    _finishProcess(process) {\r\n        addRefreshSection(this.courseId, this.sectionId);\r\n        process.setPercentage(100);\r\n        process.finish();\r\n    }\r\n}\r\n\r\n/**\r\n * The file handler manager class.\r\n *\r\n * @private\r\n */\r\nclass HandlerManager {\r\n\r\n    /** @var {Object} lastHandlers the last handlers selected per each file extension. */\r\n    lastHandlers = {};\r\n\r\n    /** @var {Handler[]|null} allHandlers all the available handlers. */\r\n    allHandlers = null;\r\n\r\n    /**\r\n     * Class constructor.\r\n     *\r\n     * @param {Number} courseId\r\n     */\r\n    constructor(courseId) {\r\n        this.courseId = courseId;\r\n        this.lastUploadId = 0;\r\n        this.courseEditor = getCourseEditor(courseId);\r\n        if (!this.courseEditor) {\r\n            throw Error('Unkown course editor');\r\n        }\r\n        this.maxbytes = this.courseEditor.get('course')?.maxbytes ?? 0;\r\n    }\r\n\r\n    /**\r\n     * Load the course file handlers.\r\n     */\r\n    async loadHandlers() {\r\n        this.allHandlers = await this.courseEditor.getFileHandlersPromise();\r\n    }\r\n\r\n    /**\r\n     * Extract the file extension from a fileInfo.\r\n     *\r\n     * @param {File} fileInfo\r\n     * @returns {String} the file extension or an empty string.\r\n     */\r\n    getFileExtension(fileInfo) {\r\n        let extension = '';\r\n        const dotpos = fileInfo.name.lastIndexOf('.');\r\n        if (dotpos != -1) {\r\n            extension = fileInfo.name.substring(dotpos + 1, fileInfo.name.length).toLowerCase();\r\n        }\r\n        return extension;\r\n    }\r\n\r\n    /**\r\n     * Check if the file is valid.\r\n     *\r\n     * @param {File} fileInfo the file info\r\n     */\r\n    validateFile(fileInfo) {\r\n        if (this.maxbytes !== USERCANIGNOREFILESIZELIMITS && fileInfo.size > this.maxbytes) {\r\n            throw Error(errors.dndmaxbytes);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the file handlers of an specific file.\r\n     *\r\n     * @param {File} fileInfo the file indo\r\n     * @return {Array} Array of handlers\r\n     */\r\n    filterHandlers(fileInfo) {\r\n        const extension = this.getFileExtension(fileInfo);\r\n        return this.allHandlers.filter(handler => handler.extension == '*' || handler.extension == extension);\r\n    }\r\n\r\n    /**\r\n     * Get the Handler to upload a specific file.\r\n     *\r\n     * It will ask the used if more than one handler is available.\r\n     *\r\n     * @param {File} fileInfo the file info\r\n     * @returns {Promise<Handler|null>} the selected handler or null if the user cancel\r\n     */\r\n    async getFileHandler(fileInfo) {\r\n        const fileHandlers = this.filterHandlers(fileInfo);\r\n        if (fileHandlers.length == 0) {\r\n            throw Error(errors.dndunkownfile);\r\n        }\r\n        let fileHandler = null;\r\n        if (fileHandlers.length == 1) {\r\n            fileHandler = fileHandlers[0];\r\n        } else {\r\n            fileHandler = await this.askHandlerToUser(fileHandlers, fileInfo);\r\n        }\r\n        return fileHandler;\r\n    }\r\n\r\n    /**\r\n     * Ask the user to select a specific handler.\r\n     *\r\n     * @param {Handler[]} fileHandlers\r\n     * @param {File} fileInfo the file info\r\n     * @return {Promise<Handler>} the selected handler\r\n     */\r\n    async askHandlerToUser(fileHandlers, fileInfo) {\r\n        const extension = this.getFileExtension(fileInfo);\r\n        // Build the modal parameters from the event data.\r\n        const modalParams = {\r\n            title: getString('addresourceoractivity', 'moodle'),\r\n            body: Templates.render(\r\n                'core_courseformat/fileuploader',\r\n                this.getModalData(\r\n                    fileHandlers,\r\n                    fileInfo,\r\n                    this.lastHandlers[extension] ?? null\r\n                )\r\n            ),\r\n            saveButtonText: getString('upload', 'moodle'),\r\n        };\r\n        // Create the modal.\r\n        const modal = await this.modalBodyRenderedPromise(modalParams);\r\n        const selectedHandler = await this.modalUserAnswerPromise(modal, fileHandlers);\r\n        // Cancel action.\r\n        if (selectedHandler === null) {\r\n            return null;\r\n        }\r\n        // Save last selected handler.\r\n        this.lastHandlers[extension] = selectedHandler.module;\r\n        return selectedHandler;\r\n    }\r\n\r\n    /**\r\n     * Generated the modal template data.\r\n     *\r\n     * @param {Handler[]} fileHandlers\r\n     * @param {File} fileInfo the file info\r\n     * @param {String|null} defaultModule the default module if any\r\n     * @return {Object} the modal template data.\r\n     */\r\n    getModalData(fileHandlers, fileInfo, defaultModule) {\r\n        const data = {\r\n            filename: fileInfo.name,\r\n            uploadid: ++this.lastUploadId,\r\n            handlers: [],\r\n        };\r\n        let hasDefault = false;\r\n        fileHandlers.forEach((handler, index) => {\r\n            const isDefault = (defaultModule == handler.module);\r\n            data.handlers.push({\r\n                ...handler,\r\n                selected: isDefault,\r\n                labelid: `fileuploader_${data.uploadid}`,\r\n                value: index,\r\n            });\r\n            hasDefault = hasDefault || isDefault;\r\n        });\r\n        if (!hasDefault && data.handlers.length > 0) {\r\n            const lastHandler = data.handlers.pop();\r\n            lastHandler.selected = true;\r\n            data.handlers.push(lastHandler);\r\n        }\r\n        return data;\r\n    }\r\n\r\n    /**\r\n     * Get the user handler choice.\r\n     *\r\n     * Wait for the user answer in the modal and resolve with the selected index.\r\n     *\r\n     * @param {Modal} modal the modal instance\r\n     * @param {Handler[]} fileHandlers the availabvle file handlers\r\n     * @return {Promise} with the option selected by the user.\r\n     */\r\n    modalUserAnswerPromise(modal, fileHandlers) {\r\n        const modalBody = getFirst(modal.getBody());\r\n        return new Promise((resolve, reject) => {\r\n            modal.getRoot().on(\r\n                ModalEvents.save,\r\n                event => {\r\n                    // Get the selected option.\r\n                    const index = modalBody.querySelector('input:checked').value;\r\n                    event.preventDefault();\r\n                    modal.destroy();\r\n                    if (!fileHandlers[index]) {\r\n                        reject('Invalid handler selected');\r\n                    }\r\n                    resolve(fileHandlers[index]);\r\n\r\n                }\r\n            );\r\n            modal.getRoot().on(\r\n                ModalEvents.cancel,\r\n                () => {\r\n                    resolve(null);\r\n                }\r\n            );\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create a new modal and return a Promise to the body rendered.\r\n     *\r\n     * @param {Object} modalParams the modal params\r\n     * @returns {Promise} the modal body rendered promise\r\n     */\r\n    modalBodyRenderedPromise(modalParams) {\r\n        return new Promise((resolve, reject) => {\r\n            ModalSaveCancel.create(modalParams).then((modal) => {\r\n                modal.setRemoveOnClose(true);\r\n                // Handle body loading event.\r\n                modal.getRoot().on(ModalEvents.bodyRendered, () => {\r\n                    resolve(modal);\r\n                });\r\n                // Configure some extra modal params.\r\n                if (modalParams.saveButtonText !== undefined) {\r\n                    modal.setSaveButtonText(modalParams.saveButtonText);\r\n                }\r\n                modal.show();\r\n                return;\r\n            }).catch(() => {\r\n                reject(`Cannot load modal content`);\r\n            });\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * Add a section to refresh.\r\n *\r\n * @param {number} courseId the course id\r\n * @param {number} sectionId the seciton id\r\n */\r\nfunction addRefreshSection(courseId, sectionId) {\r\n    let refresh = courseUpdates.get(courseId);\r\n    if (!refresh) {\r\n        refresh = new Set();\r\n    }\r\n    refresh.add(sectionId);\r\n    courseUpdates.set(courseId, refresh);\r\n    refreshCourseEditors();\r\n}\r\n\r\n/**\r\n * Debounced processing all pending course refreshes.\r\n * @private\r\n */\r\nconst refreshCourseEditors = debounce(\r\n    () => {\r\n        const refreshes = courseUpdates;\r\n        courseUpdates = new Map();\r\n        refreshes.forEach((sectionIds, courseId) => {\r\n            const courseEditor = getCourseEditor(courseId);\r\n            if (!courseEditor) {\r\n                return;\r\n            }\r\n            courseEditor.dispatch('sectionState', [...sectionIds]);\r\n        });\r\n    },\r\n    DEBOUNCETIMER\r\n);\r\n\r\n/**\r\n * Load and return the course handler manager instance.\r\n *\r\n * @param {Number} courseId the course Id to load\r\n * @returns {Promise<HandlerManager>} promise of the the loaded handleManager\r\n */\r\nasync function loadCourseHandlerManager(courseId) {\r\n    if (handlerManagers[courseId] !== undefined) {\r\n        return handlerManagers[courseId];\r\n    }\r\n    const handlerManager = new HandlerManager(courseId);\r\n    await handlerManager.loadHandlers();\r\n    handlerManagers[courseId] = handlerManager;\r\n    return handlerManagers[courseId];\r\n}\r\n\r\n/**\r\n * Load all the erros messages at once in the module \"errors\" variable.\r\n * @param {Number} courseId the course id\r\n */\r\nasync function loadErrorStrings(courseId) {\r\n    if (errors !== null) {\r\n        return;\r\n    }\r\n    const courseEditor = getCourseEditor(courseId);\r\n    const maxbytestext = courseEditor.get('course')?.maxbytestext ?? '0';\r\n\r\n    errors = {};\r\n    const allStrings = [\r\n        {key: 'dndmaxbytes', component: 'core_error', param: {size: maxbytestext}},\r\n        {key: 'dndread', component: 'core_error'},\r\n        {key: 'dndupload', component: 'core_error'},\r\n        {key: 'dndunkownfile', component: 'core_error'},\r\n    ];\r\n\r\n    const loadedStrings = await getStrings(allStrings);\r\n    allStrings.forEach(({key}, index) => {\r\n        errors[key] = loadedStrings[index];\r\n    });\r\n}\r\n\r\n/**\r\n * Start a batch file uploading into the course.\r\n *\r\n * @private\r\n * @param {number} courseId the course id.\r\n * @param {number} sectionId the section id.\r\n * @param {number} sectionNum the section number.\r\n * @param {File} fileInfo the file information object\r\n * @param {HandlerManager} handlerManager the course handler manager\r\n */\r\nconst queueFileUpload = async function(courseId, sectionId, sectionNum, fileInfo, handlerManager) {\r\n    let handler;\r\n    uploadQueue = await processMonitor.createProcessQueue();\r\n    try {\r\n        handlerManager.validateFile(fileInfo);\r\n        handler = await handlerManager.getFileHandler(fileInfo);\r\n    } catch (error) {\r\n        uploadQueue.addError(fileInfo.name, error.message);\r\n        return;\r\n    }\r\n    // If we don't have a handler means the user cancel the upload.\r\n    if (!handler) {\r\n        return;\r\n    }\r\n    const fileProcessor = new FileUploader(courseId, sectionId, sectionNum, fileInfo, handler);\r\n    uploadQueue.addPending(fileInfo.name, fileProcessor.getExecutionFunction());\r\n};\r\n\r\n/**\r\n * Upload a file to the course.\r\n *\r\n * This method will show any necesary modal to handle the request.\r\n *\r\n * @param {number} courseId the course id\r\n * @param {number} sectionId the section id\r\n * @param {number} sectionNum the section number\r\n * @param {Array} files and array of files\r\n */\r\nexport const uploadFilesToCourse = async function(courseId, sectionId, sectionNum, files) {\r\n    // Get the course handlers.\r\n    const handlerManager = await loadCourseHandlerManager(courseId);\r\n    await loadErrorStrings(courseId);\r\n    for (let index = 0; index < files.length; index++) {\r\n        const fileInfo = files[index];\r\n        await queueFileUpload(courseId, sectionId, sectionNum, fileInfo, handlerManager);\r\n    }\r\n};\r\n"],"names":["_interopRequireDefault","e","__esModule","default","_config","_modal_save_cancel","_modal_events","_templates","UPLOADURL","Config","wwwroot","uploadQueue","handlerManagers","courseUpdates","Map","errors","prefetchStrings","FileUploader","constructor","courseId","sectionId","sectionNum","fileInfo","handler","this","execute","process","xhr","_createXhrRequest","formData","_createUploadFormData","reader","FileReader","onload","open","send","onerror","setError","dndread","size","readAsText","slice","getExecutionFunction","bind","XMLHttpRequest","upload","addEventListener","event","lengthComputable","percent","Math","round","loaded","total","setPercentage","onreadystatechange","readyState","status","result","JSON","parse","responseText","error","_finishProcess","dndupload","FormData","append","Error","sesskey","module","refresh","get","Set","add","set","refreshCourseEditors","addRefreshSection","finish","HandlerManager","lastHandlers","allHandlers","lastUploadId","courseEditor","getCourseEditor","maxbytes","loadHandlers","getFileHandlersPromise","getFileExtension","extension","dotpos","name","lastIndexOf","substring","length","toLowerCase","validateFile","dndmaxbytes","filterHandlers","filter","getFileHandler","fileHandlers","dndunkownfile","fileHandler","askHandlerToUser","modalParams","title","getString","body","Templates","render","getModalData","saveButtonText","modal","modalBodyRenderedPromise","selectedHandler","modalUserAnswerPromise","defaultModule","data","filename","uploadid","handlers","hasDefault","forEach","index","isDefault","push","selected","labelid","value","lastHandler","pop","modalBody","getFirst","getBody","Promise","resolve","reject","getRoot","on","ModalEvents","save","querySelector","preventDefault","destroy","cancel","ModalSaveCancel","create","then","setRemoveOnClose","bodyRendered","undefined","setSaveButtonText","show","catch","debounce","refreshes","sectionIds","dispatch","queueFileUpload","async","handlerManager","processMonitor","createProcessQueue","addError","message","fileProcessor","addPending","_exports","uploadFilesToCourse","files","loadCourseHandlerManager","maxbytestext","allStrings","key","component","param","loadedStrings","getStrings","_ref","loadErrorStrings"],"mappings":"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"}